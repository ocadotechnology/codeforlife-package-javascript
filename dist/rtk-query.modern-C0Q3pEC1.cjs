"use strict";const D=require("@reduxjs/toolkit");var Xe=Symbol.for("immer-nothing"),he=Symbol.for("immer-draftable"),J=Symbol.for("immer-state"),Et=process.env.NODE_ENV!=="production"?[function(e){return`The plugin for '${e}' has not been loaded into Immer. To enable the plugin, import and call \`enable${e}()\` when initializing your application.`},function(e){return`produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${e}'`},"This object has been frozen and should not be mutated",function(e){return"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? "+e},"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.","Immer forbids circular references","The first or second argument to `produce` must be a function","The third argument to `produce` must be a function or undefined","First argument to `createDraft` must be a plain object, an array, or an immerable object","First argument to `finishDraft` must be a draft returned by `createDraft`",function(e){return`'current' expects a draft, got: ${e}`},"Object.defineProperty() cannot be used on an Immer draft","Object.setPrototypeOf() cannot be used on an Immer draft","Immer only supports deleting array indices","Immer only supports setting array indices and the 'length' property",function(e){return`'original' expects a draft, got: ${e}`}]:[];function B(e,...t){if(process.env.NODE_ENV!=="production"){const n=Et[e],r=typeof n=="function"?n.apply(null,t):n;throw new Error(`[Immer] ${r}`)}throw new Error(`[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`)}var ce=Object.getPrototypeOf;function te(e){return!!e&&!!e[J]}function ne(e){return e?At(e)||Array.isArray(e)||!!e[he]||!!e.constructor?.[he]||we(e)||Re(e):!1}var Kt=Object.prototype.constructor.toString();function At(e){if(!e||typeof e!="object")return!1;const t=ce(e);if(t===null)return!0;const n=Object.hasOwnProperty.call(t,"constructor")&&t.constructor;return n===Object?!0:typeof n=="function"&&Function.toString.call(n)===Kt}function Ut(e){return te(e)||B(15,e),e[J].base_}function me(e,t){ae(e)===0?Reflect.ownKeys(e).forEach(n=>{t(n,e[n],e)}):e.forEach((n,r)=>t(r,n,e))}function ae(e){const t=e[J];return t?t.type_:Array.isArray(e)?1:we(e)?2:Re(e)?3:0}function ge(e,t){return ae(e)===2?e.has(t):Object.prototype.hasOwnProperty.call(e,t)}function je(e,t){return ae(e)===2?e.get(t):e[t]}function Ot(e,t,n){const r=ae(e);r===2?e.set(t,n):r===3?e.add(n):e[t]=n}function Vt(e,t){return e===t?e!==0||1/e===1/t:e!==e&&t!==t}function we(e){return e instanceof Map}function Re(e){return e instanceof Set}function oe(e){return e.copy_||e.base_}function Ke(e,t){if(we(e))return new Map(e);if(Re(e))return new Set(e);if(Array.isArray(e))return Array.prototype.slice.call(e);const n=At(e);if(t===!0||t==="class_only"&&!n){const r=Object.getOwnPropertyDescriptors(e);delete r[J];let i=Reflect.ownKeys(r);for(let y=0;y<i.length;y++){const d=i[y],v=r[d];v.writable===!1&&(v.writable=!0,v.configurable=!0),(v.get||v.set)&&(r[d]={configurable:!0,writable:!0,enumerable:v.enumerable,value:e[d]})}return Object.create(ce(e),r)}else{const r=ce(e);if(r!==null&&n)return{...e};const i=Object.create(r);return Object.assign(i,e)}}function Ze(e,t=!1){return Qe(e)||te(e)||!ne(e)||(ae(e)>1&&(e.set=e.add=e.clear=e.delete=Wt),Object.freeze(e),t&&Object.entries(e).forEach(([n,r])=>Ze(r,!0))),e}function Wt(){B(2)}function Qe(e){return Object.isFrozen(e)}var Ue={};function ue(e){const t=Ue[e];return t||B(0,e),t}function Bt(e,t){Ue[e]||(Ue[e]=t)}var ve;function It(){return ve}function Lt(e,t){return{drafts_:[],parent_:e,immer_:t,canAutoFreeze_:!0,unfinalizedDrafts_:0}}function st(e,t){t&&(ue("Patches"),e.patches_=[],e.inversePatches_=[],e.patchListener_=t)}function Ve(e){We(e),e.drafts_.forEach(Ht),e.drafts_=null}function We(e){e===ve&&(ve=e.parent_)}function ot(e){return ve=Lt(ve,e)}function Ht(e){const t=e[J];t.type_===0||t.type_===1?t.revoke_():t.revoked_=!0}function ct(e,t){t.unfinalizedDrafts_=t.drafts_.length;const n=t.drafts_[0];return e!==void 0&&e!==n?(n[J].modified_&&(Ve(t),B(4)),ne(e)&&(e=De(t,e),t.parent_||Te(t,e)),t.patches_&&ue("Patches").generateReplacementPatches_(n[J].base_,e,t.patches_,t.inversePatches_)):e=De(t,n,[]),Ve(t),t.patches_&&t.patchListener_(t.patches_,t.inversePatches_),e!==Xe?e:void 0}function De(e,t,n){if(Qe(t))return t;const r=t[J];if(!r)return me(t,(i,y)=>at(e,r,t,i,y,n)),t;if(r.scope_!==e)return t;if(!r.modified_)return Te(e,r.base_,!0),r.base_;if(!r.finalized_){r.finalized_=!0,r.scope_.unfinalizedDrafts_--;const i=r.copy_;let y=i,d=!1;r.type_===3&&(y=new Set(i),i.clear(),d=!0),me(y,(v,T)=>at(e,r,i,v,T,n,d)),Te(e,i,!1),n&&e.patches_&&ue("Patches").generatePatches_(r,n,e.patches_,e.inversePatches_)}return r.copy_}function at(e,t,n,r,i,y,d){if(process.env.NODE_ENV!=="production"&&i===n&&B(5),te(i)){const v=y&&t&&t.type_!==3&&!ge(t.assigned_,r)?y.concat(r):void 0,T=De(e,i,v);if(Ot(n,r,T),te(T))e.canAutoFreeze_=!1;else return}else d&&n.add(i);if(ne(i)&&!Qe(i)){if(!e.immer_.autoFreeze_&&e.unfinalizedDrafts_<1)return;De(e,i),(!t||!t.scope_.parent_)&&typeof r!="symbol"&&Object.prototype.propertyIsEnumerable.call(n,r)&&Te(e,i)}}function Te(e,t,n=!1){!e.parent_&&e.immer_.autoFreeze_&&e.canAutoFreeze_&&Ze(t,n)}function Jt(e,t){const n=Array.isArray(e),r={type_:n?1:0,scope_:t?t.scope_:It(),modified_:!1,finalized_:!1,assigned_:{},parent_:t,base_:e,draft_:null,copy_:null,revoke_:null,isManual_:!1};let i=r,y=et;n&&(i=[r],y=be);const{revoke:d,proxy:v}=Proxy.revocable(i,y);return r.draft_=v,r.revoke_=d,v}var et={get(e,t){if(t===J)return e;const n=oe(e);if(!ge(n,t))return Yt(e,n,t);const r=n[t];return e.finalized_||!ne(r)?r:r===xe(e.base_,t)?(ze(e),e.copy_[t]=Le(r,e)):r},has(e,t){return t in oe(e)},ownKeys(e){return Reflect.ownKeys(oe(e))},set(e,t,n){const r=Dt(oe(e),t);if(r?.set)return r.set.call(e.draft_,n),!0;if(!e.modified_){const i=xe(oe(e),t),y=i?.[J];if(y&&y.base_===n)return e.copy_[t]=n,e.assigned_[t]=!1,!0;if(Vt(n,i)&&(n!==void 0||ge(e.base_,t)))return!0;ze(e),Be(e)}return e.copy_[t]===n&&(n!==void 0||t in e.copy_)||Number.isNaN(n)&&Number.isNaN(e.copy_[t])||(e.copy_[t]=n,e.assigned_[t]=!0),!0},deleteProperty(e,t){return xe(e.base_,t)!==void 0||t in e.base_?(e.assigned_[t]=!1,ze(e),Be(e)):delete e.assigned_[t],e.copy_&&delete e.copy_[t],!0},getOwnPropertyDescriptor(e,t){const n=oe(e),r=Reflect.getOwnPropertyDescriptor(n,t);return r&&{writable:!0,configurable:e.type_!==1||t!=="length",enumerable:r.enumerable,value:n[t]}},defineProperty(){B(11)},getPrototypeOf(e){return ce(e.base_)},setPrototypeOf(){B(12)}},be={};me(et,(e,t)=>{be[e]=function(){return arguments[0]=arguments[0][0],t.apply(this,arguments)}});be.deleteProperty=function(e,t){return process.env.NODE_ENV!=="production"&&isNaN(parseInt(t))&&B(13),be.set.call(this,e,t,void 0)};be.set=function(e,t,n){return process.env.NODE_ENV!=="production"&&t!=="length"&&isNaN(parseInt(t))&&B(14),et.set.call(this,e[0],t,n,e[0])};function xe(e,t){const n=e[J];return(n?oe(n):e)[t]}function Yt(e,t,n){const r=Dt(t,n);return r?"value"in r?r.value:r.get?.call(e.draft_):void 0}function Dt(e,t){if(!(t in e))return;let n=ce(e);for(;n;){const r=Object.getOwnPropertyDescriptor(n,t);if(r)return r;n=ce(n)}}function Be(e){e.modified_||(e.modified_=!0,e.parent_&&Be(e.parent_))}function ze(e){e.copy_||(e.copy_=Ke(e.base_,e.scope_.immer_.useStrictShallowCopy_))}var Gt=class{constructor(e){this.autoFreeze_=!0,this.useStrictShallowCopy_=!1,this.produce=(t,n,r)=>{if(typeof t=="function"&&typeof n!="function"){const y=n;n=t;const d=this;return function(T=y,...P){return d.produce(T,I=>n.call(this,I,...P))}}typeof n!="function"&&B(6),r!==void 0&&typeof r!="function"&&B(7);let i;if(ne(t)){const y=ot(this),d=Le(t,void 0);let v=!0;try{i=n(d),v=!1}finally{v?Ve(y):We(y)}return st(y,r),ct(i,y)}else if(!t||typeof t!="object"){if(i=n(t),i===void 0&&(i=t),i===Xe&&(i=void 0),this.autoFreeze_&&Ze(i,!0),r){const y=[],d=[];ue("Patches").generateReplacementPatches_(t,i,y,d),r(y,d)}return i}else B(1,t)},this.produceWithPatches=(t,n)=>{if(typeof t=="function")return(d,...v)=>this.produceWithPatches(d,T=>t(T,...v));let r,i;return[this.produce(t,n,(d,v)=>{r=d,i=v}),r,i]},typeof e?.autoFreeze=="boolean"&&this.setAutoFreeze(e.autoFreeze),typeof e?.useStrictShallowCopy=="boolean"&&this.setUseStrictShallowCopy(e.useStrictShallowCopy)}createDraft(e){ne(e)||B(8),te(e)&&(e=Xt(e));const t=ot(this),n=Le(e,void 0);return n[J].isManual_=!0,We(t),n}finishDraft(e,t){const n=e&&e[J];(!n||!n.isManual_)&&B(9);const{scope_:r}=n;return st(r,t),ct(void 0,r)}setAutoFreeze(e){this.autoFreeze_=e}setUseStrictShallowCopy(e){this.useStrictShallowCopy_=e}applyPatches(e,t){let n;for(n=t.length-1;n>=0;n--){const i=t[n];if(i.path.length===0&&i.op==="replace"){e=i.value;break}}n>-1&&(t=t.slice(n+1));const r=ue("Patches").applyPatches_;return te(e)?r(e,t):this.produce(e,i=>r(i,t))}};function Le(e,t){const n=we(e)?ue("MapSet").proxyMap_(e,t):Re(e)?ue("MapSet").proxySet_(e,t):Jt(e,t);return(t?t.scope_:It()).drafts_.push(n),n}function Xt(e){return te(e)||B(10,e),Tt(e)}function Tt(e){if(!ne(e)||Qe(e))return e;const t=e[J];let n;if(t){if(!t.modified_)return t.base_;t.finalized_=!0,n=Ke(e,t.scope_.immer_.useStrictShallowCopy_)}else n=Ke(e,!0);return me(n,(r,i)=>{Ot(n,r,Tt(i))}),t&&(t.finalized_=!1),n}function Zt(){process.env.NODE_ENV!=="production"&&Et.push('Sets cannot have "replace" patches.',function(s){return"Unsupported patch operation: "+s},function(s){return"Cannot apply patch, path doesn't resolve: "+s},"Patching reserved attributes like __proto__, prototype and constructor is not allowed");const t="replace",n="add",r="remove";function i(s,l,h,S){switch(s.type_){case 0:case 2:return d(s,l,h,S);case 1:return y(s,l,h,S);case 3:return v(s,l,h,S)}}function y(s,l,h,S){let{base_:g,assigned_:o}=s,_=s.copy_;_.length<g.length&&([g,_]=[_,g],[h,S]=[S,h]);for(let u=0;u<g.length;u++)if(o[u]&&_[u]!==g[u]){const a=l.concat([u]);h.push({op:t,path:a,value:b(_[u])}),S.push({op:t,path:a,value:b(g[u])})}for(let u=g.length;u<_.length;u++){const a=l.concat([u]);h.push({op:n,path:a,value:b(_[u])})}for(let u=_.length-1;g.length<=u;--u){const a=l.concat([u]);S.push({op:r,path:a})}}function d(s,l,h,S){const{base_:g,copy_:o}=s;me(s.assigned_,(_,u)=>{const a=je(g,_),w=je(o,_),O=u?ge(g,_)?t:n:r;if(a===w&&O===t)return;const E=l.concat(_);h.push(O===r?{op:O,path:E}:{op:O,path:E,value:w}),S.push(O===n?{op:r,path:E}:O===r?{op:n,path:E,value:b(a)}:{op:t,path:E,value:b(a)})})}function v(s,l,h,S){let{base_:g,copy_:o}=s,_=0;g.forEach(u=>{if(!o.has(u)){const a=l.concat([_]);h.push({op:r,path:a,value:u}),S.unshift({op:n,path:a,value:u})}_++}),_=0,o.forEach(u=>{if(!g.has(u)){const a=l.concat([_]);h.push({op:n,path:a,value:u}),S.unshift({op:r,path:a,value:u})}_++})}function T(s,l,h,S){h.push({op:t,path:[],value:l===Xe?void 0:l}),S.push({op:t,path:[],value:s})}function P(s,l){return l.forEach(h=>{const{path:S,op:g}=h;let o=s;for(let w=0;w<S.length-1;w++){const O=ae(o);let E=S[w];typeof E!="string"&&typeof E!="number"&&(E=""+E),(O===0||O===1)&&(E==="__proto__"||E==="constructor")&&B(19),typeof o=="function"&&E==="prototype"&&B(19),o=je(o,E),typeof o!="object"&&B(18,S.join("/"))}const _=ae(o),u=I(h.value),a=S[S.length-1];switch(g){case t:switch(_){case 2:return o.set(a,u);case 3:B(16);default:return o[a]=u}case n:switch(_){case 1:return a==="-"?o.push(u):o.splice(a,0,u);case 2:return o.set(a,u);case 3:return o.add(u);default:return o[a]=u}case r:switch(_){case 1:return o.splice(a,1);case 2:return o.delete(a);case 3:return o.delete(h.value);default:return delete o[a]}default:B(17,g)}}),s}function I(s){if(!ne(s))return s;if(Array.isArray(s))return s.map(I);if(we(s))return new Map(Array.from(s.entries()).map(([h,S])=>[h,I(S)]));if(Re(s))return new Set(Array.from(s).map(I));const l=Object.create(ce(s));for(const h in s)l[h]=I(s[h]);return ge(s,he)&&(l[he]=s[he]),l}function b(s){return te(s)?I(s):s}Bt("Patches",{applyPatches_:P,generatePatches_:i,generateReplacementPatches_:T})}var Y=new Gt;Y.produce;var Ct=Y.produceWithPatches.bind(Y);Y.setAutoFreeze.bind(Y);Y.setUseStrictShallowCopy.bind(Y);var ut=Y.applyPatches.bind(Y);Y.createDraft.bind(Y);Y.finishDraft.bind(Y);var en=class extends Error{issues;constructor(e){super(e[0].message),this.name="SchemaError",this.issues=e}},tn=(e,t,n)=>{if(t.length===1&&t[0]===n){let r=!1;try{const i={};e(i)===i&&(r=!0)}catch{}if(r){let i;try{throw new Error}catch(y){({stack:i}=y)}console.warn(`The result function returned its own inputs without modification. e.g
\`createSelector([state => state.todos], todos => todos)\`
This could lead to inefficient memoization and unnecessary re-renders.
Ensure transformation logic is in the result function, and extraction logic is in the input selectors.`,{stack:i})}}},nn=(e,t,n)=>{const{memoize:r,memoizeOptions:i}=t,{inputSelectorResults:y,inputSelectorResultsCopy:d}=e,v=r(()=>({}),...i);if(!(v.apply(null,y)===v.apply(null,d))){let P;try{throw new Error}catch(I){({stack:P}=I)}console.warn(`An input selector returned a different result when passed same arguments.
This means your output selector will likely run more frequently than intended.
Avoid returning a new reference inside your input selector, e.g.
\`createSelector([state => state.todos.map(todo => todo.id)], todoIds => todoIds.length)\``,{arguments:n,firstInputs:y,secondInputs:d,stack:P})}},rn={inputStabilityCheck:"once",identityFunctionCheck:"once"};function sn(e,t=`expected a function, instead received ${typeof e}`){if(typeof e!="function")throw new TypeError(t)}function on(e,t=`expected an object, instead received ${typeof e}`){if(typeof e!="object")throw new TypeError(t)}function cn(e,t="expected all items to be functions, instead received the following types: "){if(!e.every(n=>typeof n=="function")){const n=e.map(r=>typeof r=="function"?`function ${r.name||"unnamed"}()`:typeof r).join(", ");throw new TypeError(`${t}[${n}]`)}}var lt=e=>Array.isArray(e)?e:[e];function an(e){const t=Array.isArray(e[0])?e[0]:e;return cn(t,"createSelector expects all input-selectors to be functions, but received the following types: "),t}function ft(e,t){const n=[],{length:r}=e;for(let i=0;i<r;i++)n.push(e[i].apply(null,t));return n}var un=(e,t)=>{const{identityFunctionCheck:n,inputStabilityCheck:r}={...rn,...t};return{identityFunctionCheck:{shouldRun:n==="always"||n==="once"&&e,run:tn},inputStabilityCheck:{shouldRun:r==="always"||r==="once"&&e,run:nn}}},ln=class{constructor(e){this.value=e}deref(){return this.value}},fn=typeof WeakRef<"u"?WeakRef:ln,dn=0,dt=1;function Ee(){return{s:dn,v:void 0,o:null,p:null}}function Ce(e,t={}){let n=Ee();const{resultEqualityCheck:r}=t;let i,y=0;function d(){let v=n;const{length:T}=arguments;for(let b=0,s=T;b<s;b++){const l=arguments[b];if(typeof l=="function"||typeof l=="object"&&l!==null){let h=v.o;h===null&&(v.o=h=new WeakMap);const S=h.get(l);S===void 0?(v=Ee(),h.set(l,v)):v=S}else{let h=v.p;h===null&&(v.p=h=new Map);const S=h.get(l);S===void 0?(v=Ee(),h.set(l,v)):v=S}}const P=v;let I;if(v.s===dt)I=v.v;else if(I=e.apply(null,arguments),y++,r){const b=i?.deref?.()??i;b!=null&&r(b,I)&&(I=b,y!==0&&y--),i=typeof I=="object"&&I!==null||typeof I=="function"?new fn(I):I}return P.s=dt,P.v=I,I}return d.clearCache=()=>{n=Ee(),d.resetResultsCount()},d.resultsCount=()=>y,d.resetResultsCount=()=>{y=0},d}function pn(e,...t){const n=typeof e=="function"?{memoize:e,memoizeOptions:t}:e,r=(...i)=>{let y=0,d=0,v,T={},P=i.pop();typeof P=="object"&&(T=P,P=i.pop()),sn(P,`createSelector expects an output function after the inputs, but received: [${typeof P}]`);const I={...n,...T},{memoize:b,memoizeOptions:s=[],argsMemoize:l=Ce,argsMemoizeOptions:h=[],devModeChecks:S={}}=I,g=lt(s),o=lt(h),_=an(i),u=b(function(){return y++,P.apply(null,arguments)},...g);let a=!0;const w=l(function(){d++;const E=ft(_,arguments);if(v=u.apply(null,E),process.env.NODE_ENV!=="production"){const{identityFunctionCheck:C,inputStabilityCheck:A}=un(a,S);if(C.shouldRun&&C.run(P,E,v),A.shouldRun){const m=ft(_,arguments);A.run({inputSelectorResults:E,inputSelectorResultsCopy:m},{memoize:b,memoizeOptions:g},arguments)}a&&(a=!1)}return v},...o);return Object.assign(w,{resultFunc:P,memoizedResultFunc:u,dependencies:_,dependencyRecomputations:()=>d,resetDependencyRecomputations:()=>{d=0},lastResult:()=>v,recomputations:()=>y,resetRecomputations:()=>{y=0},memoize:b,argsMemoize:l})};return Object.assign(r,{withTypes:()=>r}),r}var Nt=pn(Ce),yn=Object.assign((e,t=Nt)=>{on(e,`createStructuredSelector expects first argument to be an object where each property is a selector, instead received a ${typeof e}`);const n=Object.keys(e),r=n.map(y=>e[y]);return t(r,(...y)=>y.reduce((d,v,T)=>(d[n[T]]=v,d),{}))},{withTypes:()=>yn}),qt=(e=>(e.uninitialized="uninitialized",e.pending="pending",e.fulfilled="fulfilled",e.rejected="rejected",e))(qt||{});function pt(e){return{status:e,isUninitialized:e==="uninitialized",isLoading:e==="pending",isSuccess:e==="fulfilled",isError:e==="rejected"}}var yt=D.isPlainObject;function Qt(e,t){if(e===t||!(yt(e)&&yt(t)||Array.isArray(e)&&Array.isArray(t)))return t;const n=Object.keys(t),r=Object.keys(e);let i=n.length===r.length;const y=Array.isArray(t)?[]:{};for(const d of n)y[d]=Qt(e[d],t[d]),i&&(i=e[d]===y[d]);return i?e:y}function pe(e){let t=0;for(const n in e)t++;return t}var ht=e=>[].concat(...e);function hn(e){return new RegExp("(^|:)//").test(e)}function mn(){return typeof document>"u"?!0:document.visibilityState!=="hidden"}function Ne(e){return e!=null}function gn(){return typeof navigator>"u"||navigator.onLine===void 0?!0:navigator.onLine}var vn=e=>e.replace(/\/$/,""),bn=e=>e.replace(/^\//,"");function Sn(e,t){if(!e)return t;if(!t)return e;if(hn(t))return t;const n=e.endsWith("/")||!t.startsWith("?")?"/":"";return e=vn(e),t=bn(t),`${e}${n}${t}`}function _n(e,t,n){return e.has(t)?e.get(t):e.set(t,n).get(t)}var mt=(...e)=>fetch(...e),wn=e=>e.status>=200&&e.status<=299,Rn=e=>/ion\/(vnd\.api\+)?json/.test(e.get("content-type")||"");function gt(e){if(!D.isPlainObject(e))return e;const t={...e};for(const[n,r]of Object.entries(t))r===void 0&&delete t[n];return t}function Pn({baseUrl:e,prepareHeaders:t=b=>b,fetchFn:n=mt,paramsSerializer:r,isJsonContentType:i=Rn,jsonContentType:y="application/json",jsonReplacer:d,timeout:v,responseHandler:T,validateStatus:P,...I}={}){return typeof fetch>"u"&&n===mt&&console.warn("Warning: `fetch` is not available. Please supply a custom `fetchFn` property to use `fetchBaseQuery` on SSR environments."),async(s,l,h)=>{const{getState:S,extra:g,endpoint:o,forced:_,type:u}=l;let a,{url:w,headers:O=new Headers(I.headers),params:E=void 0,responseHandler:C=T??"json",validateStatus:A=P??wn,timeout:m=v,...c}=typeof s=="string"?{url:s}:s,f,p=l.signal;m&&(f=new AbortController,l.signal.addEventListener("abort",f.abort),p=f.signal);let R={...I,signal:p,...c};O=new Headers(gt(O)),R.headers=await t(O,{getState:S,arg:s,extra:g,endpoint:o,forced:_,type:u,extraOptions:h})||O;const N=x=>typeof x=="object"&&(D.isPlainObject(x)||Array.isArray(x)||typeof x.toJSON=="function");if(!R.headers.has("content-type")&&N(R.body)&&R.headers.set("content-type",y),N(R.body)&&i(R.headers)&&(R.body=JSON.stringify(R.body,d)),E){const x=~w.indexOf("?")?"&":"?",k=r?r(E):new URLSearchParams(gt(E));w+=x+k}w=Sn(e,w);const M=new Request(w,R);a={request:new Request(w,R)};let Q,q=!1,$=f&&setTimeout(()=>{q=!0,f.abort()},m);try{Q=await n(M)}catch(x){return{error:{status:q?"TIMEOUT_ERROR":"FETCH_ERROR",error:String(x)},meta:a}}finally{$&&clearTimeout($),f?.signal.removeEventListener("abort",f.abort)}const U=Q.clone();a.response=U;let H,K="";try{let x;if(await Promise.all([b(Q,C).then(k=>H=k,k=>x=k),U.text().then(k=>K=k,()=>{})]),x)throw x}catch(x){return{error:{status:"PARSING_ERROR",originalStatus:Q.status,data:K,error:String(x)},meta:a}}return A(Q,H)?{data:H,meta:a}:{error:{status:Q.status,data:H},meta:a}};async function b(s,l){if(typeof l=="function")return l(s);if(l==="content-type"&&(l=i(s.headers)?"json":"text"),l==="json"){const h=await s.text();return h.length?JSON.parse(h):null}return s.text()}}var vt=class{constructor(e,t=void 0){this.value=e,this.meta=t}},ke=D.createAction("__rtkq/focused"),tt=D.createAction("__rtkq/unfocused"),Me=D.createAction("__rtkq/online"),nt=D.createAction("__rtkq/offline"),$e=!1;function En(e,t){function n(){const r=()=>e(ke()),i=()=>e(tt()),y=()=>e(Me()),d=()=>e(nt()),v=()=>{window.document.visibilityState==="visible"?r():i()};return $e||typeof window<"u"&&window.addEventListener&&(window.addEventListener("visibilitychange",v,!1),window.addEventListener("focus",r,!1),window.addEventListener("online",y,!1),window.addEventListener("offline",d,!1),$e=!0),()=>{window.removeEventListener("focus",r),window.removeEventListener("visibilitychange",v),window.removeEventListener("online",y),window.removeEventListener("offline",d),$e=!1}}return n()}function Fe(e){return e.type==="query"}function An(e){return e.type==="mutation"}function Pe(e){return e.type==="infinitequery"}function qe(e){return Fe(e)||Pe(e)}function rt(e,t,n,r,i,y){return On(e)?e(t,n,r,i).filter(Ne).map(He).map(y):Array.isArray(e)?e.map(He).map(y):[]}function On(e){return typeof e=="function"}function He(e){return typeof e=="string"?{type:e}:e}function In(e,t){return e.catch(t)}var Se=Symbol("forceQueryFn"),Je=e=>typeof e[Se]=="function";function Dn({serializeQueryArgs:e,queryThunk:t,infiniteQueryThunk:n,mutationThunk:r,api:i,context:y}){const d=new Map,v=new Map,{unsubscribeQueryResult:T,removeMutationResult:P,updateSubscriptionOptions:I}=i.internalActions;return{buildInitiateQuery:o,buildInitiateInfiniteQuery:_,buildInitiateMutation:u,getRunningQueryThunk:b,getRunningMutationThunk:s,getRunningQueriesThunk:l,getRunningMutationsThunk:h};function b(a,w){return O=>{const E=y.endpointDefinitions[a],C=e({queryArgs:w,endpointDefinition:E,endpointName:a});return d.get(O)?.[C]}}function s(a,w){return O=>v.get(O)?.[w]}function l(){return a=>Object.values(d.get(a)||{}).filter(Ne)}function h(){return a=>Object.values(v.get(a)||{}).filter(Ne)}function S(a){if(process.env.NODE_ENV!=="production"){if(S.triggered)return;const w=a(i.internalActions.internal_getRTKQSubscriptions());if(S.triggered=!0,typeof w!="object"||typeof w?.type=="string")throw new Error(process.env.NODE_ENV==="production"?D.formatProdErrorMessage(34):`Warning: Middleware for RTK-Query API at reducerPath "${i.reducerPath}" has not been added to the store.
You must add the middleware for RTK-Query to function correctly!`)}}function g(a,w){const O=(E,{subscribe:C=!0,forceRefetch:A,subscriptionOptions:m,[Se]:c,...f}={})=>(p,R)=>{const N=e({queryArgs:E,endpointDefinition:w,endpointName:a});let M;const F={...f,type:"query",subscribe:C,forceRefetch:A,subscriptionOptions:m,endpointName:a,originalArgs:E,queryCacheKey:N,[Se]:c};if(Fe(w))M=t(F);else{const{direction:V,initialPageParam:z}=f;M=n({...F,direction:V,initialPageParam:z})}const Q=i.endpoints[a].select(E),q=p(M),$=Q(R());S(p);const{requestId:U,abort:H}=q,K=$.requestId!==U,x=d.get(p)?.[N],k=()=>Q(R()),W=Object.assign(c?q.then(k):K&&!x?Promise.resolve($):Promise.all([x,q]).then(k),{arg:E,requestId:U,subscriptionOptions:m,queryCacheKey:N,abort:H,async unwrap(){const V=await W;if(V.isError)throw V.error;return V.data},refetch:()=>p(O(E,{subscribe:!1,forceRefetch:!0})),unsubscribe(){C&&p(T({queryCacheKey:N,requestId:U}))},updateSubscriptionOptions(V){W.subscriptionOptions=V,p(I({endpointName:a,requestId:U,queryCacheKey:N,options:V}))}});if(!x&&!K&&!c){const V=_n(d,p,{});V[N]=W,W.then(()=>{delete V[N],pe(V)||d.delete(p)})}return W};return O}function o(a,w){return g(a,w)}function _(a,w){return g(a,w)}function u(a){return(w,{track:O=!0,fixedCacheKey:E}={})=>(C,A)=>{const m=r({type:"mutation",endpointName:a,originalArgs:w,track:O,fixedCacheKey:E}),c=C(m);S(C);const{requestId:f,abort:p,unwrap:R}=c,N=In(c.unwrap().then(q=>({data:q})),q=>({error:q})),M=()=>{C(P({requestId:f,fixedCacheKey:E}))},F=Object.assign(N,{arg:c.arg,requestId:f,abort:p,unwrap:R,reset:M}),Q=v.get(C)||{};return v.set(C,Q),Q[f]=F,F.then(()=>{delete Q[f],pe(Q)||v.delete(C)}),E&&(Q[E]=F,F.then(()=>{Q[E]===F&&(delete Q[E],pe(Q)||v.delete(C))})),F}}}var kt=class extends en{constructor(e,t,n,r){super(e),this.value=t,this.schemaName=n,this._bqMeta=r}};async function se(e,t,n,r){const i=await e["~standard"].validate(t);if(i.issues)throw new kt(i.issues,t,n,r);return i.value}function Tn(e){return e}var ye=(e={})=>({...e,[D.SHOULD_AUTOBATCH]:!0});function Cn({reducerPath:e,baseQuery:t,context:{endpointDefinitions:n},serializeQueryArgs:r,api:i,assertTagType:y,selectors:d,onSchemaFailure:v,catchSchemaFailure:T,skipSchemaValidation:P}){const I=(c,f,p,R)=>(N,M)=>{const F=n[c],Q=r({queryArgs:f,endpointDefinition:F,endpointName:c});if(N(i.internalActions.queryResultPatched({queryCacheKey:Q,patches:p})),!R)return;const q=i.endpoints[c].select(f)(M()),$=rt(F.providesTags,q.data,void 0,f,{},y);N(i.internalActions.updateProvidedBy([{queryCacheKey:Q,providedTags:$}]))};function b(c,f,p=0){const R=[f,...c];return p&&R.length>p?R.slice(0,-1):R}function s(c,f,p=0){const R=[...c,f];return p&&R.length>p?R.slice(1):R}const l=(c,f,p,R=!0)=>(N,M)=>{const Q=i.endpoints[c].select(f)(M()),q={patches:[],inversePatches:[],undo:()=>N(i.util.patchQueryData(c,f,q.inversePatches,R))};if(Q.status==="uninitialized")return q;let $;if("data"in Q)if(ne(Q.data)){const[U,H,K]=Ct(Q.data,p);q.patches.push(...H),q.inversePatches.push(...K),$=U}else $=p(Q.data),q.patches.push({op:"replace",path:[],value:$}),q.inversePatches.push({op:"replace",path:[],value:Q.data});return q.patches.length===0||N(i.util.patchQueryData(c,f,q.patches,R)),q},h=(c,f,p)=>R=>R(i.endpoints[c].initiate(f,{subscribe:!1,forceRefetch:!0,[Se]:()=>({data:p})})),S=(c,f)=>c.query&&c[f]?c[f]:Tn,g=async(c,{signal:f,abort:p,rejectWithValue:R,fulfillWithValue:N,dispatch:M,getState:F,extra:Q})=>{const q=n[c.endpointName],{metaSchema:$,skipSchemaValidation:U=P}=q;try{let H=S(q,"transformResponse");const K={signal:f,abort:p,dispatch:M,getState:F,extra:Q,endpoint:c.endpointName,type:c.type,forced:c.type==="query"?o(c,F()):void 0,queryCacheKey:c.type==="query"?c.queryCacheKey:void 0},x=c.type==="query"?c[Se]:void 0;let k;const W=async(z,j,L,le)=>{if(j==null&&z.pages.length)return Promise.resolve({data:z});const re={queryArg:c.originalArgs,pageParam:j},fe=await V(re),Z=le?b:s;return{data:{pages:Z(z.pages,fe.data,L),pageParams:Z(z.pageParams,j,L)},meta:fe.meta}};async function V(z){let j;const{extraOptions:L,argSchema:le,rawResponseSchema:re,responseSchema:fe}=q;if(le&&!U&&(z=await se(le,z,"argSchema",{})),x?j=x():q.query?j=await t(q.query(z),K,L):j=await q.queryFn(z,K,L,G=>t(G,K,L)),typeof process<"u"&&process.env.NODE_ENV==="development"){const G=q.query?"`baseQuery`":"`queryFn`";let X;if(!j)X=`${G} did not return anything.`;else if(typeof j!="object")X=`${G} did not return an object.`;else if(j.error&&j.data)X=`${G} returned an object containing both \`error\` and \`result\`.`;else if(j.error===void 0&&j.data===void 0)X=`${G} returned an object containing neither a valid \`error\` and \`result\`. At least one of them should not be \`undefined\``;else for(const de of Object.keys(j))if(de!=="error"&&de!=="data"&&de!=="meta"){X=`The object returned by ${G} has the unknown property ${de}.`;break}X&&console.error(`Error encountered handling the endpoint ${c.endpointName}.
                  ${X}
                  It needs to return an object with either the shape \`{ data: <value> }\` or \`{ error: <value> }\` that may contain an optional \`meta\` property.
                  Object returned was:`,j)}if(j.error)throw new vt(j.error,j.meta);let{data:Z}=j;re&&!U&&(Z=await se(re,j.data,"rawResponseSchema",j.meta));let ie=await H(Z,j.meta,z);return fe&&!U&&(ie=await se(fe,ie,"responseSchema",j.meta)),{...j,data:ie}}if(c.type==="query"&&"infiniteQueryOptions"in q){const{infiniteQueryOptions:z}=q,{maxPages:j=1/0}=z;let L;const le={pages:[],pageParams:[]},re=d.selectQueryEntry(F(),c.queryCacheKey)?.data,Z=o(c,F())&&!c.direction||!re?le:re;if("direction"in c&&c.direction&&Z.pages.length){const ie=c.direction==="backward",X=(ie?Mt:Ye)(z,Z,c.originalArgs);L=await W(Z,X,j,ie)}else{const{initialPageParam:ie=z.initialPageParam}=c,G=re?.pageParams??[],X=G[0]??ie,de=G.length;L=await W(Z,X,j),x&&(L={data:L.data.pages[0]});for(let it=1;it<de;it++){const $t=Ye(z,L.data,c.originalArgs);L=await W(L.data,$t,j)}}k=L}else k=await V(c.originalArgs);return $&&!U&&k.meta&&(k.meta=await se($,k.meta,"metaSchema",k.meta)),N(k.data,ye({fulfilledTimeStamp:Date.now(),baseQueryMeta:k.meta}))}catch(H){let K=H;if(K instanceof vt){let x=S(q,"transformErrorResponse");const{rawErrorResponseSchema:k,errorResponseSchema:W}=q;let{value:V,meta:z}=K;try{k&&!U&&(V=await se(k,V,"rawErrorResponseSchema",z)),$&&!U&&(z=await se($,z,"metaSchema",z));let j=await x(V,z,c.originalArgs);return W&&!U&&(j=await se(W,j,"errorResponseSchema",z)),R(j,ye({baseQueryMeta:z}))}catch(j){K=j}}try{if(K instanceof kt){const x={endpoint:c.endpointName,arg:c.originalArgs,type:c.type,queryCacheKey:c.type==="query"?c.queryCacheKey:void 0};q.onSchemaFailure?.(K,x),v?.(K,x);const{catchSchemaFailure:k=T}=q;if(k)return R(k(K,x),ye({baseQueryMeta:K._bqMeta}))}}catch(x){K=x}throw typeof process<"u"&&process.env.NODE_ENV!=="production"?console.error(`An unhandled error occurred processing a request for the endpoint "${c.endpointName}".
In the case of an unhandled error, no tags will be "provided" or "invalidated".`,K):console.error(K),K}};function o(c,f){const p=d.selectQueryEntry(f,c.queryCacheKey),R=d.selectConfig(f).refetchOnMountOrArgChange,N=p?.fulfilledTimeStamp,M=c.forceRefetch??(c.subscribe&&R);return M?M===!0||(Number(new Date)-Number(N))/1e3>=M:!1}const _=()=>D.createAsyncThunk(`${e}/executeQuery`,g,{getPendingMeta({arg:f}){const p=n[f.endpointName];return ye({startedTimeStamp:Date.now(),...Pe(p)?{direction:f.direction}:{}})},condition(f,{getState:p}){const R=p(),N=d.selectQueryEntry(R,f.queryCacheKey),M=N?.fulfilledTimeStamp,F=f.originalArgs,Q=N?.originalArgs,q=n[f.endpointName],$=f.direction;return Je(f)?!0:N?.status==="pending"?!1:o(f,R)||Fe(q)&&q?.forceRefetch?.({currentArg:F,previousArg:Q,endpointState:N,state:R})?!0:!(M&&!$)},dispatchConditionRejection:!0}),u=_(),a=_(),w=D.createAsyncThunk(`${e}/executeMutation`,g,{getPendingMeta(){return ye({startedTimeStamp:Date.now()})}}),O=c=>"force"in c,E=c=>"ifOlderThan"in c,C=(c,f,p)=>(R,N)=>{const M=O(p)&&p.force,F=E(p)&&p.ifOlderThan,Q=($=!0)=>{const U={forceRefetch:$,isPrefetch:!0};return i.endpoints[c].initiate(f,U)},q=i.endpoints[c].select(f)(N());if(M)R(Q());else if(F){const $=q?.fulfilledTimeStamp;if(!$){R(Q());return}(Number(new Date)-Number(new Date($)))/1e3>=F&&R(Q())}else R(Q(!1))};function A(c){return f=>f?.meta?.arg?.endpointName===c}function m(c,f){return{matchPending:D.isAllOf(D.isPending(c),A(f)),matchFulfilled:D.isAllOf(D.isFulfilled(c),A(f)),matchRejected:D.isAllOf(D.isRejected(c),A(f))}}return{queryThunk:u,mutationThunk:w,infiniteQueryThunk:a,prefetch:C,updateQueryData:l,upsertQueryData:h,patchQueryData:I,buildMatchThunkActions:m}}function Ye(e,{pages:t,pageParams:n},r){const i=t.length-1;return e.getNextPageParam(t[i],t,n[i],n,r)}function Mt(e,{pages:t,pageParams:n},r){return e.getPreviousPageParam?.(t[0],t,n[0],n,r)}function Ft(e,t,n,r){return rt(n[e.meta.arg.endpointName][t],D.isFulfilled(e)?e.payload:void 0,D.isRejectedWithValue(e)?e.payload:void 0,e.meta.arg.originalArgs,"baseQueryMeta"in e.meta?e.meta.baseQueryMeta:void 0,r)}function Ae(e,t,n){const r=e[t];r&&n(r)}function _e(e){return("arg"in e?e.arg.fixedCacheKey:e.fixedCacheKey)??e.requestId}function bt(e,t,n){const r=e[_e(t)];r&&n(r)}var Oe={};function Nn({reducerPath:e,queryThunk:t,mutationThunk:n,serializeQueryArgs:r,context:{endpointDefinitions:i,apiUid:y,extractRehydrationInfo:d,hasRehydrationInfo:v},assertTagType:T,config:P}){const I=D.createAction(`${e}/resetApiState`);function b(A,m,c,f){A[m.queryCacheKey]??={status:"uninitialized",endpointName:m.endpointName},Ae(A,m.queryCacheKey,p=>{p.status="pending",p.requestId=c&&p.requestId?p.requestId:f.requestId,m.originalArgs!==void 0&&(p.originalArgs=m.originalArgs),p.startedTimeStamp=f.startedTimeStamp;const R=i[f.arg.endpointName];Pe(R)&&"direction"in m&&(p.direction=m.direction)})}function s(A,m,c,f){Ae(A,m.arg.queryCacheKey,p=>{if(p.requestId!==m.requestId&&!f)return;const{merge:R}=i[m.arg.endpointName];if(p.status="fulfilled",R)if(p.data!==void 0){const{fulfilledTimeStamp:N,arg:M,baseQueryMeta:F,requestId:Q}=m;let q=D.createNextState(p.data,$=>R($,c,{arg:M.originalArgs,baseQueryMeta:F,fulfilledTimeStamp:N,requestId:Q}));p.data=q}else p.data=c;else p.data=i[m.arg.endpointName].structuralSharing??!0?Qt(te(p.data)?Ut(p.data):p.data,c):c;delete p.error,p.fulfilledTimeStamp=m.fulfilledTimeStamp})}const l=D.createSlice({name:`${e}/queries`,initialState:Oe,reducers:{removeQueryResult:{reducer(A,{payload:{queryCacheKey:m}}){delete A[m]},prepare:D.prepareAutoBatched()},cacheEntriesUpserted:{reducer(A,m){for(const c of m.payload){const{queryDescription:f,value:p}=c;b(A,f,!0,{arg:f,requestId:m.meta.requestId,startedTimeStamp:m.meta.timestamp}),s(A,{arg:f,requestId:m.meta.requestId,fulfilledTimeStamp:m.meta.timestamp,baseQueryMeta:{}},p,!0)}},prepare:A=>({payload:A.map(f=>{const{endpointName:p,arg:R,value:N}=f,M=i[p];return{queryDescription:{type:"query",endpointName:p,originalArgs:f.arg,queryCacheKey:r({queryArgs:R,endpointDefinition:M,endpointName:p})},value:N}}),meta:{[D.SHOULD_AUTOBATCH]:!0,requestId:D.nanoid(),timestamp:Date.now()}})},queryResultPatched:{reducer(A,{payload:{queryCacheKey:m,patches:c}}){Ae(A,m,f=>{f.data=ut(f.data,c.concat())})},prepare:D.prepareAutoBatched()}},extraReducers(A){A.addCase(t.pending,(m,{meta:c,meta:{arg:f}})=>{const p=Je(f);b(m,f,p,c)}).addCase(t.fulfilled,(m,{meta:c,payload:f})=>{const p=Je(c.arg);s(m,c,f,p)}).addCase(t.rejected,(m,{meta:{condition:c,arg:f,requestId:p},error:R,payload:N})=>{Ae(m,f.queryCacheKey,M=>{if(!c){if(M.requestId!==p)return;M.status="rejected",M.error=N??R}})}).addMatcher(v,(m,c)=>{const{queries:f}=d(c);for(const[p,R]of Object.entries(f))(R?.status==="fulfilled"||R?.status==="rejected")&&(m[p]=R)})}}),h=D.createSlice({name:`${e}/mutations`,initialState:Oe,reducers:{removeMutationResult:{reducer(A,{payload:m}){const c=_e(m);c in A&&delete A[c]},prepare:D.prepareAutoBatched()}},extraReducers(A){A.addCase(n.pending,(m,{meta:c,meta:{requestId:f,arg:p,startedTimeStamp:R}})=>{p.track&&(m[_e(c)]={requestId:f,status:"pending",endpointName:p.endpointName,startedTimeStamp:R})}).addCase(n.fulfilled,(m,{payload:c,meta:f})=>{f.arg.track&&bt(m,f,p=>{p.requestId===f.requestId&&(p.status="fulfilled",p.data=c,p.fulfilledTimeStamp=f.fulfilledTimeStamp)})}).addCase(n.rejected,(m,{payload:c,error:f,meta:p})=>{p.arg.track&&bt(m,p,R=>{R.requestId===p.requestId&&(R.status="rejected",R.error=c??f)})}).addMatcher(v,(m,c)=>{const{mutations:f}=d(c);for(const[p,R]of Object.entries(f))(R?.status==="fulfilled"||R?.status==="rejected")&&p!==R?.requestId&&(m[p]=R)})}}),S={tags:{},keys:{}},g=D.createSlice({name:`${e}/invalidation`,initialState:S,reducers:{updateProvidedBy:{reducer(A,m){for(const{queryCacheKey:c,providedTags:f}of m.payload){o(A,c);for(const{type:p,id:R}of f){const N=(A.tags[p]??={})[R||"__internal_without_id"]??=[];N.includes(c)||N.push(c)}A.keys[c]=f}},prepare:D.prepareAutoBatched()}},extraReducers(A){A.addCase(l.actions.removeQueryResult,(m,{payload:{queryCacheKey:c}})=>{o(m,c)}).addMatcher(v,(m,c)=>{const{provided:f}=d(c);for(const[p,R]of Object.entries(f))for(const[N,M]of Object.entries(R)){const F=(m.tags[p]??={})[N||"__internal_without_id"]??=[];for(const Q of M)F.includes(Q)||F.push(Q)}}).addMatcher(D.isAnyOf(D.isFulfilled(t),D.isRejectedWithValue(t)),(m,c)=>{_(m,[c])}).addMatcher(l.actions.cacheEntriesUpserted.match,(m,c)=>{const f=c.payload.map(({queryDescription:p,value:R})=>({type:"UNKNOWN",payload:R,meta:{requestStatus:"fulfilled",requestId:"UNKNOWN",arg:p}}));_(m,f)})}});function o(A,m){const c=A.keys[m]??[];for(const f of c){const p=f.type,R=f.id??"__internal_without_id",N=A.tags[p]?.[R];N&&(A.tags[p][R]=N.filter(M=>M!==m))}delete A.keys[m]}function _(A,m){const c=m.map(f=>{const p=Ft(f,"providesTags",i,T),{queryCacheKey:R}=f.meta.arg;return{queryCacheKey:R,providedTags:p}});g.caseReducers.updateProvidedBy(A,g.actions.updateProvidedBy(c))}const u=D.createSlice({name:`${e}/subscriptions`,initialState:Oe,reducers:{updateSubscriptionOptions(A,m){},unsubscribeQueryResult(A,m){},internal_getRTKQSubscriptions(){}}}),a=D.createSlice({name:`${e}/internalSubscriptions`,initialState:Oe,reducers:{subscriptionsUpdated:{reducer(A,m){return ut(A,m.payload)},prepare:D.prepareAutoBatched()}}}),w=D.createSlice({name:`${e}/config`,initialState:{online:gn(),focused:mn(),middlewareRegistered:!1,...P},reducers:{middlewareRegistered(A,{payload:m}){A.middlewareRegistered=A.middlewareRegistered==="conflict"||y!==m?"conflict":!0}},extraReducers:A=>{A.addCase(Me,m=>{m.online=!0}).addCase(nt,m=>{m.online=!1}).addCase(ke,m=>{m.focused=!0}).addCase(tt,m=>{m.focused=!1}).addMatcher(v,m=>({...m}))}}),O=D.combineReducers({queries:l.reducer,mutations:h.reducer,provided:g.reducer,subscriptions:a.reducer,config:w.reducer}),E=(A,m)=>O(I.match(m)?void 0:A,m),C={...w.actions,...l.actions,...u.actions,...a.actions,...h.actions,...g.actions,resetApiState:I};return{reducer:E,actions:C}}var Ie=Symbol.for("RTKQ/skipToken"),jt={status:"uninitialized"},St=D.createNextState(jt,()=>{}),_t=D.createNextState(jt,()=>{});function qn({serializeQueryArgs:e,reducerPath:t,createSelector:n}){const r=u=>St,i=u=>_t;return{buildQuerySelector:s,buildInfiniteQuerySelector:l,buildMutationSelector:h,selectInvalidatedBy:S,selectCachedArgsForQuery:g,selectApiState:d,selectQueries:v,selectMutations:P,selectQueryEntry:T,selectConfig:I};function y(u){return{...u,...pt(u.status)}}function d(u){const a=u[t];if(process.env.NODE_ENV!=="production"&&!a){if(d.triggered)return a;d.triggered=!0,console.error(`Error: No data found at \`state.${t}\`. Did you forget to add the reducer to the store?`)}return a}function v(u){return d(u)?.queries}function T(u,a){return v(u)?.[a]}function P(u){return d(u)?.mutations}function I(u){return d(u)?.config}function b(u,a,w){return O=>{if(O===Ie)return n(r,w);const E=e({queryArgs:O,endpointDefinition:a,endpointName:u});return n(A=>T(A,E)??St,w)}}function s(u,a){return b(u,a,y)}function l(u,a){const{infiniteQueryOptions:w}=a;function O(E){const C={...E,...pt(E.status)},{isLoading:A,isError:m,direction:c}=C,f=c==="forward",p=c==="backward";return{...C,hasNextPage:o(w,C.data,C.originalArgs),hasPreviousPage:_(w,C.data,C.originalArgs),isFetchingNextPage:A&&f,isFetchingPreviousPage:A&&p,isFetchNextPageError:m&&f,isFetchPreviousPageError:m&&p}}return b(u,a,O)}function h(){return u=>{let a;return typeof u=="object"?a=_e(u)??Ie:a=u,n(a===Ie?i:E=>d(E)?.mutations?.[a]??_t,y)}}function S(u,a){const w=u[t],O=new Set;for(const E of a.filter(Ne).map(He)){const C=w.provided.tags[E.type];if(!C)continue;let A=(E.id!==void 0?C[E.id]:ht(Object.values(C)))??[];for(const m of A)O.add(m)}return ht(Array.from(O.values()).map(E=>{const C=w.queries[E];return C?[{queryCacheKey:E,endpointName:C.endpointName,originalArgs:C.originalArgs}]:[]}))}function g(u,a){return Object.values(v(u)).filter(w=>w?.endpointName===a&&w.status!=="uninitialized").map(w=>w.originalArgs)}function o(u,a,w){return a?Ye(u,a,w)!=null:!1}function _(u,a,w){return!a||!u.getPreviousPageParam?!1:Mt(u,a,w)!=null}}var wt=WeakMap?new WeakMap:void 0,Ge=({endpointName:e,queryArgs:t})=>{let n="";const r=wt?.get(t);if(typeof r=="string")n=r;else{const i=JSON.stringify(t,(y,d)=>(d=typeof d=="bigint"?{$bigint:d.toString()}:d,d=D.isPlainObject(d)?Object.keys(d).sort().reduce((v,T)=>(v[T]=d[T],v),{}):d,d));D.isPlainObject(t)&&wt?.set(t,i),n=i}return`${e}(${n})`};function xt(...e){return function(n){const r=Ce(P=>n.extractRehydrationInfo?.(P,{reducerPath:n.reducerPath??"api"})),i={reducerPath:"api",keepUnusedDataFor:60,refetchOnMountOrArgChange:!1,refetchOnFocus:!1,refetchOnReconnect:!1,invalidationBehavior:"delayed",...n,extractRehydrationInfo:r,serializeQueryArgs(P){let I=Ge;if("serializeQueryArgs"in P.endpointDefinition){const b=P.endpointDefinition.serializeQueryArgs;I=s=>{const l=b(s);return typeof l=="string"?l:Ge({...s,queryArgs:l})}}else n.serializeQueryArgs&&(I=n.serializeQueryArgs);return I(P)},tagTypes:[...n.tagTypes||[]]},y={endpointDefinitions:{},batch(P){P()},apiUid:D.nanoid(),extractRehydrationInfo:r,hasRehydrationInfo:Ce(P=>r(P)!=null)},d={injectEndpoints:T,enhanceEndpoints({addTagTypes:P,endpoints:I}){if(P)for(const b of P)i.tagTypes.includes(b)||i.tagTypes.push(b);if(I)for(const[b,s]of Object.entries(I))typeof s=="function"?s(y.endpointDefinitions[b]):Object.assign(y.endpointDefinitions[b]||{},s);return d}},v=e.map(P=>P.init(d,i,y));function T(P){const I=P.endpoints({query:b=>({...b,type:"query"}),mutation:b=>({...b,type:"mutation"}),infiniteQuery:b=>({...b,type:"infinitequery"})});for(const[b,s]of Object.entries(I)){if(P.overrideExisting!==!0&&b in y.endpointDefinitions){if(P.overrideExisting==="throw")throw new Error(process.env.NODE_ENV==="production"?D.formatProdErrorMessage(39):`called \`injectEndpoints\` to override already-existing endpointName ${b} without specifying \`overrideExisting: true\``);typeof process<"u"&&process.env.NODE_ENV==="development"&&console.error(`called \`injectEndpoints\` to override already-existing endpointName ${b} without specifying \`overrideExisting: true\``);continue}if(typeof process<"u"&&process.env.NODE_ENV==="development"&&Pe(s)){const{infiniteQueryOptions:l}=s,{maxPages:h,getPreviousPageParam:S}=l;if(typeof h=="number"){if(h<1)throw new Error(process.env.NODE_ENV==="production"?D.formatProdErrorMessage(40):`maxPages for endpoint '${b}' must be a number greater than 0`);if(typeof S!="function")throw new Error(process.env.NODE_ENV==="production"?D.formatProdErrorMessage(41):`getPreviousPageParam for endpoint '${b}' must be a function if maxPages is used`)}}y.endpointDefinitions[b]=s;for(const l of v)l.injectEndpoint(b,s)}return d}return d.injectEndpoints({endpoints:n.endpoints})}}function ee(e,...t){return Object.assign(e,...t)}var Qn=({api:e,queryThunk:t,internalState:n})=>{const r=`${e.reducerPath}/subscriptions`;let i=null,y=null;const{updateSubscriptionOptions:d,unsubscribeQueryResult:v}=e.internalActions,T=(l,h)=>{if(d.match(h)){const{queryCacheKey:g,requestId:o,options:_}=h.payload;return l?.[g]?.[o]&&(l[g][o]=_),!0}if(v.match(h)){const{queryCacheKey:g,requestId:o}=h.payload;return l[g]&&delete l[g][o],!0}if(e.internalActions.removeQueryResult.match(h))return delete l[h.payload.queryCacheKey],!0;if(t.pending.match(h)){const{meta:{arg:g,requestId:o}}=h,_=l[g.queryCacheKey]??={};return _[`${o}_running`]={},g.subscribe&&(_[o]=g.subscriptionOptions??_[o]??{}),!0}let S=!1;if(t.fulfilled.match(h)||t.rejected.match(h)){const g=l[h.meta.arg.queryCacheKey]||{},o=`${h.meta.requestId}_running`;S||=!!g[o],delete g[o]}if(t.rejected.match(h)){const{meta:{condition:g,arg:o,requestId:_}}=h;if(g&&o.subscribe){const u=l[o.queryCacheKey]??={};u[_]=o.subscriptionOptions??u[_]??{},S=!0}}return S},P=()=>n.currentSubscriptions,s={getSubscriptions:P,getSubscriptionCount:l=>{const S=P()[l]??{};return pe(S)},isRequestSubscribed:(l,h)=>!!P()?.[l]?.[h]};return(l,h)=>{if(i||(i=JSON.parse(JSON.stringify(n.currentSubscriptions))),e.util.resetApiState.match(l))return i=n.currentSubscriptions={},y=null,[!0,!1];if(e.internalActions.internal_getRTKQSubscriptions.match(l))return[!1,s];const S=T(n.currentSubscriptions,l);let g=!0;if(S){y||(y=setTimeout(()=>{const u=JSON.parse(JSON.stringify(n.currentSubscriptions)),[,a]=Ct(i,()=>u);h.next(e.internalActions.subscriptionsUpdated(a)),i=u,y=null},500));const o=typeof l.type=="string"&&!!l.type.startsWith(r),_=t.rejected.match(l)&&l.meta.condition&&!!l.meta.arg.subscribe;g=!o&&!_}return[g,!1]}};function kn(e){for(const t in e)return!1;return!0}var Mn=2147483647/1e3-1,Fn=({reducerPath:e,api:t,queryThunk:n,context:r,internalState:i,selectors:{selectQueryEntry:y,selectConfig:d}})=>{const{removeQueryResult:v,unsubscribeQueryResult:T,cacheEntriesUpserted:P}=t.internalActions,I=D.isAnyOf(T.match,n.fulfilled,n.rejected,P.match);function b(g){const o=i.currentSubscriptions[g];return!!o&&!kn(o)}const s={},l=(g,o,_)=>{const u=o.getState(),a=d(u);if(I(g)){let w;if(P.match(g))w=g.payload.map(O=>O.queryDescription.queryCacheKey);else{const{queryCacheKey:O}=T.match(g)?g.payload:g.meta.arg;w=[O]}h(w,o,a)}if(t.util.resetApiState.match(g))for(const[w,O]of Object.entries(s))O&&clearTimeout(O),delete s[w];if(r.hasRehydrationInfo(g)){const{queries:w}=r.extractRehydrationInfo(g);h(Object.keys(w),o,a)}};function h(g,o,_){const u=o.getState();for(const a of g){const w=y(u,a);S(a,w?.endpointName,o,_)}}function S(g,o,_,u){const w=r.endpointDefinitions[o]?.keepUnusedDataFor??u.keepUnusedDataFor;if(w===1/0)return;const O=Math.max(0,Math.min(w,Mn));if(!b(g)){const E=s[g];E&&clearTimeout(E),s[g]=setTimeout(()=>{b(g)||_.dispatch(v({queryCacheKey:g})),delete s[g]},O*1e3)}}return l},Rt=new Error("Promise never resolved before cacheEntryRemoved."),jn=({api:e,reducerPath:t,context:n,queryThunk:r,mutationThunk:i,internalState:y,selectors:{selectQueryEntry:d,selectApiState:v}})=>{const T=D.isAsyncThunkAction(r),P=D.isAsyncThunkAction(i),I=D.isFulfilled(r,i),b={};function s(o,_,u){const a=b[o];a?.valueResolved&&(a.valueResolved({data:_,meta:u}),delete a.valueResolved)}function l(o){const _=b[o];_&&(delete b[o],_.cacheEntryRemoved())}const h=(o,_,u)=>{const a=S(o);function w(O,E,C,A){const m=d(u,E),c=d(_.getState(),E);!m&&c&&g(O,A,E,_,C)}if(r.pending.match(o))w(o.meta.arg.endpointName,a,o.meta.requestId,o.meta.arg.originalArgs);else if(e.internalActions.cacheEntriesUpserted.match(o))for(const{queryDescription:O,value:E}of o.payload){const{endpointName:C,originalArgs:A,queryCacheKey:m}=O;w(C,m,o.meta.requestId,A),s(m,E,{})}else if(i.pending.match(o))_.getState()[t].mutations[a]&&g(o.meta.arg.endpointName,o.meta.arg.originalArgs,a,_,o.meta.requestId);else if(I(o))s(a,o.payload,o.meta.baseQueryMeta);else if(e.internalActions.removeQueryResult.match(o)||e.internalActions.removeMutationResult.match(o))l(a);else if(e.util.resetApiState.match(o))for(const O of Object.keys(b))l(O)};function S(o){return T(o)?o.meta.arg.queryCacheKey:P(o)?o.meta.arg.fixedCacheKey??o.meta.requestId:e.internalActions.removeQueryResult.match(o)?o.payload.queryCacheKey:e.internalActions.removeMutationResult.match(o)?_e(o.payload):""}function g(o,_,u,a,w){const O=n.endpointDefinitions[o],E=O?.onCacheEntryAdded;if(!E)return;const C={},A=new Promise(N=>{C.cacheEntryRemoved=N}),m=Promise.race([new Promise(N=>{C.valueResolved=N}),A.then(()=>{throw Rt})]);m.catch(()=>{}),b[u]=C;const c=e.endpoints[o].select(qe(O)?_:u),f=a.dispatch((N,M,F)=>F),p={...a,getCacheEntry:()=>c(a.getState()),requestId:w,extra:f,updateCachedData:qe(O)?N=>a.dispatch(e.util.updateQueryData(o,_,N)):void 0,cacheDataLoaded:m,cacheEntryRemoved:A},R=E(_,p);Promise.resolve(R).catch(N=>{if(N!==Rt)throw N})}return h},xn=({api:e,context:{apiUid:t},reducerPath:n})=>(r,i)=>{e.util.resetApiState.match(r)&&i.dispatch(e.internalActions.middlewareRegistered(t)),typeof process<"u"&&process.env.NODE_ENV==="development"&&e.internalActions.middlewareRegistered.match(r)&&r.payload===t&&i.getState()[n]?.config?.middlewareRegistered==="conflict"&&console.warn(`There is a mismatch between slice and middleware for the reducerPath "${n}".
You can only have one api per reducer path, this will lead to crashes in various situations!${n==="api"?`
If you have multiple apis, you *have* to specify the reducerPath option when using createApi!`:""}`)},zn=({reducerPath:e,context:t,context:{endpointDefinitions:n},mutationThunk:r,queryThunk:i,api:y,assertTagType:d,refetchQuery:v,internalState:T})=>{const{removeQueryResult:P}=y.internalActions,I=D.isAnyOf(D.isFulfilled(r),D.isRejectedWithValue(r)),b=D.isAnyOf(D.isFulfilled(r,i),D.isRejected(r,i));let s=[];const l=(g,o)=>{I(g)?S(Ft(g,"invalidatesTags",n,d),o):b(g)?S([],o):y.util.invalidateTags.match(g)&&S(rt(g.payload,void 0,void 0,void 0,void 0,d),o)};function h(g){const{queries:o,mutations:_}=g;for(const u of[o,_])for(const a in u)if(u[a]?.status==="pending")return!0;return!1}function S(g,o){const _=o.getState(),u=_[e];if(s.push(...g),u.config.invalidationBehavior==="delayed"&&h(u))return;const a=s;if(s=[],a.length===0)return;const w=y.util.selectInvalidatedBy(_,a);t.batch(()=>{const O=Array.from(w.values());for(const{queryCacheKey:E}of O){const C=u.queries[E],A=T.currentSubscriptions[E]??{};C&&(pe(A)===0?o.dispatch(P({queryCacheKey:E})):C.status!=="uninitialized"&&o.dispatch(v(C)))}})}return l},$n=({reducerPath:e,queryThunk:t,api:n,refetchQuery:r,internalState:i})=>{const y={},d=(s,l)=>{(n.internalActions.updateSubscriptionOptions.match(s)||n.internalActions.unsubscribeQueryResult.match(s))&&T(s.payload,l),(t.pending.match(s)||t.rejected.match(s)&&s.meta.condition)&&T(s.meta.arg,l),(t.fulfilled.match(s)||t.rejected.match(s)&&!s.meta.condition)&&v(s.meta.arg,l),n.util.resetApiState.match(s)&&I()};function v({queryCacheKey:s},l){const h=l.getState()[e],S=h.queries[s],g=i.currentSubscriptions[s];if(!S||S.status==="uninitialized")return;const{lowestPollingInterval:o,skipPollingIfUnfocused:_}=b(g);if(!Number.isFinite(o))return;const u=y[s];u?.timeout&&(clearTimeout(u.timeout),u.timeout=void 0);const a=Date.now()+o;y[s]={nextPollTimestamp:a,pollingInterval:o,timeout:setTimeout(()=>{(h.config.focused||!_)&&l.dispatch(r(S)),v({queryCacheKey:s},l)},o)}}function T({queryCacheKey:s},l){const S=l.getState()[e].queries[s],g=i.currentSubscriptions[s];if(!S||S.status==="uninitialized")return;const{lowestPollingInterval:o}=b(g);if(!Number.isFinite(o)){P(s);return}const _=y[s],u=Date.now()+o;(!_||u<_.nextPollTimestamp)&&v({queryCacheKey:s},l)}function P(s){const l=y[s];l?.timeout&&clearTimeout(l.timeout),delete y[s]}function I(){for(const s of Object.keys(y))P(s)}function b(s={}){let l=!1,h=Number.POSITIVE_INFINITY;for(let S in s)s[S].pollingInterval&&(h=Math.min(s[S].pollingInterval,h),l=s[S].skipPollingIfUnfocused||l);return{lowestPollingInterval:h,skipPollingIfUnfocused:l}}return d},Kn=({api:e,context:t,queryThunk:n,mutationThunk:r})=>{const i=D.isPending(n,r),y=D.isRejected(n,r),d=D.isFulfilled(n,r),v={};return(P,I)=>{if(i(P)){const{requestId:b,arg:{endpointName:s,originalArgs:l}}=P.meta,h=t.endpointDefinitions[s],S=h?.onQueryStarted;if(S){const g={},o=new Promise((w,O)=>{g.resolve=w,g.reject=O});o.catch(()=>{}),v[b]=g;const _=e.endpoints[s].select(qe(h)?l:b),u=I.dispatch((w,O,E)=>E),a={...I,getCacheEntry:()=>_(I.getState()),requestId:b,extra:u,updateCachedData:qe(h)?w=>I.dispatch(e.util.updateQueryData(s,l,w)):void 0,queryFulfilled:o};S(l,a)}}else if(d(P)){const{requestId:b,baseQueryMeta:s}=P.meta;v[b]?.resolve({data:P.payload,meta:s}),delete v[b]}else if(y(P)){const{requestId:b,rejectedWithValue:s,baseQueryMeta:l}=P.meta;v[b]?.reject({error:P.payload??P.error,isUnhandledError:!s,meta:l}),delete v[b]}}},Un=({reducerPath:e,context:t,api:n,refetchQuery:r,internalState:i})=>{const{removeQueryResult:y}=n.internalActions,d=(T,P)=>{ke.match(T)&&v(P,"refetchOnFocus"),Me.match(T)&&v(P,"refetchOnReconnect")};function v(T,P){const I=T.getState()[e],b=I.queries,s=i.currentSubscriptions;t.batch(()=>{for(const l of Object.keys(s)){const h=b[l],S=s[l];if(!S||!h)continue;(Object.values(S).some(o=>o[P]===!0)||Object.values(S).every(o=>o[P]===void 0)&&I.config[P])&&(pe(S)===0?T.dispatch(y({queryCacheKey:l})):h.status!=="uninitialized"&&T.dispatch(r(h)))}})}return d};function Vn(e){const{reducerPath:t,queryThunk:n,api:r,context:i}=e,{apiUid:y}=i,d={invalidateTags:D.createAction(`${t}/invalidateTags`)},v=b=>b.type.startsWith(`${t}/`),T=[xn,Fn,zn,$n,jn,Kn];return{middleware:b=>{let s=!1;const h={...e,internalState:{currentSubscriptions:{}},refetchQuery:I,isThisApiSliceAction:v},S=T.map(_=>_(h)),g=Qn(h),o=Un(h);return _=>u=>{if(!D.isAction(u))return _(u);s||(s=!0,b.dispatch(r.internalActions.middlewareRegistered(y)));const a={...b,next:_},w=b.getState(),[O,E]=g(u,a,w);let C;if(O?C=_(u):C=E,b.getState()[t]&&(o(u,a,w),v(u)||i.hasRehydrationInfo(u)))for(const A of S)A(u,a,w);return C}},actions:d};function I(b){return e.api.endpoints[b.endpointName].initiate(b.originalArgs,{subscribe:!1,forceRefetch:!0})}}var Pt=Symbol(),zt=({createSelector:e=D.createSelector}={})=>({name:Pt,init(t,{baseQuery:n,tagTypes:r,reducerPath:i,serializeQueryArgs:y,keepUnusedDataFor:d,refetchOnMountOrArgChange:v,refetchOnFocus:T,refetchOnReconnect:P,invalidationBehavior:I,onSchemaFailure:b,catchSchemaFailure:s,skipSchemaValidation:l},h){Zt();const S=k=>(typeof process<"u"&&process.env.NODE_ENV==="development"&&(r.includes(k.type)||console.error(`Tag type '${k.type}' was used, but not specified in \`tagTypes\`!`)),k);Object.assign(t,{reducerPath:i,endpoints:{},internalActions:{onOnline:Me,onOffline:nt,onFocus:ke,onFocusLost:tt},util:{}});const g=qn({serializeQueryArgs:y,reducerPath:i,createSelector:e}),{selectInvalidatedBy:o,selectCachedArgsForQuery:_,buildQuerySelector:u,buildInfiniteQuerySelector:a,buildMutationSelector:w}=g;ee(t.util,{selectInvalidatedBy:o,selectCachedArgsForQuery:_});const{queryThunk:O,infiniteQueryThunk:E,mutationThunk:C,patchQueryData:A,updateQueryData:m,upsertQueryData:c,prefetch:f,buildMatchThunkActions:p}=Cn({baseQuery:n,reducerPath:i,context:h,api:t,serializeQueryArgs:y,assertTagType:S,selectors:g,onSchemaFailure:b,catchSchemaFailure:s,skipSchemaValidation:l}),{reducer:R,actions:N}=Nn({context:h,queryThunk:O,mutationThunk:C,serializeQueryArgs:y,reducerPath:i,assertTagType:S,config:{refetchOnFocus:T,refetchOnReconnect:P,refetchOnMountOrArgChange:v,keepUnusedDataFor:d,reducerPath:i,invalidationBehavior:I}});ee(t.util,{patchQueryData:A,updateQueryData:m,upsertQueryData:c,prefetch:f,resetApiState:N.resetApiState,upsertQueryEntries:N.cacheEntriesUpserted}),ee(t.internalActions,N);const{middleware:M,actions:F}=Vn({reducerPath:i,context:h,queryThunk:O,mutationThunk:C,infiniteQueryThunk:E,api:t,assertTagType:S,selectors:g});ee(t.util,F),ee(t,{reducer:R,middleware:M});const{buildInitiateQuery:Q,buildInitiateInfiniteQuery:q,buildInitiateMutation:$,getRunningMutationThunk:U,getRunningMutationsThunk:H,getRunningQueriesThunk:K,getRunningQueryThunk:x}=Dn({queryThunk:O,mutationThunk:C,infiniteQueryThunk:E,api:t,serializeQueryArgs:y,context:h});return ee(t.util,{getRunningMutationThunk:U,getRunningMutationsThunk:H,getRunningQueryThunk:x,getRunningQueriesThunk:K}),{name:Pt,injectEndpoint(k,W){const V=t,z=V.endpoints[k]??={};Fe(W)&&ee(z,{name:k,select:u(k,W),initiate:Q(k,W)},p(O,k)),An(W)&&ee(z,{name:k,select:w(),initiate:$(k)},p(C,k)),Pe(W)&&ee(z,{name:k,select:a(k,W),initiate:q(k,W)},p(O,k))}}}});zt();exports.QueryStatus=qt;exports.buildCreateApi=xt;exports.coreModule=zt;exports.createSelector=Nt;exports.defaultSerializeQueryArgs=Ge;exports.fetchBaseQuery=Pn;exports.setupListeners=En;exports.skipToken=Ie;
//# sourceMappingURL=rtk-query.modern-C0Q3pEC1.cjs.map
