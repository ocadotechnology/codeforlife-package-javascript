"use strict";const N=require("@reduxjs/toolkit");var tt=Symbol.for("immer-nothing"),he=Symbol.for("immer-draftable"),J=Symbol.for("immer-state"),Nt=process.env.NODE_ENV!=="production"?[function(e){return`The plugin for '${e}' has not been loaded into Immer. To enable the plugin, import and call \`enable${e}()\` when initializing your application.`},function(e){return`produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${e}'`},"This object has been frozen and should not be mutated",function(e){return"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? "+e},"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.","Immer forbids circular references","The first or second argument to `produce` must be a function","The third argument to `produce` must be a function or undefined","First argument to `createDraft` must be a plain object, an array, or an immerable object","First argument to `finishDraft` must be a draft returned by `createDraft`",function(e){return`'current' expects a draft, got: ${e}`},"Object.defineProperty() cannot be used on an Immer draft","Object.setPrototypeOf() cannot be used on an Immer draft","Immer only supports deleting array indices","Immer only supports setting array indices and the 'length' property",function(e){return`'original' expects a draft, got: ${e}`}]:[];function B(e,...t){if(process.env.NODE_ENV!=="production"){const n=Nt[e],r=typeof n=="function"?n.apply(null,t):n;throw new Error(`[Immer] ${r}`)}throw new Error(`[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`)}var ae=Object.getPrototypeOf;function ee(e){return!!e&&!!e[J]}function te(e){return e?Ct(e)||Array.isArray(e)||!!e[he]||!!e.constructor?.[he]||pe(e)||Pe(e):!1}var Lt=Object.prototype.constructor.toString();function Ct(e){if(!e||typeof e!="object")return!1;const t=ae(e);if(t===null)return!0;const n=Object.hasOwnProperty.call(t,"constructor")&&t.constructor;return n===Object?!0:typeof n=="function"&&Function.toString.call(n)===Lt}function Ht(e){return ee(e)||B(15,e),e[J].base_}function me(e,t){ce(e)===0?Reflect.ownKeys(e).forEach(n=>{t(n,e[n],e)}):e.forEach((n,r)=>t(r,n,e))}function ce(e){const t=e[J];return t?t.type_:Array.isArray(e)?1:pe(e)?2:Pe(e)?3:0}function ge(e,t){return ce(e)===2?e.has(t):Object.prototype.hasOwnProperty.call(e,t)}function xe(e,t){return ce(e)===2?e.get(t):e[t]}function Qt(e,t,n){const r=ce(e);r===2?e.set(t,n):r===3?e.add(n):e[t]=n}function Jt(e,t){return e===t?e!==0||1/e===1/t:e!==e&&t!==t}function pe(e){return e instanceof Map}function Pe(e){return e instanceof Set}function oe(e){return e.copy_||e.base_}function Ve(e,t){if(pe(e))return new Map(e);if(Pe(e))return new Set(e);if(Array.isArray(e))return Array.prototype.slice.call(e);const n=Ct(e);if(t===!0||t==="class_only"&&!n){const r=Object.getOwnPropertyDescriptors(e);delete r[J];let s=Reflect.ownKeys(r);for(let d=0;d<s.length;d++){const p=s[d],g=r[p];g.writable===!1&&(g.writable=!0,g.configurable=!0),(g.get||g.set)&&(r[p]={configurable:!0,writable:!0,enumerable:g.enumerable,value:e[p]})}return Object.create(ae(e),r)}else{const r=ae(e);if(r!==null&&n)return{...e};const s=Object.create(r);return Object.assign(s,e)}}function nt(e,t=!1){return qe(e)||ee(e)||!te(e)||(ce(e)>1&&Object.defineProperties(e,{set:{value:Ee},add:{value:Ee},clear:{value:Ee},delete:{value:Ee}}),Object.freeze(e),t&&Object.values(e).forEach(n=>nt(n,!0))),e}function Ee(){B(2)}function qe(e){return Object.isFrozen(e)}var We={};function ue(e){const t=We[e];return t||B(0,e),t}function Yt(e,t){We[e]||(We[e]=t)}var ve;function Mt(){return ve}function Gt(e,t){return{drafts_:[],parent_:e,immer_:t,canAutoFreeze_:!0,unfinalizedDrafts_:0}}function ut(e,t){t&&(ue("Patches"),e.patches_=[],e.inversePatches_=[],e.patchListener_=t)}function Be(e){Le(e),e.drafts_.forEach(Xt),e.drafts_=null}function Le(e){e===ve&&(ve=e.parent_)}function lt(e){return ve=Gt(ve,e)}function Xt(e){const t=e[J];t.type_===0||t.type_===1?t.revoke_():t.revoked_=!0}function ft(e,t){t.unfinalizedDrafts_=t.drafts_.length;const n=t.drafts_[0];return e!==void 0&&e!==n?(n[J].modified_&&(Be(t),B(4)),te(e)&&(e=De(t,e),t.parent_||Ne(t,e)),t.patches_&&ue("Patches").generateReplacementPatches_(n[J].base_,e,t.patches_,t.inversePatches_)):e=De(t,n,[]),Be(t),t.patches_&&t.patchListener_(t.patches_,t.inversePatches_),e!==tt?e:void 0}function De(e,t,n){if(qe(t))return t;const r=t[J];if(!r)return me(t,(s,d)=>dt(e,r,t,s,d,n)),t;if(r.scope_!==e)return t;if(!r.modified_)return Ne(e,r.base_,!0),r.base_;if(!r.finalized_){r.finalized_=!0,r.scope_.unfinalizedDrafts_--;const s=r.copy_;let d=s,p=!1;r.type_===3&&(d=new Set(s),s.clear(),p=!0),me(d,(g,D)=>dt(e,r,s,g,D,n,p)),Ne(e,s,!1),n&&e.patches_&&ue("Patches").generatePatches_(r,n,e.patches_,e.inversePatches_)}return r.copy_}function dt(e,t,n,r,s,d,p){if(process.env.NODE_ENV!=="production"&&s===n&&B(5),ee(s)){const g=d&&t&&t.type_!==3&&!ge(t.assigned_,r)?d.concat(r):void 0,D=De(e,s,g);if(Qt(n,r,D),ee(D))e.canAutoFreeze_=!1;else return}else p&&n.add(s);if(te(s)&&!qe(s)){if(!e.immer_.autoFreeze_&&e.unfinalizedDrafts_<1)return;De(e,s),(!t||!t.scope_.parent_)&&typeof r!="symbol"&&(pe(n)?n.has(r):Object.prototype.propertyIsEnumerable.call(n,r))&&Ne(e,s)}}function Ne(e,t,n=!1){!e.parent_&&e.immer_.autoFreeze_&&e.canAutoFreeze_&&nt(t,n)}function Zt(e,t){const n=Array.isArray(e),r={type_:n?1:0,scope_:t?t.scope_:Mt(),modified_:!1,finalized_:!1,assigned_:{},parent_:t,base_:e,draft_:null,copy_:null,revoke_:null,isManual_:!1};let s=r,d=rt;n&&(s=[r],d=be);const{revoke:p,proxy:g}=Proxy.revocable(s,d);return r.draft_=g,r.revoke_=p,g}var rt={get(e,t){if(t===J)return e;const n=oe(e);if(!ge(n,t))return en(e,n,t);const r=n[t];return e.finalized_||!te(r)?r:r===ze(e.base_,t)?($e(e),e.copy_[t]=Je(r,e)):r},has(e,t){return t in oe(e)},ownKeys(e){return Reflect.ownKeys(oe(e))},set(e,t,n){const r=qt(oe(e),t);if(r?.set)return r.set.call(e.draft_,n),!0;if(!e.modified_){const s=ze(oe(e),t),d=s?.[J];if(d&&d.base_===n)return e.copy_[t]=n,e.assigned_[t]=!1,!0;if(Jt(n,s)&&(n!==void 0||ge(e.base_,t)))return!0;$e(e),He(e)}return e.copy_[t]===n&&(n!==void 0||t in e.copy_)||Number.isNaN(n)&&Number.isNaN(e.copy_[t])||(e.copy_[t]=n,e.assigned_[t]=!0),!0},deleteProperty(e,t){return ze(e.base_,t)!==void 0||t in e.base_?(e.assigned_[t]=!1,$e(e),He(e)):delete e.assigned_[t],e.copy_&&delete e.copy_[t],!0},getOwnPropertyDescriptor(e,t){const n=oe(e),r=Reflect.getOwnPropertyDescriptor(n,t);return r&&{writable:!0,configurable:e.type_!==1||t!=="length",enumerable:r.enumerable,value:n[t]}},defineProperty(){B(11)},getPrototypeOf(e){return ae(e.base_)},setPrototypeOf(){B(12)}},be={};me(rt,(e,t)=>{be[e]=function(){return arguments[0]=arguments[0][0],t.apply(this,arguments)}});be.deleteProperty=function(e,t){return process.env.NODE_ENV!=="production"&&isNaN(parseInt(t))&&B(13),be.set.call(this,e,t,void 0)};be.set=function(e,t,n){return process.env.NODE_ENV!=="production"&&t!=="length"&&isNaN(parseInt(t))&&B(14),rt.set.call(this,e[0],t,n,e[0])};function ze(e,t){const n=e[J];return(n?oe(n):e)[t]}function en(e,t,n){const r=qt(t,n);return r?"value"in r?r.value:r.get?.call(e.draft_):void 0}function qt(e,t){if(!(t in e))return;let n=ae(e);for(;n;){const r=Object.getOwnPropertyDescriptor(n,t);if(r)return r;n=ae(n)}}function He(e){e.modified_||(e.modified_=!0,e.parent_&&He(e.parent_))}function $e(e){e.copy_||(e.copy_=Ve(e.base_,e.scope_.immer_.useStrictShallowCopy_))}var tn=class{constructor(e){this.autoFreeze_=!0,this.useStrictShallowCopy_=!1,this.produce=(t,n,r)=>{if(typeof t=="function"&&typeof n!="function"){const d=n;n=t;const p=this;return function(D=d,...I){return p.produce(D,T=>n.call(this,T,...I))}}typeof n!="function"&&B(6),r!==void 0&&typeof r!="function"&&B(7);let s;if(te(t)){const d=lt(this),p=Je(t,void 0);let g=!0;try{s=n(p),g=!1}finally{g?Be(d):Le(d)}return ut(d,r),ft(s,d)}else if(!t||typeof t!="object"){if(s=n(t),s===void 0&&(s=t),s===tt&&(s=void 0),this.autoFreeze_&&nt(s,!0),r){const d=[],p=[];ue("Patches").generateReplacementPatches_(t,s,d,p),r(d,p)}return s}else B(1,t)},this.produceWithPatches=(t,n)=>{if(typeof t=="function")return(p,...g)=>this.produceWithPatches(p,D=>t(D,...g));let r,s;return[this.produce(t,n,(p,g)=>{r=p,s=g}),r,s]},typeof e?.autoFreeze=="boolean"&&this.setAutoFreeze(e.autoFreeze),typeof e?.useStrictShallowCopy=="boolean"&&this.setUseStrictShallowCopy(e.useStrictShallowCopy)}createDraft(e){te(e)||B(8),ee(e)&&(e=nn(e));const t=lt(this),n=Je(e,void 0);return n[J].isManual_=!0,Le(t),n}finishDraft(e,t){const n=e&&e[J];(!n||!n.isManual_)&&B(9);const{scope_:r}=n;return ut(r,t),ft(void 0,r)}setAutoFreeze(e){this.autoFreeze_=e}setUseStrictShallowCopy(e){this.useStrictShallowCopy_=e}applyPatches(e,t){let n;for(n=t.length-1;n>=0;n--){const s=t[n];if(s.path.length===0&&s.op==="replace"){e=s.value;break}}n>-1&&(t=t.slice(n+1));const r=ue("Patches").applyPatches_;return ee(e)?r(e,t):this.produce(e,s=>r(s,t))}};function Je(e,t){const n=pe(e)?ue("MapSet").proxyMap_(e,t):Pe(e)?ue("MapSet").proxySet_(e,t):Zt(e,t);return(t?t.scope_:Mt()).drafts_.push(n),n}function nn(e){return ee(e)||B(10,e),kt(e)}function kt(e){if(!te(e)||qe(e))return e;const t=e[J];let n;if(t){if(!t.modified_)return t.base_;t.finalized_=!0,n=Ve(e,t.scope_.immer_.useStrictShallowCopy_)}else n=Ve(e,!0);return me(n,(r,s)=>{Qt(n,r,kt(s))}),t&&(t.finalized_=!1),n}function rn(){process.env.NODE_ENV!=="production"&&Nt.push('Sets cannot have "replace" patches.',function(f){return"Unsupported patch operation: "+f},function(f){return"Cannot apply patch, path doesn't resolve: "+f},"Patching reserved attributes like __proto__, prototype and constructor is not allowed");const t="replace",n="add",r="remove";function s(f,w,A,b){switch(f.type_){case 0:case 2:return p(f,w,A,b);case 1:return d(f,w,A,b);case 3:return g(f,w,A,b)}}function d(f,w,A,b){let{base_:u,assigned_:c}=f,v=f.copy_;v.length<u.length&&([u,v]=[v,u],[A,b]=[b,A]);for(let i=0;i<u.length;i++)if(c[i]&&v[i]!==u[i]){const a=w.concat([i]);A.push({op:t,path:a,value:P(v[i])}),b.push({op:t,path:a,value:P(u[i])})}for(let i=u.length;i<v.length;i++){const a=w.concat([i]);A.push({op:n,path:a,value:P(v[i])})}for(let i=v.length-1;u.length<=i;--i){const a=w.concat([i]);b.push({op:r,path:a})}}function p(f,w,A,b){const{base_:u,copy_:c}=f;me(f.assigned_,(v,i)=>{const a=xe(u,v),m=xe(c,v),R=i?ge(u,v)?t:n:r;if(a===m&&R===t)return;const E=w.concat(v);A.push(R===r?{op:R,path:E}:{op:R,path:E,value:m}),b.push(R===n?{op:r,path:E}:R===r?{op:n,path:E,value:P(a)}:{op:t,path:E,value:P(a)})})}function g(f,w,A,b){let{base_:u,copy_:c}=f,v=0;u.forEach(i=>{if(!c.has(i)){const a=w.concat([v]);A.push({op:r,path:a,value:i}),b.unshift({op:n,path:a,value:i})}v++}),v=0,c.forEach(i=>{if(!u.has(i)){const a=w.concat([v]);A.push({op:n,path:a,value:i}),b.unshift({op:r,path:a,value:i})}v++})}function D(f,w,A,b){A.push({op:t,path:[],value:w===tt?void 0:w}),b.push({op:t,path:[],value:f})}function I(f,w){return w.forEach(A=>{const{path:b,op:u}=A;let c=f;for(let m=0;m<b.length-1;m++){const R=ce(c);let E=b[m];typeof E!="string"&&typeof E!="number"&&(E=""+E),(R===0||R===1)&&(E==="__proto__"||E==="constructor")&&B(19),typeof c=="function"&&E==="prototype"&&B(19),c=xe(c,E),typeof c!="object"&&B(18,b.join("/"))}const v=ce(c),i=T(A.value),a=b[b.length-1];switch(u){case t:switch(v){case 2:return c.set(a,i);case 3:B(16);default:return c[a]=i}case n:switch(v){case 1:return a==="-"?c.push(i):c.splice(a,0,i);case 2:return c.set(a,i);case 3:return c.add(i);default:return c[a]=i}case r:switch(v){case 1:return c.splice(a,1);case 2:return c.delete(a);case 3:return c.delete(A.value);default:return delete c[a]}default:B(17,u)}}),f}function T(f){if(!te(f))return f;if(Array.isArray(f))return f.map(T);if(pe(f))return new Map(Array.from(f.entries()).map(([A,b])=>[A,T(b)]));if(Pe(f))return new Set(Array.from(f).map(T));const w=Object.create(ae(f));for(const A in f)w[A]=T(f[A]);return ge(f,he)&&(w[he]=f[he]),w}function P(f){return ee(f)?T(f):f}Yt("Patches",{applyPatches_:I,generatePatches_:s,generateReplacementPatches_:D})}var Se=new tn;Se.produce;var Ft=Se.produceWithPatches.bind(Se),pt=Se.applyPatches.bind(Se),sn=class extends Error{issues;constructor(e){super(e[0].message),this.name="SchemaError",this.issues=e}},on=(e,t,n)=>{if(t.length===1&&t[0]===n){let r=!1;try{const s={};e(s)===s&&(r=!0)}catch{}if(r){let s;try{throw new Error}catch(d){({stack:s}=d)}console.warn(`The result function returned its own inputs without modification. e.g
\`createSelector([state => state.todos], todos => todos)\`
This could lead to inefficient memoization and unnecessary re-renders.
Ensure transformation logic is in the result function, and extraction logic is in the input selectors.`,{stack:s})}}},an=(e,t,n)=>{const{memoize:r,memoizeOptions:s}=t,{inputSelectorResults:d,inputSelectorResultsCopy:p}=e,g=r(()=>({}),...s);if(!(g.apply(null,d)===g.apply(null,p))){let I;try{throw new Error}catch(T){({stack:I}=T)}console.warn(`An input selector returned a different result when passed same arguments.
This means your output selector will likely run more frequently than intended.
Avoid returning a new reference inside your input selector, e.g.
\`createSelector([state => state.todos.map(todo => todo.id)], todoIds => todoIds.length)\``,{arguments:n,firstInputs:d,secondInputs:p,stack:I})}},cn={inputStabilityCheck:"once",identityFunctionCheck:"once"};function un(e,t=`expected a function, instead received ${typeof e}`){if(typeof e!="function")throw new TypeError(t)}function ln(e,t=`expected an object, instead received ${typeof e}`){if(typeof e!="object")throw new TypeError(t)}function fn(e,t="expected all items to be functions, instead received the following types: "){if(!e.every(n=>typeof n=="function")){const n=e.map(r=>typeof r=="function"?`function ${r.name||"unnamed"}()`:typeof r).join(", ");throw new TypeError(`${t}[${n}]`)}}var yt=e=>Array.isArray(e)?e:[e];function dn(e){const t=Array.isArray(e[0])?e[0]:e;return fn(t,"createSelector expects all input-selectors to be functions, but received the following types: "),t}function ht(e,t){const n=[],{length:r}=e;for(let s=0;s<r;s++)n.push(e[s].apply(null,t));return n}var pn=(e,t)=>{const{identityFunctionCheck:n,inputStabilityCheck:r}={...cn,...t};return{identityFunctionCheck:{shouldRun:n==="always"||n==="once"&&e,run:on},inputStabilityCheck:{shouldRun:r==="always"||r==="once"&&e,run:an}}},yn=class{constructor(e){this.value=e}deref(){return this.value}},hn=typeof WeakRef<"u"?WeakRef:yn,mn=0,mt=1;function Ae(){return{s:mn,v:void 0,o:null,p:null}}function Ce(e,t={}){let n=Ae();const{resultEqualityCheck:r}=t;let s,d=0;function p(){let g=n;const{length:D}=arguments;for(let P=0,f=D;P<f;P++){const w=arguments[P];if(typeof w=="function"||typeof w=="object"&&w!==null){let A=g.o;A===null&&(g.o=A=new WeakMap);const b=A.get(w);b===void 0?(g=Ae(),A.set(w,g)):g=b}else{let A=g.p;A===null&&(g.p=A=new Map);const b=A.get(w);b===void 0?(g=Ae(),A.set(w,g)):g=b}}const I=g;let T;if(g.s===mt)T=g.v;else if(T=e.apply(null,arguments),d++,r){const P=s?.deref?.()??s;P!=null&&r(P,T)&&(T=P,d!==0&&d--),s=typeof T=="object"&&T!==null||typeof T=="function"?new hn(T):T}return I.s=mt,I.v=T,T}return p.clearCache=()=>{n=Ae(),p.resetResultsCount()},p.resultsCount=()=>d,p.resetResultsCount=()=>{d=0},p}function gn(e,...t){const n=typeof e=="function"?{memoize:e,memoizeOptions:t}:e,r=(...s)=>{let d=0,p=0,g,D={},I=s.pop();typeof I=="object"&&(D=I,I=s.pop()),un(I,`createSelector expects an output function after the inputs, but received: [${typeof I}]`);const T={...n,...D},{memoize:P,memoizeOptions:f=[],argsMemoize:w=Ce,argsMemoizeOptions:A=[],devModeChecks:b={}}=T,u=yt(f),c=yt(A),v=dn(s),i=P(function(){return d++,I.apply(null,arguments)},...u);let a=!0;const m=w(function(){p++;const E=ht(v,arguments);if(g=i.apply(null,E),process.env.NODE_ENV!=="production"){const{identityFunctionCheck:O,inputStabilityCheck:S}=pn(a,b);if(O.shouldRun&&O.run(I,E,g),S.shouldRun){const y=ht(v,arguments);S.run({inputSelectorResults:E,inputSelectorResultsCopy:y},{memoize:P,memoizeOptions:u},arguments)}a&&(a=!1)}return g},...c);return Object.assign(m,{resultFunc:I,memoizedResultFunc:i,dependencies:v,dependencyRecomputations:()=>p,resetDependencyRecomputations:()=>{p=0},lastResult:()=>g,recomputations:()=>d,resetRecomputations:()=>{d=0},memoize:P,argsMemoize:w})};return Object.assign(r,{withTypes:()=>r}),r}var jt=gn(Ce),vn=Object.assign((e,t=jt)=>{ln(e,`createStructuredSelector expects first argument to be an object where each property is a selector, instead received a ${typeof e}`);const n=Object.keys(e),r=n.map(d=>e[d]);return t(r,(...d)=>d.reduce((p,g,D)=>(p[n[D]]=g,p),{}))},{withTypes:()=>vn}),xt=(e=>(e.uninitialized="uninitialized",e.pending="pending",e.fulfilled="fulfilled",e.rejected="rejected",e))(xt||{});function gt(e){return{status:e,isUninitialized:e==="uninitialized",isLoading:e==="pending",isSuccess:e==="fulfilled",isError:e==="rejected"}}var vt=N.isPlainObject;function it(e,t){if(e===t||!(vt(e)&&vt(t)||Array.isArray(e)&&Array.isArray(t)))return t;const n=Object.keys(t),r=Object.keys(e);let s=n.length===r.length;const d=Array.isArray(t)?[]:{};for(const p of n)d[p]=it(e[p],t[p]),s&&(s=e[p]===d[p]);return s?e:d}function Ue(e){let t=0;for(const n in e)t++;return t}var bt=e=>[].concat(...e);function bn(e){return new RegExp("(^|:)//").test(e)}function Sn(){return typeof document>"u"?!0:document.visibilityState!=="hidden"}function Qe(e){return e!=null}function _n(){return typeof navigator>"u"||navigator.onLine===void 0?!0:navigator.onLine}var wn=e=>e.replace(/\/$/,""),Pn=e=>e.replace(/^\//,"");function Rn(e,t){if(!e)return t;if(!t)return e;if(bn(t))return t;const n=e.endsWith("/")||!t.startsWith("?")?"/":"";return e=wn(e),t=Pn(t),`${e}${n}${t}`}function En(e,t,n){return e.has(t)?e.get(t):e.set(t,n).get(t)}function Ye(e,t,n){return e.has(t)?e.get(t):e.set(t,n(t)).get(t)}var Ge=()=>new Map,St=(...e)=>fetch(...e),An=e=>e.status>=200&&e.status<=299,On=e=>/ion\/(vnd\.api\+)?json/.test(e.get("content-type")||"");function _t(e){if(!N.isPlainObject(e))return e;const t={...e};for(const[n,r]of Object.entries(t))r===void 0&&delete t[n];return t}function In({baseUrl:e,prepareHeaders:t=P=>P,fetchFn:n=St,paramsSerializer:r,isJsonContentType:s=On,jsonContentType:d="application/json",jsonReplacer:p,timeout:g,responseHandler:D,validateStatus:I,...T}={}){return typeof fetch>"u"&&n===St&&console.warn("Warning: `fetch` is not available. Please supply a custom `fetchFn` property to use `fetchBaseQuery` on SSR environments."),async(f,w,A)=>{const{getState:b,extra:u,endpoint:c,forced:v,type:i}=w;let a,{url:m,headers:R=new Headers(T.headers),params:E=void 0,responseHandler:O=D??"json",validateStatus:S=I??An,timeout:y=g,...o}=typeof f=="string"?{url:f}:f,l,h=w.signal;y&&(l=new AbortController,w.signal.addEventListener("abort",l.abort),h=l.signal);let _={...T,signal:h,...o};R=new Headers(_t(R)),_.headers=await t(R,{getState:b,arg:f,extra:u,endpoint:c,forced:v,type:i,extraOptions:A})||R;const C=x=>typeof x=="object"&&(N.isPlainObject(x)||Array.isArray(x)||typeof x.toJSON=="function");if(!_.headers.has("content-type")&&C(_.body)&&_.headers.set("content-type",d),C(_.body)&&s(_.headers)&&(_.body=JSON.stringify(_.body,p)),E){const x=~m.indexOf("?")?"&":"?",$=r?r(E):new URLSearchParams(_t(E));m+=x+$}m=Rn(e,m);const q=new Request(m,_);a={request:new Request(m,_)};let M,Q=!1,j=l&&setTimeout(()=>{Q=!0,l.abort()},y);try{M=await n(q)}catch(x){return{error:{status:Q?"TIMEOUT_ERROR":"FETCH_ERROR",error:String(x)},meta:a}}finally{j&&clearTimeout(j),l?.signal.removeEventListener("abort",l.abort)}const V=M.clone();a.response=V;let L,U="";try{let x;if(await Promise.all([P(M,O).then($=>L=$,$=>x=$),V.text().then($=>U=$,()=>{})]),x)throw x}catch(x){return{error:{status:"PARSING_ERROR",originalStatus:M.status,data:U,error:String(x)},meta:a}}return S(M,L)?{data:L,meta:a}:{error:{status:M.status,data:L},meta:a}};async function P(f,w){if(typeof w=="function")return w(f);if(w==="content-type"&&(w=s(f.headers)?"json":"text"),w==="json"){const A=await f.text();return A.length?JSON.parse(A):null}return f.text()}}var wt=class{constructor(e,t=void 0){this.value=e,this.meta=t}},ke=N.createAction("__rtkq/focused"),st=N.createAction("__rtkq/unfocused"),Fe=N.createAction("__rtkq/online"),ot=N.createAction("__rtkq/offline"),Ke=!1;function Tn(e,t){function n(){const r=()=>e(ke()),s=()=>e(st()),d=()=>e(Fe()),p=()=>e(ot()),g=()=>{window.document.visibilityState==="visible"?r():s()};return Ke||typeof window<"u"&&window.addEventListener&&(window.addEventListener("visibilitychange",g,!1),window.addEventListener("focus",r,!1),window.addEventListener("online",d,!1),window.addEventListener("offline",p,!1),Ke=!0),()=>{window.removeEventListener("focus",r),window.removeEventListener("visibilitychange",g),window.removeEventListener("online",d),window.removeEventListener("offline",p),Ke=!1}}return n()}function je(e){return e.type==="query"}function Dn(e){return e.type==="mutation"}function Re(e){return e.type==="infinitequery"}function Me(e){return je(e)||Re(e)}function at(e,t,n,r,s,d){return Nn(e)?e(t,n,r,s).filter(Qe).map(Xe).map(d):Array.isArray(e)?e.map(Xe).map(d):[]}function Nn(e){return typeof e=="function"}function Xe(e){return typeof e=="string"?{type:e}:e}function Cn(e,t){return e.catch(t)}var _e=Symbol("forceQueryFn"),Ze=e=>typeof e[_e]=="function";function Qn({serializeQueryArgs:e,queryThunk:t,infiniteQueryThunk:n,mutationThunk:r,api:s,context:d,internalState:p}){const{runningQueries:g,runningMutations:D}=p,{unsubscribeQueryResult:I,removeMutationResult:T,updateSubscriptionOptions:P}=s.internalActions;return{buildInitiateQuery:v,buildInitiateInfiniteQuery:i,buildInitiateMutation:a,getRunningQueryThunk:f,getRunningMutationThunk:w,getRunningQueriesThunk:A,getRunningMutationsThunk:b};function f(m,R){return E=>{const O=d.endpointDefinitions[m],S=e({queryArgs:R,endpointDefinition:O,endpointName:m});return g.get(E)?.[S]}}function w(m,R){return E=>D.get(E)?.[R]}function A(){return m=>Object.values(g.get(m)||{}).filter(Qe)}function b(){return m=>Object.values(D.get(m)||{}).filter(Qe)}function u(m){if(process.env.NODE_ENV!=="production"){if(u.triggered)return;const R=m(s.internalActions.internal_getRTKQSubscriptions());if(u.triggered=!0,typeof R!="object"||typeof R?.type=="string")throw new Error(process.env.NODE_ENV==="production"?N.formatProdErrorMessage(34):`Warning: Middleware for RTK-Query API at reducerPath "${s.reducerPath}" has not been added to the store.
You must add the middleware for RTK-Query to function correctly!`)}}function c(m,R){const E=(O,{subscribe:S=!0,forceRefetch:y,subscriptionOptions:o,[_e]:l,...h}={})=>(_,C)=>{const q=e({queryArgs:O,endpointDefinition:R,endpointName:m});let z;const M={...h,type:"query",subscribe:S,forceRefetch:y,subscriptionOptions:o,endpointName:m,originalArgs:O,queryCacheKey:q,[_e]:l};if(je(R))z=t(M);else{const{direction:F,initialPageParam:k}=h;z=n({...M,direction:F,initialPageParam:k})}const Q=s.endpoints[m].select(O),j=_(z),V=Q(C());u(_);const{requestId:L,abort:U}=j,x=V.requestId!==L,$=g.get(_)?.[q],K=()=>Q(C()),W=Object.assign(l?j.then(K):x&&!$?Promise.resolve(V):Promise.all([$,j]).then(K),{arg:O,requestId:L,subscriptionOptions:o,queryCacheKey:q,abort:U,async unwrap(){const F=await W;if(F.isError)throw F.error;return F.data},refetch:()=>_(E(O,{subscribe:!1,forceRefetch:!0})),unsubscribe(){S&&_(I({queryCacheKey:q,requestId:L}))},updateSubscriptionOptions(F){W.subscriptionOptions=F,_(P({endpointName:m,requestId:L,queryCacheKey:q,options:F}))}});if(!$&&!x&&!l){const F=En(g,_,{});F[q]=W,W.then(()=>{delete F[q],Ue(F)||g.delete(_)})}return W};return E}function v(m,R){return c(m,R)}function i(m,R){return c(m,R)}function a(m){return(R,{track:E=!0,fixedCacheKey:O}={})=>(S,y)=>{const o=r({type:"mutation",endpointName:m,originalArgs:R,track:E,fixedCacheKey:O}),l=S(o);u(S);const{requestId:h,abort:_,unwrap:C}=l,q=Cn(l.unwrap().then(j=>({data:j})),j=>({error:j})),z=()=>{S(T({requestId:h,fixedCacheKey:O}))},M=Object.assign(q,{arg:l.arg,requestId:h,abort:_,unwrap:C,reset:z}),Q=D.get(S)||{};return D.set(S,Q),Q[h]=M,M.then(()=>{delete Q[h],Ue(Q)||D.delete(S)}),O&&(Q[O]=M,M.then(()=>{Q[O]===M&&(delete Q[O],Ue(Q)||D.delete(S))})),M}}}var zt=class extends sn{constructor(e,t,n,r){super(e),this.value=t,this.schemaName=n,this._bqMeta=r}},ie=(e,t)=>Array.isArray(e)?e.includes(t):!!e;async function se(e,t,n,r){const s=await e["~standard"].validate(t);if(s.issues)throw new zt(s.issues,t,n,r);return s.value}function Pt(e){return e}var ye=(e={})=>({...e,[N.SHOULD_AUTOBATCH]:!0});function Mn({reducerPath:e,baseQuery:t,context:{endpointDefinitions:n},serializeQueryArgs:r,api:s,assertTagType:d,selectors:p,onSchemaFailure:g,catchSchemaFailure:D,skipSchemaValidation:I}){const T=(o,l,h,_)=>(C,q)=>{const z=n[o],M=r({queryArgs:l,endpointDefinition:z,endpointName:o});if(C(s.internalActions.queryResultPatched({queryCacheKey:M,patches:h})),!_)return;const Q=s.endpoints[o].select(l)(q()),j=at(z.providesTags,Q.data,void 0,l,{},d);C(s.internalActions.updateProvidedBy([{queryCacheKey:M,providedTags:j}]))};function P(o,l,h=0){const _=[l,...o];return h&&_.length>h?_.slice(0,-1):_}function f(o,l,h=0){const _=[...o,l];return h&&_.length>h?_.slice(1):_}const w=(o,l,h,_=!0)=>(C,q)=>{const M=s.endpoints[o].select(l)(q()),Q={patches:[],inversePatches:[],undo:()=>C(s.util.patchQueryData(o,l,Q.inversePatches,_))};if(M.status==="uninitialized")return Q;let j;if("data"in M)if(te(M.data)){const[V,L,U]=Ft(M.data,h);Q.patches.push(...L),Q.inversePatches.push(...U),j=V}else j=h(M.data),Q.patches.push({op:"replace",path:[],value:j}),Q.inversePatches.push({op:"replace",path:[],value:M.data});return Q.patches.length===0||C(s.util.patchQueryData(o,l,Q.patches,_)),Q},A=(o,l,h)=>_=>_(s.endpoints[o].initiate(l,{subscribe:!1,forceRefetch:!0,[_e]:()=>({data:h})})),b=(o,l)=>o.query&&o[l]?o[l]:Pt,u=async(o,{signal:l,abort:h,rejectWithValue:_,fulfillWithValue:C,dispatch:q,getState:z,extra:M})=>{const Q=n[o.endpointName],{metaSchema:j,skipSchemaValidation:V=I}=Q;try{let L=Pt;const U={signal:l,abort:h,dispatch:q,getState:z,extra:M,endpoint:o.endpointName,type:o.type,forced:o.type==="query"?c(o,z()):void 0,queryCacheKey:o.type==="query"?o.queryCacheKey:void 0},x=o.type==="query"?o[_e]:void 0;let $;const K=async(F,k,H,le)=>{if(k==null&&F.pages.length)return Promise.resolve({data:F});const ne={queryArg:o.originalArgs,pageParam:k},fe=await W(ne),X=le?P:f;return{data:{pages:X(F.pages,fe.data,H),pageParams:X(F.pageParams,k,H)},meta:fe.meta}};async function W(F){let k;const{extraOptions:H,argSchema:le,rawResponseSchema:ne,responseSchema:fe}=Q;if(le&&!ie(V,"arg")&&(F=await se(le,F,"argSchema",{})),x?k=x():Q.query?(L=b(Q,"transformResponse"),k=await t(Q.query(F),U,H)):k=await Q.queryFn(F,U,H,Y=>t(Y,U,H)),typeof process<"u"&&process.env.NODE_ENV==="development"){const Y=Q.query?"`baseQuery`":"`queryFn`";let G;if(!k)G=`${Y} did not return anything.`;else if(typeof k!="object")G=`${Y} did not return an object.`;else if(k.error&&k.data)G=`${Y} returned an object containing both \`error\` and \`result\`.`;else if(k.error===void 0&&k.data===void 0)G=`${Y} returned an object containing neither a valid \`error\` and \`result\`. At least one of them should not be \`undefined\``;else for(const de of Object.keys(k))if(de!=="error"&&de!=="data"&&de!=="meta"){G=`The object returned by ${Y} has the unknown property ${de}.`;break}G&&console.error(`Error encountered handling the endpoint ${o.endpointName}.
                  ${G}
                  It needs to return an object with either the shape \`{ data: <value> }\` or \`{ error: <value> }\` that may contain an optional \`meta\` property.
                  Object returned was:`,k)}if(k.error)throw new wt(k.error,k.meta);let{data:X}=k;ne&&!ie(V,"rawResponse")&&(X=await se(ne,k.data,"rawResponseSchema",k.meta));let re=await L(X,k.meta,F);return fe&&!ie(V,"response")&&(re=await se(fe,re,"responseSchema",k.meta)),{...k,data:re}}if(o.type==="query"&&"infiniteQueryOptions"in Q){const{infiniteQueryOptions:F}=Q,{maxPages:k=1/0}=F;let H;const le={pages:[],pageParams:[]},ne=p.selectQueryEntry(z(),o.queryCacheKey)?.data,X=c(o,z())&&!o.direction||!ne?le:ne;if("direction"in o&&o.direction&&X.pages.length){const re=o.direction==="backward",G=(re?$t:et)(F,X,o.originalArgs);H=await K(X,G,k,re)}else{const{initialPageParam:re=F.initialPageParam}=o,Y=ne?.pageParams??[],G=Y[0]??re,de=Y.length;H=await K(X,G,k),x&&(H={data:H.data.pages[0]});for(let ct=1;ct<de;ct++){const Bt=et(F,H.data,o.originalArgs);H=await K(H.data,Bt,k)}}$=H}else $=await W(o.originalArgs);return j&&!ie(V,"meta")&&$.meta&&($.meta=await se(j,$.meta,"metaSchema",$.meta)),C($.data,ye({fulfilledTimeStamp:Date.now(),baseQueryMeta:$.meta}))}catch(L){let U=L;if(U instanceof wt){let x=b(Q,"transformErrorResponse");const{rawErrorResponseSchema:$,errorResponseSchema:K}=Q;let{value:W,meta:F}=U;try{$&&!ie(V,"rawErrorResponse")&&(W=await se($,W,"rawErrorResponseSchema",F)),j&&!ie(V,"meta")&&(F=await se(j,F,"metaSchema",F));let k=await x(W,F,o.originalArgs);return K&&!ie(V,"errorResponse")&&(k=await se(K,k,"errorResponseSchema",F)),_(k,ye({baseQueryMeta:F}))}catch(k){U=k}}try{if(U instanceof zt){const x={endpoint:o.endpointName,arg:o.originalArgs,type:o.type,queryCacheKey:o.type==="query"?o.queryCacheKey:void 0};Q.onSchemaFailure?.(U,x),g?.(U,x);const{catchSchemaFailure:$=D}=Q;if($)return _($(U,x),ye({baseQueryMeta:U._bqMeta}))}}catch(x){U=x}throw typeof process<"u"&&process.env.NODE_ENV!=="production"?console.error(`An unhandled error occurred processing a request for the endpoint "${o.endpointName}".
In the case of an unhandled error, no tags will be "provided" or "invalidated".`,U):console.error(U),U}};function c(o,l){const h=p.selectQueryEntry(l,o.queryCacheKey),_=p.selectConfig(l).refetchOnMountOrArgChange,C=h?.fulfilledTimeStamp,q=o.forceRefetch??(o.subscribe&&_);return q?q===!0||(Number(new Date)-Number(C))/1e3>=q:!1}const v=()=>N.createAsyncThunk(`${e}/executeQuery`,u,{getPendingMeta({arg:l}){const h=n[l.endpointName];return ye({startedTimeStamp:Date.now(),...Re(h)?{direction:l.direction}:{}})},condition(l,{getState:h}){const _=h(),C=p.selectQueryEntry(_,l.queryCacheKey),q=C?.fulfilledTimeStamp,z=l.originalArgs,M=C?.originalArgs,Q=n[l.endpointName],j=l.direction;return Ze(l)?!0:C?.status==="pending"?!1:c(l,_)||je(Q)&&Q?.forceRefetch?.({currentArg:z,previousArg:M,endpointState:C,state:_})?!0:!(q&&!j)},dispatchConditionRejection:!0}),i=v(),a=v(),m=N.createAsyncThunk(`${e}/executeMutation`,u,{getPendingMeta(){return ye({startedTimeStamp:Date.now()})}}),R=o=>"force"in o,E=o=>"ifOlderThan"in o,O=(o,l,h)=>(_,C)=>{const q=R(h)&&h.force,z=E(h)&&h.ifOlderThan,M=(j=!0)=>{const V={forceRefetch:j,isPrefetch:!0};return s.endpoints[o].initiate(l,V)},Q=s.endpoints[o].select(l)(C());if(q)_(M());else if(z){const j=Q?.fulfilledTimeStamp;if(!j){_(M());return}(Number(new Date)-Number(new Date(j)))/1e3>=z&&_(M())}else _(M(!1))};function S(o){return l=>l?.meta?.arg?.endpointName===o}function y(o,l){return{matchPending:N.isAllOf(N.isPending(o),S(l)),matchFulfilled:N.isAllOf(N.isFulfilled(o),S(l)),matchRejected:N.isAllOf(N.isRejected(o),S(l))}}return{queryThunk:i,mutationThunk:m,infiniteQueryThunk:a,prefetch:O,updateQueryData:w,upsertQueryData:A,patchQueryData:T,buildMatchThunkActions:y}}function et(e,{pages:t,pageParams:n},r){const s=t.length-1;return e.getNextPageParam(t[s],t,n[s],n,r)}function $t(e,{pages:t,pageParams:n},r){return e.getPreviousPageParam?.(t[0],t,n[0],n,r)}function Ut(e,t,n,r){return at(n[e.meta.arg.endpointName][t],N.isFulfilled(e)?e.payload:void 0,N.isRejectedWithValue(e)?e.payload:void 0,e.meta.arg.originalArgs,"baseQueryMeta"in e.meta?e.meta.baseQueryMeta:void 0,r)}function Oe(e,t,n){const r=e[t];r&&n(r)}function we(e){return("arg"in e?e.arg.fixedCacheKey:e.fixedCacheKey)??e.requestId}function Rt(e,t,n){const r=e[we(t)];r&&n(r)}var Ie={};function qn({reducerPath:e,queryThunk:t,mutationThunk:n,serializeQueryArgs:r,context:{endpointDefinitions:s,apiUid:d,extractRehydrationInfo:p,hasRehydrationInfo:g},assertTagType:D,config:I}){const T=N.createAction(`${e}/resetApiState`);function P(S,y,o,l){S[y.queryCacheKey]??={status:"uninitialized",endpointName:y.endpointName},Oe(S,y.queryCacheKey,h=>{h.status="pending",h.requestId=o&&h.requestId?h.requestId:l.requestId,y.originalArgs!==void 0&&(h.originalArgs=y.originalArgs),h.startedTimeStamp=l.startedTimeStamp;const _=s[l.arg.endpointName];Re(_)&&"direction"in y&&(h.direction=y.direction)})}function f(S,y,o,l){Oe(S,y.arg.queryCacheKey,h=>{if(h.requestId!==y.requestId&&!l)return;const{merge:_}=s[y.arg.endpointName];if(h.status="fulfilled",_)if(h.data!==void 0){const{fulfilledTimeStamp:C,arg:q,baseQueryMeta:z,requestId:M}=y;let Q=N.createNextState(h.data,j=>_(j,o,{arg:q.originalArgs,baseQueryMeta:z,fulfilledTimeStamp:C,requestId:M}));h.data=Q}else h.data=o;else h.data=s[y.arg.endpointName].structuralSharing??!0?it(ee(h.data)?Ht(h.data):h.data,o):o;delete h.error,h.fulfilledTimeStamp=y.fulfilledTimeStamp})}const w=N.createSlice({name:`${e}/queries`,initialState:Ie,reducers:{removeQueryResult:{reducer(S,{payload:{queryCacheKey:y}}){delete S[y]},prepare:N.prepareAutoBatched()},cacheEntriesUpserted:{reducer(S,y){for(const o of y.payload){const{queryDescription:l,value:h}=o;P(S,l,!0,{arg:l,requestId:y.meta.requestId,startedTimeStamp:y.meta.timestamp}),f(S,{arg:l,requestId:y.meta.requestId,fulfilledTimeStamp:y.meta.timestamp,baseQueryMeta:{}},h,!0)}},prepare:S=>({payload:S.map(l=>{const{endpointName:h,arg:_,value:C}=l,q=s[h];return{queryDescription:{type:"query",endpointName:h,originalArgs:l.arg,queryCacheKey:r({queryArgs:_,endpointDefinition:q,endpointName:h})},value:C}}),meta:{[N.SHOULD_AUTOBATCH]:!0,requestId:N.nanoid(),timestamp:Date.now()}})},queryResultPatched:{reducer(S,{payload:{queryCacheKey:y,patches:o}}){Oe(S,y,l=>{l.data=pt(l.data,o.concat())})},prepare:N.prepareAutoBatched()}},extraReducers(S){S.addCase(t.pending,(y,{meta:o,meta:{arg:l}})=>{const h=Ze(l);P(y,l,h,o)}).addCase(t.fulfilled,(y,{meta:o,payload:l})=>{const h=Ze(o.arg);f(y,o,l,h)}).addCase(t.rejected,(y,{meta:{condition:o,arg:l,requestId:h},error:_,payload:C})=>{Oe(y,l.queryCacheKey,q=>{if(!o){if(q.requestId!==h)return;q.status="rejected",q.error=C??_}})}).addMatcher(g,(y,o)=>{const{queries:l}=p(o);for(const[h,_]of Object.entries(l))(_?.status==="fulfilled"||_?.status==="rejected")&&(y[h]=_)})}}),A=N.createSlice({name:`${e}/mutations`,initialState:Ie,reducers:{removeMutationResult:{reducer(S,{payload:y}){const o=we(y);o in S&&delete S[o]},prepare:N.prepareAutoBatched()}},extraReducers(S){S.addCase(n.pending,(y,{meta:o,meta:{requestId:l,arg:h,startedTimeStamp:_}})=>{h.track&&(y[we(o)]={requestId:l,status:"pending",endpointName:h.endpointName,startedTimeStamp:_})}).addCase(n.fulfilled,(y,{payload:o,meta:l})=>{l.arg.track&&Rt(y,l,h=>{h.requestId===l.requestId&&(h.status="fulfilled",h.data=o,h.fulfilledTimeStamp=l.fulfilledTimeStamp)})}).addCase(n.rejected,(y,{payload:o,error:l,meta:h})=>{h.arg.track&&Rt(y,h,_=>{_.requestId===h.requestId&&(_.status="rejected",_.error=o??l)})}).addMatcher(g,(y,o)=>{const{mutations:l}=p(o);for(const[h,_]of Object.entries(l))(_?.status==="fulfilled"||_?.status==="rejected")&&h!==_?.requestId&&(y[h]=_)})}}),b={tags:{},keys:{}},u=N.createSlice({name:`${e}/invalidation`,initialState:b,reducers:{updateProvidedBy:{reducer(S,y){for(const{queryCacheKey:o,providedTags:l}of y.payload){c(S,o);for(const{type:h,id:_}of l){const C=(S.tags[h]??={})[_||"__internal_without_id"]??=[];C.includes(o)||C.push(o)}S.keys[o]=l}},prepare:N.prepareAutoBatched()}},extraReducers(S){S.addCase(w.actions.removeQueryResult,(y,{payload:{queryCacheKey:o}})=>{c(y,o)}).addMatcher(g,(y,o)=>{const{provided:l}=p(o);for(const[h,_]of Object.entries(l.tags??{}))for(const[C,q]of Object.entries(_)){const z=(y.tags[h]??={})[C||"__internal_without_id"]??=[];for(const M of q)z.includes(M)||z.push(M),y.keys[M]=l.keys[M]}}).addMatcher(N.isAnyOf(N.isFulfilled(t),N.isRejectedWithValue(t)),(y,o)=>{v(y,[o])}).addMatcher(w.actions.cacheEntriesUpserted.match,(y,o)=>{const l=o.payload.map(({queryDescription:h,value:_})=>({type:"UNKNOWN",payload:_,meta:{requestStatus:"fulfilled",requestId:"UNKNOWN",arg:h}}));v(y,l)})}});function c(S,y){const o=S.keys[y]??[];for(const l of o){const h=l.type,_=l.id??"__internal_without_id",C=S.tags[h]?.[_];C&&(S.tags[h][_]=C.filter(q=>q!==y))}delete S.keys[y]}function v(S,y){const o=y.map(l=>{const h=Ut(l,"providesTags",s,D),{queryCacheKey:_}=l.meta.arg;return{queryCacheKey:_,providedTags:h}});u.caseReducers.updateProvidedBy(S,u.actions.updateProvidedBy(o))}const i=N.createSlice({name:`${e}/subscriptions`,initialState:Ie,reducers:{updateSubscriptionOptions(S,y){},unsubscribeQueryResult(S,y){},internal_getRTKQSubscriptions(){}}}),a=N.createSlice({name:`${e}/internalSubscriptions`,initialState:Ie,reducers:{subscriptionsUpdated:{reducer(S,y){return pt(S,y.payload)},prepare:N.prepareAutoBatched()}}}),m=N.createSlice({name:`${e}/config`,initialState:{online:_n(),focused:Sn(),middlewareRegistered:!1,...I},reducers:{middlewareRegistered(S,{payload:y}){S.middlewareRegistered=S.middlewareRegistered==="conflict"||d!==y?"conflict":!0}},extraReducers:S=>{S.addCase(Fe,y=>{y.online=!0}).addCase(ot,y=>{y.online=!1}).addCase(ke,y=>{y.focused=!0}).addCase(st,y=>{y.focused=!1}).addMatcher(g,y=>({...y}))}}),R=N.combineReducers({queries:w.reducer,mutations:A.reducer,provided:u.reducer,subscriptions:a.reducer,config:m.reducer}),E=(S,y)=>R(T.match(y)?void 0:S,y),O={...m.actions,...w.actions,...i.actions,...a.actions,...A.actions,...u.actions,resetApiState:T};return{reducer:E,actions:O}}var Te=Symbol.for("RTKQ/skipToken"),Kt={status:"uninitialized"},Et=N.createNextState(Kt,()=>{}),At=N.createNextState(Kt,()=>{});function kn({serializeQueryArgs:e,reducerPath:t,createSelector:n}){const r=i=>Et,s=i=>At;return{buildQuerySelector:f,buildInfiniteQuerySelector:w,buildMutationSelector:A,selectInvalidatedBy:b,selectCachedArgsForQuery:u,selectApiState:p,selectQueries:g,selectMutations:I,selectQueryEntry:D,selectConfig:T};function d(i){return{...i,...gt(i.status)}}function p(i){const a=i[t];if(process.env.NODE_ENV!=="production"&&!a){if(p.triggered)return a;p.triggered=!0,console.error(`Error: No data found at \`state.${t}\`. Did you forget to add the reducer to the store?`)}return a}function g(i){return p(i)?.queries}function D(i,a){return g(i)?.[a]}function I(i){return p(i)?.mutations}function T(i){return p(i)?.config}function P(i,a,m){return R=>{if(R===Te)return n(r,m);const E=e({queryArgs:R,endpointDefinition:a,endpointName:i});return n(S=>D(S,E)??Et,m)}}function f(i,a){return P(i,a,d)}function w(i,a){const{infiniteQueryOptions:m}=a;function R(E){const O={...E,...gt(E.status)},{isLoading:S,isError:y,direction:o}=O,l=o==="forward",h=o==="backward";return{...O,hasNextPage:c(m,O.data,O.originalArgs),hasPreviousPage:v(m,O.data,O.originalArgs),isFetchingNextPage:S&&l,isFetchingPreviousPage:S&&h,isFetchNextPageError:y&&l,isFetchPreviousPageError:y&&h}}return P(i,a,R)}function A(){return i=>{let a;return typeof i=="object"?a=we(i)??Te:a=i,n(a===Te?s:E=>p(E)?.mutations?.[a]??At,d)}}function b(i,a){const m=i[t],R=new Set;for(const E of a.filter(Qe).map(Xe)){const O=m.provided.tags[E.type];if(!O)continue;let S=(E.id!==void 0?O[E.id]:bt(Object.values(O)))??[];for(const y of S)R.add(y)}return bt(Array.from(R.values()).map(E=>{const O=m.queries[E];return O?[{queryCacheKey:E,endpointName:O.endpointName,originalArgs:O.originalArgs}]:[]}))}function u(i,a){return Object.values(g(i)).filter(m=>m?.endpointName===a&&m.status!=="uninitialized").map(m=>m.originalArgs)}function c(i,a,m){return a?et(i,a,m)!=null:!1}function v(i,a,m){return!a||!i.getPreviousPageParam?!1:$t(i,a,m)!=null}}var Ot=WeakMap?new WeakMap:void 0,It=({endpointName:e,queryArgs:t})=>{let n="";const r=Ot?.get(t);if(typeof r=="string")n=r;else{const s=JSON.stringify(t,(d,p)=>(p=typeof p=="bigint"?{$bigint:p.toString()}:p,p=N.isPlainObject(p)?Object.keys(p).sort().reduce((g,D)=>(g[D]=p[D],g),{}):p,p));N.isPlainObject(t)&&Ot?.set(t,s),n=s}return`${e}(${n})`};function Vt(...e){return function(n){const r=Ce(I=>n.extractRehydrationInfo?.(I,{reducerPath:n.reducerPath??"api"})),s={reducerPath:"api",keepUnusedDataFor:60,refetchOnMountOrArgChange:!1,refetchOnFocus:!1,refetchOnReconnect:!1,invalidationBehavior:"delayed",...n,extractRehydrationInfo:r,serializeQueryArgs(I){let T=It;if("serializeQueryArgs"in I.endpointDefinition){const P=I.endpointDefinition.serializeQueryArgs;T=f=>{const w=P(f);return typeof w=="string"?w:It({...f,queryArgs:w})}}else n.serializeQueryArgs&&(T=n.serializeQueryArgs);return T(I)},tagTypes:[...n.tagTypes||[]]},d={endpointDefinitions:{},batch(I){I()},apiUid:N.nanoid(),extractRehydrationInfo:r,hasRehydrationInfo:Ce(I=>r(I)!=null)},p={injectEndpoints:D,enhanceEndpoints({addTagTypes:I,endpoints:T}){if(I)for(const P of I)s.tagTypes.includes(P)||s.tagTypes.push(P);if(T)for(const[P,f]of Object.entries(T))typeof f=="function"?f(d.endpointDefinitions[P]):Object.assign(d.endpointDefinitions[P]||{},f);return p}},g=e.map(I=>I.init(p,s,d));function D(I){const T=I.endpoints({query:P=>({...P,type:"query"}),mutation:P=>({...P,type:"mutation"}),infiniteQuery:P=>({...P,type:"infinitequery"})});for(const[P,f]of Object.entries(T)){if(I.overrideExisting!==!0&&P in d.endpointDefinitions){if(I.overrideExisting==="throw")throw new Error(process.env.NODE_ENV==="production"?N.formatProdErrorMessage(39):`called \`injectEndpoints\` to override already-existing endpointName ${P} without specifying \`overrideExisting: true\``);typeof process<"u"&&process.env.NODE_ENV==="development"&&console.error(`called \`injectEndpoints\` to override already-existing endpointName ${P} without specifying \`overrideExisting: true\``);continue}if(typeof process<"u"&&process.env.NODE_ENV==="development"&&Re(f)){const{infiniteQueryOptions:w}=f,{maxPages:A,getPreviousPageParam:b}=w;if(typeof A=="number"){if(A<1)throw new Error(process.env.NODE_ENV==="production"?N.formatProdErrorMessage(40):`maxPages for endpoint '${P}' must be a number greater than 0`);if(typeof b!="function")throw new Error(process.env.NODE_ENV==="production"?N.formatProdErrorMessage(41):`getPreviousPageParam for endpoint '${P}' must be a function if maxPages is used`)}}d.endpointDefinitions[P]=f;for(const w of g)w.injectEndpoint(P,f)}return p}return p.injectEndpoints({endpoints:n.endpoints})}}function Z(e,...t){return Object.assign(e,...t)}var Fn=({api:e,queryThunk:t,internalState:n,mwApi:r})=>{const s=`${e.reducerPath}/subscriptions`;let d=null,p=null;const{updateSubscriptionOptions:g,unsubscribeQueryResult:D}=e.internalActions,I=(b,u)=>{if(g.match(u)){const{queryCacheKey:v,requestId:i,options:a}=u.payload,m=b.get(v);return m?.has(i)&&m.set(i,a),!0}if(D.match(u)){const{queryCacheKey:v,requestId:i}=u.payload,a=b.get(v);return a&&a.delete(i),!0}if(e.internalActions.removeQueryResult.match(u))return b.delete(u.payload.queryCacheKey),!0;if(t.pending.match(u)){const{meta:{arg:v,requestId:i}}=u,a=Ye(b,v.queryCacheKey,Ge);return v.subscribe&&a.set(i,v.subscriptionOptions??a.get(i)??{}),!0}let c=!1;if(t.rejected.match(u)){const{meta:{condition:v,arg:i,requestId:a}}=u;if(v&&i.subscribe){const m=Ye(b,i.queryCacheKey,Ge);m.set(a,i.subscriptionOptions??m.get(a)??{}),c=!0}}return c},T=()=>n.currentSubscriptions,w={getSubscriptions:T,getSubscriptionCount:b=>T().get(b)?.size??0,isRequestSubscribed:(b,u)=>!!T()?.get(b)?.get(u)};function A(b){return JSON.parse(JSON.stringify(Object.fromEntries([...b].map(([u,c])=>[u,Object.fromEntries(c)]))))}return(b,u)=>{if(d||(d=A(n.currentSubscriptions)),e.util.resetApiState.match(b))return d={},n.currentSubscriptions.clear(),p=null,[!0,!1];if(e.internalActions.internal_getRTKQSubscriptions.match(b))return[!1,w];const c=I(n.currentSubscriptions,b);let v=!0;if(process.env.NODE_ENV==="test"&&typeof b.type=="string"&&b.type===`${e.reducerPath}/getPolling`)return[!1,n.currentPolls];if(c){p||(p=setTimeout(()=>{const m=A(n.currentSubscriptions),[,R]=Ft(d,()=>m);u.next(e.internalActions.subscriptionsUpdated(R)),d=m,p=null},500));const i=typeof b.type=="string"&&!!b.type.startsWith(s),a=t.rejected.match(b)&&b.meta.condition&&!!b.meta.arg.subscribe;v=!i&&!a}return[v,!1]}},jn=2147483647/1e3-1,xn=({reducerPath:e,api:t,queryThunk:n,context:r,internalState:s,selectors:{selectQueryEntry:d,selectConfig:p},getRunningQueryThunk:g,mwApi:D})=>{const{removeQueryResult:I,unsubscribeQueryResult:T,cacheEntriesUpserted:P}=t.internalActions,f=s.runningQueries.get(D.dispatch),w=N.isAnyOf(T.match,n.fulfilled,n.rejected,P.match);function A(i){const a=s.currentSubscriptions.get(i);if(!a)return!1;const m=a.size>0,R=f?.[i]!==void 0;return m||R}const b={},u=(i,a,m)=>{const R=a.getState(),E=p(R);if(w(i)){let O;if(P.match(i))O=i.payload.map(S=>S.queryDescription.queryCacheKey);else{const{queryCacheKey:S}=T.match(i)?i.payload:i.meta.arg;O=[S]}c(O,a,E)}if(t.util.resetApiState.match(i))for(const[O,S]of Object.entries(b))S&&clearTimeout(S),delete b[O];if(r.hasRehydrationInfo(i)){const{queries:O}=r.extractRehydrationInfo(i);c(Object.keys(O),a,E)}};function c(i,a,m){const R=a.getState();for(const E of i){const O=d(R,E);O?.endpointName&&v(E,O.endpointName,a,m)}}function v(i,a,m,R){const O=r.endpointDefinitions[a]?.keepUnusedDataFor??R.keepUnusedDataFor;if(O===1/0)return;const S=Math.max(0,Math.min(O,jn));if(!A(i)){const y=b[i];y&&clearTimeout(y),b[i]=setTimeout(()=>{if(!A(i)){const o=d(m.getState(),i);o?.endpointName&&m.dispatch(g(o.endpointName,o.originalArgs))?.abort(),m.dispatch(I({queryCacheKey:i}))}delete b[i]},S*1e3)}}return u},Tt=new Error("Promise never resolved before cacheEntryRemoved."),zn=({api:e,reducerPath:t,context:n,queryThunk:r,mutationThunk:s,internalState:d,selectors:{selectQueryEntry:p,selectApiState:g}})=>{const D=N.isAsyncThunkAction(r),I=N.isAsyncThunkAction(s),T=N.isFulfilled(r,s),P={};function f(c,v,i){const a=P[c];a?.valueResolved&&(a.valueResolved({data:v,meta:i}),delete a.valueResolved)}function w(c){const v=P[c];v&&(delete P[c],v.cacheEntryRemoved())}const A=(c,v,i)=>{const a=b(c);function m(R,E,O,S){const y=p(i,E),o=p(v.getState(),E);!y&&o&&u(R,S,E,v,O)}if(r.pending.match(c))m(c.meta.arg.endpointName,a,c.meta.requestId,c.meta.arg.originalArgs);else if(e.internalActions.cacheEntriesUpserted.match(c))for(const{queryDescription:R,value:E}of c.payload){const{endpointName:O,originalArgs:S,queryCacheKey:y}=R;m(O,y,c.meta.requestId,S),f(y,E,{})}else if(s.pending.match(c))v.getState()[t].mutations[a]&&u(c.meta.arg.endpointName,c.meta.arg.originalArgs,a,v,c.meta.requestId);else if(T(c))f(a,c.payload,c.meta.baseQueryMeta);else if(e.internalActions.removeQueryResult.match(c)||e.internalActions.removeMutationResult.match(c))w(a);else if(e.util.resetApiState.match(c))for(const R of Object.keys(P))w(R)};function b(c){return D(c)?c.meta.arg.queryCacheKey:I(c)?c.meta.arg.fixedCacheKey??c.meta.requestId:e.internalActions.removeQueryResult.match(c)?c.payload.queryCacheKey:e.internalActions.removeMutationResult.match(c)?we(c.payload):""}function u(c,v,i,a,m){const R=n.endpointDefinitions[c],E=R?.onCacheEntryAdded;if(!E)return;const O={},S=new Promise(C=>{O.cacheEntryRemoved=C}),y=Promise.race([new Promise(C=>{O.valueResolved=C}),S.then(()=>{throw Tt})]);y.catch(()=>{}),P[i]=O;const o=e.endpoints[c].select(Me(R)?v:i),l=a.dispatch((C,q,z)=>z),h={...a,getCacheEntry:()=>o(a.getState()),requestId:m,extra:l,updateCachedData:Me(R)?C=>a.dispatch(e.util.updateQueryData(c,v,C)):void 0,cacheDataLoaded:y,cacheEntryRemoved:S},_=E(v,h);Promise.resolve(_).catch(C=>{if(C!==Tt)throw C})}return A},$n=({api:e,context:{apiUid:t},reducerPath:n})=>(r,s)=>{e.util.resetApiState.match(r)&&s.dispatch(e.internalActions.middlewareRegistered(t)),typeof process<"u"&&process.env.NODE_ENV==="development"&&e.internalActions.middlewareRegistered.match(r)&&r.payload===t&&s.getState()[n]?.config?.middlewareRegistered==="conflict"&&console.warn(`There is a mismatch between slice and middleware for the reducerPath "${n}".
You can only have one api per reducer path, this will lead to crashes in various situations!${n==="api"?`
If you have multiple apis, you *have* to specify the reducerPath option when using createApi!`:""}`)},Un=({reducerPath:e,context:t,context:{endpointDefinitions:n},mutationThunk:r,queryThunk:s,api:d,assertTagType:p,refetchQuery:g,internalState:D})=>{const{removeQueryResult:I}=d.internalActions,T=N.isAnyOf(N.isFulfilled(r),N.isRejectedWithValue(r)),P=N.isAnyOf(N.isFulfilled(r,s),N.isRejected(r,s));let f=[];const w=(u,c)=>{T(u)?b(Ut(u,"invalidatesTags",n,p),c):P(u)?b([],c):d.util.invalidateTags.match(u)&&b(at(u.payload,void 0,void 0,void 0,void 0,p),c)};function A(u){const{queries:c,mutations:v}=u;for(const i of[c,v])for(const a in i)if(i[a]?.status==="pending")return!0;return!1}function b(u,c){const v=c.getState(),i=v[e];if(f.push(...u),i.config.invalidationBehavior==="delayed"&&A(i))return;const a=f;if(f=[],a.length===0)return;const m=d.util.selectInvalidatedBy(v,a);t.batch(()=>{const R=Array.from(m.values());for(const{queryCacheKey:E}of R){const O=i.queries[E],S=Ye(D.currentSubscriptions,E,Ge);O&&(S.size===0?c.dispatch(I({queryCacheKey:E})):O.status!=="uninitialized"&&c.dispatch(g(O)))}})}return w},Kn=({reducerPath:e,queryThunk:t,api:n,refetchQuery:r,internalState:s})=>{const{currentPolls:d,currentSubscriptions:p}=s,g=new Set;let D=null;const I=(u,c)=>{(n.internalActions.updateSubscriptionOptions.match(u)||n.internalActions.unsubscribeQueryResult.match(u))&&T(u.payload.queryCacheKey,c),(t.pending.match(u)||t.rejected.match(u)&&u.meta.condition)&&T(u.meta.arg.queryCacheKey,c),(t.fulfilled.match(u)||t.rejected.match(u)&&!u.meta.condition)&&P(u.meta.arg,c),n.util.resetApiState.match(u)&&(A(),D&&(clearTimeout(D),D=null),g.clear())};function T(u,c){g.add(u),D||(D=setTimeout(()=>{for(const v of g)f({queryCacheKey:v},c);g.clear(),D=null},0))}function P({queryCacheKey:u},c){const v=c.getState()[e],i=v.queries[u],a=p.get(u);if(!i||i.status==="uninitialized")return;const{lowestPollingInterval:m,skipPollingIfUnfocused:R}=b(a);if(!Number.isFinite(m))return;const E=d.get(u);E?.timeout&&(clearTimeout(E.timeout),E.timeout=void 0);const O=Date.now()+m;d.set(u,{nextPollTimestamp:O,pollingInterval:m,timeout:setTimeout(()=>{(v.config.focused||!R)&&c.dispatch(r(i)),P({queryCacheKey:u},c)},m)})}function f({queryCacheKey:u},c){const i=c.getState()[e].queries[u],a=p.get(u);if(!i||i.status==="uninitialized")return;const{lowestPollingInterval:m}=b(a);if(process.env.NODE_ENV==="test"){const O=d.pollUpdateCounters??={};O[u]??=0,O[u]++}if(!Number.isFinite(m)){w(u);return}const R=d.get(u),E=Date.now()+m;(!R||E<R.nextPollTimestamp)&&P({queryCacheKey:u},c)}function w(u){const c=d.get(u);c?.timeout&&clearTimeout(c.timeout),d.delete(u)}function A(){for(const u of d.keys())w(u)}function b(u=new Map){let c=!1,v=Number.POSITIVE_INFINITY;for(const i of u.values())i.pollingInterval&&(v=Math.min(i.pollingInterval,v),c=i.skipPollingIfUnfocused||c);return{lowestPollingInterval:v,skipPollingIfUnfocused:c}}return I},Vn=({api:e,context:t,queryThunk:n,mutationThunk:r})=>{const s=N.isPending(n,r),d=N.isRejected(n,r),p=N.isFulfilled(n,r),g={};return(I,T)=>{if(s(I)){const{requestId:P,arg:{endpointName:f,originalArgs:w}}=I.meta,A=t.endpointDefinitions[f],b=A?.onQueryStarted;if(b){const u={},c=new Promise((m,R)=>{u.resolve=m,u.reject=R});c.catch(()=>{}),g[P]=u;const v=e.endpoints[f].select(Me(A)?w:P),i=T.dispatch((m,R,E)=>E),a={...T,getCacheEntry:()=>v(T.getState()),requestId:P,extra:i,updateCachedData:Me(A)?m=>T.dispatch(e.util.updateQueryData(f,w,m)):void 0,queryFulfilled:c};b(w,a)}}else if(p(I)){const{requestId:P,baseQueryMeta:f}=I.meta;g[P]?.resolve({data:I.payload,meta:f}),delete g[P]}else if(d(I)){const{requestId:P,rejectedWithValue:f,baseQueryMeta:w}=I.meta;g[P]?.reject({error:I.payload??I.error,isUnhandledError:!f,meta:w}),delete g[P]}}},Wn=({reducerPath:e,context:t,api:n,refetchQuery:r,internalState:s})=>{const{removeQueryResult:d}=n.internalActions,p=(D,I)=>{ke.match(D)&&g(I,"refetchOnFocus"),Fe.match(D)&&g(I,"refetchOnReconnect")};function g(D,I){const T=D.getState()[e],P=T.queries,f=s.currentSubscriptions;t.batch(()=>{for(const w of f.keys()){const A=P[w],b=f.get(w);if(!b||!A)continue;const u=[...b.values()];(u.some(v=>v[I]===!0)||u.every(v=>v[I]===void 0)&&T.config[I])&&(b.size===0?D.dispatch(d({queryCacheKey:w})):A.status!=="uninitialized"&&D.dispatch(r(A)))}})}return p};function Bn(e){const{reducerPath:t,queryThunk:n,api:r,context:s,internalState:d}=e,{apiUid:p}=s,g={invalidateTags:N.createAction(`${t}/invalidateTags`)},D=f=>f.type.startsWith(`${t}/`),I=[$n,xn,Un,Kn,zn,Vn];return{middleware:f=>{let w=!1;const A={...e,internalState:d,refetchQuery:P,isThisApiSliceAction:D,mwApi:f},b=I.map(v=>v(A)),u=Fn(A),c=Wn(A);return v=>i=>{if(!N.isAction(i))return v(i);w||(w=!0,f.dispatch(r.internalActions.middlewareRegistered(p)));const a={...f,next:v},m=f.getState(),[R,E]=u(i,a,m);let O;if(R?O=v(i):O=E,f.getState()[t]&&(c(i,a,m),D(i)||s.hasRehydrationInfo(i)))for(const S of b)S(i,a,m);return O}},actions:g};function P(f){return e.api.endpoints[f.endpointName].initiate(f.originalArgs,{subscribe:!1,forceRefetch:!0})}}var Dt=Symbol(),Wt=({createSelector:e=N.createSelector}={})=>({name:Dt,init(t,{baseQuery:n,tagTypes:r,reducerPath:s,serializeQueryArgs:d,keepUnusedDataFor:p,refetchOnMountOrArgChange:g,refetchOnFocus:D,refetchOnReconnect:I,invalidationBehavior:T,onSchemaFailure:P,catchSchemaFailure:f,skipSchemaValidation:w},A){rn();const b=K=>(typeof process<"u"&&process.env.NODE_ENV==="development"&&(r.includes(K.type)||console.error(`Tag type '${K.type}' was used, but not specified in \`tagTypes\`!`)),K);Object.assign(t,{reducerPath:s,endpoints:{},internalActions:{onOnline:Fe,onOffline:ot,onFocus:ke,onFocusLost:st},util:{}});const u=kn({serializeQueryArgs:d,reducerPath:s,createSelector:e}),{selectInvalidatedBy:c,selectCachedArgsForQuery:v,buildQuerySelector:i,buildInfiniteQuerySelector:a,buildMutationSelector:m}=u;Z(t.util,{selectInvalidatedBy:c,selectCachedArgsForQuery:v});const{queryThunk:R,infiniteQueryThunk:E,mutationThunk:O,patchQueryData:S,updateQueryData:y,upsertQueryData:o,prefetch:l,buildMatchThunkActions:h}=Mn({baseQuery:n,reducerPath:s,context:A,api:t,serializeQueryArgs:d,assertTagType:b,selectors:u,onSchemaFailure:P,catchSchemaFailure:f,skipSchemaValidation:w}),{reducer:_,actions:C}=qn({context:A,queryThunk:R,mutationThunk:O,serializeQueryArgs:d,reducerPath:s,assertTagType:b,config:{refetchOnFocus:D,refetchOnReconnect:I,refetchOnMountOrArgChange:g,keepUnusedDataFor:p,reducerPath:s,invalidationBehavior:T}});Z(t.util,{patchQueryData:S,updateQueryData:y,upsertQueryData:o,prefetch:l,resetApiState:C.resetApiState,upsertQueryEntries:C.cacheEntriesUpserted}),Z(t.internalActions,C);const q={currentSubscriptions:new Map,currentPolls:new Map,runningQueries:new Map,runningMutations:new Map},{buildInitiateQuery:z,buildInitiateInfiniteQuery:M,buildInitiateMutation:Q,getRunningMutationThunk:j,getRunningMutationsThunk:V,getRunningQueriesThunk:L,getRunningQueryThunk:U}=Qn({queryThunk:R,mutationThunk:O,infiniteQueryThunk:E,api:t,serializeQueryArgs:d,context:A,internalState:q});Z(t.util,{getRunningMutationThunk:j,getRunningMutationsThunk:V,getRunningQueryThunk:U,getRunningQueriesThunk:L});const{middleware:x,actions:$}=Bn({reducerPath:s,context:A,queryThunk:R,mutationThunk:O,infiniteQueryThunk:E,api:t,assertTagType:b,selectors:u,getRunningQueryThunk:U,internalState:q});return Z(t.util,$),Z(t,{reducer:_,middleware:x}),{name:Dt,injectEndpoint(K,W){const F=t,k=F.endpoints[K]??={};je(W)&&Z(k,{name:K,select:i(K,W),initiate:z(K,W)},h(R,K)),Dn(W)&&Z(k,{name:K,select:m(),initiate:Q(K)},h(O,K)),Re(W)&&Z(k,{name:K,select:a(K,W),initiate:M(K,W)},h(R,K))}}}});Wt();exports.QueryStatus=xt;exports.buildCreateApi=Vt;exports.copyWithStructuralSharing=it;exports.coreModule=Wt;exports.createSelector=jt;exports.fetchBaseQuery=In;exports.setupListeners=Tn;exports.skipToken=Te;
//# sourceMappingURL=rtk-query.modern-PBCErCqb.cjs.map
