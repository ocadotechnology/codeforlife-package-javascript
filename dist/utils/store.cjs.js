"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const D=require("@reduxjs/toolkit");var Ge=Symbol.for("immer-nothing"),he=Symbol.for("immer-draftable"),H=Symbol.for("immer-state"),Pt=process.env.NODE_ENV!=="production"?[function(e){return`The plugin for '${e}' has not been loaded into Immer. To enable the plugin, import and call \`enable${e}()\` when initializing your application.`},function(e){return`produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${e}'`},"This object has been frozen and should not be mutated",function(e){return"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? "+e},"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.","Immer forbids circular references","The first or second argument to `produce` must be a function","The third argument to `produce` must be a function or undefined","First argument to `createDraft` must be a plain object, an array, or an immerable object","First argument to `finishDraft` must be a draft returned by `createDraft`",function(e){return`'current' expects a draft, got: ${e}`},"Object.defineProperty() cannot be used on an Immer draft","Object.setPrototypeOf() cannot be used on an Immer draft","Immer only supports deleting array indices","Immer only supports setting array indices and the 'length' property",function(e){return`'original' expects a draft, got: ${e}`}]:[];function U(e,...t){if(process.env.NODE_ENV!=="production"){const n=Pt[e],r=typeof n=="function"?n.apply(null,t):n;throw new Error(`[Immer] ${r}`)}throw new Error(`[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`)}var ce=Object.getPrototypeOf;function te(e){return!!e&&!!e[H]}function ne(e){return e?Et(e)||Array.isArray(e)||!!e[he]||!!e.constructor?.[he]||we(e)||Pe(e):!1}var Mt=Object.prototype.constructor.toString();function Et(e){if(!e||typeof e!="object")return!1;const t=ce(e);if(t===null)return!0;const n=Object.hasOwnProperty.call(t,"constructor")&&t.constructor;return n===Object?!0:typeof n=="function"&&Function.toString.call(n)===Mt}function Ft(e){return te(e)||U(15,e),e[H].base_}function me(e,t){ae(e)===0?Reflect.ownKeys(e).forEach(n=>{t(n,e[n],e)}):e.forEach((n,r)=>t(r,n,e))}function ae(e){const t=e[H];return t?t.type_:Array.isArray(e)?1:we(e)?2:Pe(e)?3:0}function ge(e,t){return ae(e)===2?e.has(t):Object.prototype.hasOwnProperty.call(e,t)}function Fe(e,t){return ae(e)===2?e.get(t):e[t]}function At(e,t,n){const r=ae(e);r===2?e.set(t,n):r===3?e.add(n):e[t]=n}function jt(e,t){return e===t?e!==0||1/e===1/t:e!==e&&t!==t}function we(e){return e instanceof Map}function Pe(e){return e instanceof Set}function oe(e){return e.copy_||e.base_}function Ke(e,t){if(we(e))return new Map(e);if(Pe(e))return new Set(e);if(Array.isArray(e))return Array.prototype.slice.call(e);const n=Et(e);if(t===!0||t==="class_only"&&!n){const r=Object.getOwnPropertyDescriptors(e);delete r[H];let i=Reflect.ownKeys(r);for(let p=0;p<i.length;p++){const f=i[p],v=r[f];v.writable===!1&&(v.writable=!0,v.configurable=!0),(v.get||v.set)&&(r[f]={configurable:!0,writable:!0,enumerable:v.enumerable,value:e[f]})}return Object.create(ce(e),r)}else{const r=ce(e);if(r!==null&&n)return{...e};const i=Object.create(r);return Object.assign(i,e)}}function Xe(e,t=!1){return Qe(e)||te(e)||!ne(e)||(ae(e)>1&&(e.set=e.add=e.clear=e.delete=zt),Object.freeze(e),t&&Object.entries(e).forEach(([n,r])=>Xe(r,!0))),e}function zt(){U(2)}function Qe(e){return Object.isFrozen(e)}var Ve={};function ue(e){const t=Ve[e];return t||U(0,e),t}function xt(e,t){Ve[e]||(Ve[e]=t)}var ve;function Rt(){return ve}function $t(e,t){return{drafts_:[],parent_:e,immer_:t,canAutoFreeze_:!0,unfinalizedDrafts_:0}}function it(e,t){t&&(ue("Patches"),e.patches_=[],e.inversePatches_=[],e.patchListener_=t)}function Ue(e){We(e),e.drafts_.forEach(Kt),e.drafts_=null}function We(e){e===ve&&(ve=e.parent_)}function st(e){return ve=$t(ve,e)}function Kt(e){const t=e[H];t.type_===0||t.type_===1?t.revoke_():t.revoked_=!0}function ot(e,t){t.unfinalizedDrafts_=t.drafts_.length;const n=t.drafts_[0];return e!==void 0&&e!==n?(n[H].modified_&&(Ue(t),U(4)),ne(e)&&(e=Ie(t,e),t.parent_||De(t,e)),t.patches_&&ue("Patches").generateReplacementPatches_(n[H].base_,e,t.patches_,t.inversePatches_)):e=Ie(t,n,[]),Ue(t),t.patches_&&t.patchListener_(t.patches_,t.inversePatches_),e!==Ge?e:void 0}function Ie(e,t,n){if(Qe(t))return t;const r=t[H];if(!r)return me(t,(i,p)=>ct(e,r,t,i,p,n)),t;if(r.scope_!==e)return t;if(!r.modified_)return De(e,r.base_,!0),r.base_;if(!r.finalized_){r.finalized_=!0,r.scope_.unfinalizedDrafts_--;const i=r.copy_;let p=i,f=!1;r.type_===3&&(p=new Set(i),i.clear(),f=!0),me(p,(v,T)=>ct(e,r,i,v,T,n,f)),De(e,i,!1),n&&e.patches_&&ue("Patches").generatePatches_(r,n,e.patches_,e.inversePatches_)}return r.copy_}function ct(e,t,n,r,i,p,f){if(process.env.NODE_ENV!=="production"&&i===n&&U(5),te(i)){const v=p&&t&&t.type_!==3&&!ge(t.assigned_,r)?p.concat(r):void 0,T=Ie(e,i,v);if(At(n,r,T),te(T))e.canAutoFreeze_=!1;else return}else f&&n.add(i);if(ne(i)&&!Qe(i)){if(!e.immer_.autoFreeze_&&e.unfinalizedDrafts_<1)return;Ie(e,i),(!t||!t.scope_.parent_)&&typeof r!="symbol"&&Object.prototype.propertyIsEnumerable.call(n,r)&&De(e,i)}}function De(e,t,n=!1){!e.parent_&&e.immer_.autoFreeze_&&e.canAutoFreeze_&&Xe(t,n)}function Vt(e,t){const n=Array.isArray(e),r={type_:n?1:0,scope_:t?t.scope_:Rt(),modified_:!1,finalized_:!1,assigned_:{},parent_:t,base_:e,draft_:null,copy_:null,revoke_:null,isManual_:!1};let i=r,p=Ze;n&&(i=[r],p=be);const{revoke:f,proxy:v}=Proxy.revocable(i,p);return r.draft_=v,r.revoke_=f,v}var Ze={get(e,t){if(t===H)return e;const n=oe(e);if(!ge(n,t))return Ut(e,n,t);const r=n[t];return e.finalized_||!ne(r)?r:r===je(e.base_,t)?(ze(e),e.copy_[t]=Le(r,e)):r},has(e,t){return t in oe(e)},ownKeys(e){return Reflect.ownKeys(oe(e))},set(e,t,n){const r=Ot(oe(e),t);if(r?.set)return r.set.call(e.draft_,n),!0;if(!e.modified_){const i=je(oe(e),t),p=i?.[H];if(p&&p.base_===n)return e.copy_[t]=n,e.assigned_[t]=!1,!0;if(jt(n,i)&&(n!==void 0||ge(e.base_,t)))return!0;ze(e),Be(e)}return e.copy_[t]===n&&(n!==void 0||t in e.copy_)||Number.isNaN(n)&&Number.isNaN(e.copy_[t])||(e.copy_[t]=n,e.assigned_[t]=!0),!0},deleteProperty(e,t){return je(e.base_,t)!==void 0||t in e.base_?(e.assigned_[t]=!1,ze(e),Be(e)):delete e.assigned_[t],e.copy_&&delete e.copy_[t],!0},getOwnPropertyDescriptor(e,t){const n=oe(e),r=Reflect.getOwnPropertyDescriptor(n,t);return r&&{writable:!0,configurable:e.type_!==1||t!=="length",enumerable:r.enumerable,value:n[t]}},defineProperty(){U(11)},getPrototypeOf(e){return ce(e.base_)},setPrototypeOf(){U(12)}},be={};me(Ze,(e,t)=>{be[e]=function(){return arguments[0]=arguments[0][0],t.apply(this,arguments)}});be.deleteProperty=function(e,t){return process.env.NODE_ENV!=="production"&&isNaN(parseInt(t))&&U(13),be.set.call(this,e,t,void 0)};be.set=function(e,t,n){return process.env.NODE_ENV!=="production"&&t!=="length"&&isNaN(parseInt(t))&&U(14),Ze.set.call(this,e[0],t,n,e[0])};function je(e,t){const n=e[H];return(n?oe(n):e)[t]}function Ut(e,t,n){const r=Ot(t,n);return r?"value"in r?r.value:r.get?.call(e.draft_):void 0}function Ot(e,t){if(!(t in e))return;let n=ce(e);for(;n;){const r=Object.getOwnPropertyDescriptor(n,t);if(r)return r;n=ce(n)}}function Be(e){e.modified_||(e.modified_=!0,e.parent_&&Be(e.parent_))}function ze(e){e.copy_||(e.copy_=Ke(e.base_,e.scope_.immer_.useStrictShallowCopy_))}var Wt=class{constructor(e){this.autoFreeze_=!0,this.useStrictShallowCopy_=!1,this.produce=(t,n,r)=>{if(typeof t=="function"&&typeof n!="function"){const p=n;n=t;const f=this;return function(T=p,...w){return f.produce(T,I=>n.call(this,I,...w))}}typeof n!="function"&&U(6),r!==void 0&&typeof r!="function"&&U(7);let i;if(ne(t)){const p=st(this),f=Le(t,void 0);let v=!0;try{i=n(f),v=!1}finally{v?Ue(p):We(p)}return it(p,r),ot(i,p)}else if(!t||typeof t!="object"){if(i=n(t),i===void 0&&(i=t),i===Ge&&(i=void 0),this.autoFreeze_&&Xe(i,!0),r){const p=[],f=[];ue("Patches").generateReplacementPatches_(t,i,p,f),r(p,f)}return i}else U(1,t)},this.produceWithPatches=(t,n)=>{if(typeof t=="function")return(f,...v)=>this.produceWithPatches(f,T=>t(T,...v));let r,i;return[this.produce(t,n,(f,v)=>{r=f,i=v}),r,i]},typeof e?.autoFreeze=="boolean"&&this.setAutoFreeze(e.autoFreeze),typeof e?.useStrictShallowCopy=="boolean"&&this.setUseStrictShallowCopy(e.useStrictShallowCopy)}createDraft(e){ne(e)||U(8),te(e)&&(e=Bt(e));const t=st(this),n=Le(e,void 0);return n[H].isManual_=!0,We(t),n}finishDraft(e,t){const n=e&&e[H];(!n||!n.isManual_)&&U(9);const{scope_:r}=n;return it(r,t),ot(void 0,r)}setAutoFreeze(e){this.autoFreeze_=e}setUseStrictShallowCopy(e){this.useStrictShallowCopy_=e}applyPatches(e,t){let n;for(n=t.length-1;n>=0;n--){const i=t[n];if(i.path.length===0&&i.op==="replace"){e=i.value;break}}n>-1&&(t=t.slice(n+1));const r=ue("Patches").applyPatches_;return te(e)?r(e,t):this.produce(e,i=>r(i,t))}};function Le(e,t){const n=we(e)?ue("MapSet").proxyMap_(e,t):Pe(e)?ue("MapSet").proxySet_(e,t):Vt(e,t);return(t?t.scope_:Rt()).drafts_.push(n),n}function Bt(e){return te(e)||U(10,e),It(e)}function It(e){if(!ne(e)||Qe(e))return e;const t=e[H];let n;if(t){if(!t.modified_)return t.base_;t.finalized_=!0,n=Ke(e,t.scope_.immer_.useStrictShallowCopy_)}else n=Ke(e,!0);return me(n,(r,i)=>{At(n,r,It(i))}),t&&(t.finalized_=!1),n}function Lt(){process.env.NODE_ENV!=="production"&&Pt.push('Sets cannot have "replace" patches.',function(o){return"Unsupported patch operation: "+o},function(o){return"Cannot apply patch, path doesn't resolve: "+o},"Patching reserved attributes like __proto__, prototype and constructor is not allowed");const t="replace",n="add",r="remove";function i(o,l,m,S){switch(o.type_){case 0:case 2:return f(o,l,m,S);case 1:return p(o,l,m,S);case 3:return v(o,l,m,S)}}function p(o,l,m,S){let{base_:g,assigned_:s}=o,_=o.copy_;_.length<g.length&&([g,_]=[_,g],[m,S]=[S,m]);for(let a=0;a<g.length;a++)if(s[a]&&_[a]!==g[a]){const u=l.concat([a]);m.push({op:t,path:u,value:b(_[a])}),S.push({op:t,path:u,value:b(g[a])})}for(let a=g.length;a<_.length;a++){const u=l.concat([a]);m.push({op:n,path:u,value:b(_[a])})}for(let a=_.length-1;g.length<=a;--a){const u=l.concat([a]);S.push({op:r,path:u})}}function f(o,l,m,S){const{base_:g,copy_:s}=o;me(o.assigned_,(_,a)=>{const u=Fe(g,_),P=Fe(s,_),O=a?ge(g,_)?t:n:r;if(u===P&&O===t)return;const E=l.concat(_);m.push(O===r?{op:O,path:E}:{op:O,path:E,value:P}),S.push(O===n?{op:r,path:E}:O===r?{op:n,path:E,value:b(u)}:{op:t,path:E,value:b(u)})})}function v(o,l,m,S){let{base_:g,copy_:s}=o,_=0;g.forEach(a=>{if(!s.has(a)){const u=l.concat([_]);m.push({op:r,path:u,value:a}),S.unshift({op:n,path:u,value:a})}_++}),_=0,s.forEach(a=>{if(!g.has(a)){const u=l.concat([_]);m.push({op:n,path:u,value:a}),S.unshift({op:r,path:u,value:a})}_++})}function T(o,l,m,S){m.push({op:t,path:[],value:l===Ge?void 0:l}),S.push({op:t,path:[],value:o})}function w(o,l){return l.forEach(m=>{const{path:S,op:g}=m;let s=o;for(let P=0;P<S.length-1;P++){const O=ae(s);let E=S[P];typeof E!="string"&&typeof E!="number"&&(E=""+E),(O===0||O===1)&&(E==="__proto__"||E==="constructor")&&U(19),typeof s=="function"&&E==="prototype"&&U(19),s=Fe(s,E),typeof s!="object"&&U(18,S.join("/"))}const _=ae(s),a=I(m.value),u=S[S.length-1];switch(g){case t:switch(_){case 2:return s.set(u,a);case 3:U(16);default:return s[u]=a}case n:switch(_){case 1:return u==="-"?s.push(a):s.splice(u,0,a);case 2:return s.set(u,a);case 3:return s.add(a);default:return s[u]=a}case r:switch(_){case 1:return s.splice(u,1);case 2:return s.delete(u);case 3:return s.delete(m.value);default:return delete s[u]}default:U(17,g)}}),o}function I(o){if(!ne(o))return o;if(Array.isArray(o))return o.map(I);if(we(o))return new Map(Array.from(o.entries()).map(([m,S])=>[m,I(S)]));if(Pe(o))return new Set(Array.from(o).map(I));const l=Object.create(ce(o));for(const m in o)l[m]=I(o[m]);return ge(o,he)&&(l[he]=o[he]),l}function b(o){return te(o)?I(o):o}xt("Patches",{applyPatches_:w,generatePatches_:i,generateReplacementPatches_:T})}var J=new Wt;J.produce;var Dt=J.produceWithPatches.bind(J);J.setAutoFreeze.bind(J);J.setUseStrictShallowCopy.bind(J);var at=J.applyPatches.bind(J);J.createDraft.bind(J);J.finishDraft.bind(J);var Ht=class extends Error{issues;constructor(e){super(e[0].message),this.name="SchemaError",this.issues=e}},Jt=(e,t,n)=>{if(t.length===1&&t[0]===n){let r=!1;try{const i={};e(i)===i&&(r=!0)}catch{}if(r){let i;try{throw new Error}catch(p){({stack:i}=p)}console.warn(`The result function returned its own inputs without modification. e.g
\`createSelector([state => state.todos], todos => todos)\`
This could lead to inefficient memoization and unnecessary re-renders.
Ensure transformation logic is in the result function, and extraction logic is in the input selectors.`,{stack:i})}}},Yt=(e,t,n)=>{const{memoize:r,memoizeOptions:i}=t,{inputSelectorResults:p,inputSelectorResultsCopy:f}=e,v=r(()=>({}),...i);if(!(v.apply(null,p)===v.apply(null,f))){let w;try{throw new Error}catch(I){({stack:w}=I)}console.warn(`An input selector returned a different result when passed same arguments.
This means your output selector will likely run more frequently than intended.
Avoid returning a new reference inside your input selector, e.g.
\`createSelector([state => state.todos.map(todo => todo.id)], todoIds => todoIds.length)\``,{arguments:n,firstInputs:p,secondInputs:f,stack:w})}},Gt={inputStabilityCheck:"once",identityFunctionCheck:"once"};function Xt(e,t=`expected a function, instead received ${typeof e}`){if(typeof e!="function")throw new TypeError(t)}function Zt(e,t=`expected an object, instead received ${typeof e}`){if(typeof e!="object")throw new TypeError(t)}function en(e,t="expected all items to be functions, instead received the following types: "){if(!e.every(n=>typeof n=="function")){const n=e.map(r=>typeof r=="function"?`function ${r.name||"unnamed"}()`:typeof r).join(", ");throw new TypeError(`${t}[${n}]`)}}var ut=e=>Array.isArray(e)?e:[e];function tn(e){const t=Array.isArray(e[0])?e[0]:e;return en(t,"createSelector expects all input-selectors to be functions, but received the following types: "),t}function lt(e,t){const n=[],{length:r}=e;for(let i=0;i<r;i++)n.push(e[i].apply(null,t));return n}var nn=(e,t)=>{const{identityFunctionCheck:n,inputStabilityCheck:r}={...Gt,...t};return{identityFunctionCheck:{shouldRun:n==="always"||n==="once"&&e,run:Jt},inputStabilityCheck:{shouldRun:r==="always"||r==="once"&&e,run:Yt}}},rn=class{constructor(e){this.value=e}deref(){return this.value}},sn=typeof WeakRef<"u"?WeakRef:rn,on=0,ft=1;function Ae(){return{s:on,v:void 0,o:null,p:null}}function Te(e,t={}){let n=Ae();const{resultEqualityCheck:r}=t;let i,p=0;function f(){let v=n;const{length:T}=arguments;for(let b=0,o=T;b<o;b++){const l=arguments[b];if(typeof l=="function"||typeof l=="object"&&l!==null){let m=v.o;m===null&&(v.o=m=new WeakMap);const S=m.get(l);S===void 0?(v=Ae(),m.set(l,v)):v=S}else{let m=v.p;m===null&&(v.p=m=new Map);const S=m.get(l);S===void 0?(v=Ae(),m.set(l,v)):v=S}}const w=v;let I;if(v.s===ft)I=v.v;else if(I=e.apply(null,arguments),p++,r){const b=i?.deref?.()??i;b!=null&&r(b,I)&&(I=b,p!==0&&p--),i=typeof I=="object"&&I!==null||typeof I=="function"?new sn(I):I}return w.s=ft,w.v=I,I}return f.clearCache=()=>{n=Ae(),f.resetResultsCount()},f.resultsCount=()=>p,f.resetResultsCount=()=>{p=0},f}function cn(e,...t){const n=typeof e=="function"?{memoize:e,memoizeOptions:t}:e,r=(...i)=>{let p=0,f=0,v,T={},w=i.pop();typeof w=="object"&&(T=w,w=i.pop()),Xt(w,`createSelector expects an output function after the inputs, but received: [${typeof w}]`);const I={...n,...T},{memoize:b,memoizeOptions:o=[],argsMemoize:l=Te,argsMemoizeOptions:m=[],devModeChecks:S={}}=I,g=ut(o),s=ut(m),_=tn(i),a=b(function(){return p++,w.apply(null,arguments)},...g);let u=!0;const P=l(function(){f++;const E=lt(_,arguments);if(v=a.apply(null,E),process.env.NODE_ENV!=="production"){const{identityFunctionCheck:N,inputStabilityCheck:A}=nn(u,S);if(N.shouldRun&&N.run(w,E,v),A.shouldRun){const h=lt(_,arguments);A.run({inputSelectorResults:E,inputSelectorResultsCopy:h},{memoize:b,memoizeOptions:g},arguments)}u&&(u=!1)}return v},...s);return Object.assign(P,{resultFunc:w,memoizedResultFunc:a,dependencies:_,dependencyRecomputations:()=>f,resetDependencyRecomputations:()=>{f=0},lastResult:()=>v,recomputations:()=>p,resetRecomputations:()=>{p=0},memoize:b,argsMemoize:l})};return Object.assign(r,{withTypes:()=>r}),r}var an=cn(Te),un=Object.assign((e,t=an)=>{Zt(e,`createStructuredSelector expects first argument to be an object where each property is a selector, instead received a ${typeof e}`);const n=Object.keys(e),r=n.map(p=>e[p]);return t(r,(...p)=>p.reduce((f,v,T)=>(f[n[T]]=v,f),{}))},{withTypes:()=>un});function dt(e){return{status:e,isUninitialized:e==="uninitialized",isLoading:e==="pending",isSuccess:e==="fulfilled",isError:e==="rejected"}}var pt=D.isPlainObject;function Tt(e,t){if(e===t||!(pt(e)&&pt(t)||Array.isArray(e)&&Array.isArray(t)))return t;const n=Object.keys(t),r=Object.keys(e);let i=n.length===r.length;const p=Array.isArray(t)?[]:{};for(const f of n)p[f]=Tt(e[f],t[f]),i&&(i=e[f]===p[f]);return i?e:p}function pe(e){let t=0;for(const n in e)t++;return t}var yt=e=>[].concat(...e);function ln(){return typeof document>"u"?!0:document.visibilityState!=="hidden"}function Ne(e){return e!=null}function fn(){return typeof navigator>"u"||navigator.onLine===void 0?!0:navigator.onLine}function dn(e,t,n){return e.has(t)?e.get(t):e.set(t,n).get(t)}var ht=class{constructor(e,t=void 0){this.value=e,this.meta=t}},ke=D.createAction("__rtkq/focused"),et=D.createAction("__rtkq/unfocused"),qe=D.createAction("__rtkq/online"),tt=D.createAction("__rtkq/offline"),xe=!1;function pn(e,t){function n(){const r=()=>e(ke()),i=()=>e(et()),p=()=>e(qe()),f=()=>e(tt()),v=()=>{window.document.visibilityState==="visible"?r():i()};return xe||typeof window<"u"&&window.addEventListener&&(window.addEventListener("visibilitychange",v,!1),window.addEventListener("focus",r,!1),window.addEventListener("online",p,!1),window.addEventListener("offline",f,!1),xe=!0),()=>{window.removeEventListener("focus",r),window.removeEventListener("visibilitychange",v),window.removeEventListener("online",p),window.removeEventListener("offline",f),xe=!1}}return n()}function Me(e){return e.type==="query"}function yn(e){return e.type==="mutation"}function Ee(e){return e.type==="infinitequery"}function Ce(e){return Me(e)||Ee(e)}function nt(e,t,n,r,i,p){return hn(e)?e(t,n,r,i).filter(Ne).map(He).map(p):Array.isArray(e)?e.map(He).map(p):[]}function hn(e){return typeof e=="function"}function He(e){return typeof e=="string"?{type:e}:e}function mn(e,t){return e.catch(t)}var Se=Symbol("forceQueryFn"),Je=e=>typeof e[Se]=="function";function gn({serializeQueryArgs:e,queryThunk:t,infiniteQueryThunk:n,mutationThunk:r,api:i,context:p}){const f=new Map,v=new Map,{unsubscribeQueryResult:T,removeMutationResult:w,updateSubscriptionOptions:I}=i.internalActions;return{buildInitiateQuery:s,buildInitiateInfiniteQuery:_,buildInitiateMutation:a,getRunningQueryThunk:b,getRunningMutationThunk:o,getRunningQueriesThunk:l,getRunningMutationsThunk:m};function b(u,P){return O=>{const E=p.endpointDefinitions[u],N=e({queryArgs:P,endpointDefinition:E,endpointName:u});return f.get(O)?.[N]}}function o(u,P){return O=>v.get(O)?.[P]}function l(){return u=>Object.values(f.get(u)||{}).filter(Ne)}function m(){return u=>Object.values(v.get(u)||{}).filter(Ne)}function S(u){if(process.env.NODE_ENV!=="production"){if(S.triggered)return;const P=u(i.internalActions.internal_getRTKQSubscriptions());if(S.triggered=!0,typeof P!="object"||typeof P?.type=="string")throw new Error(process.env.NODE_ENV==="production"?D.formatProdErrorMessage(34):`Warning: Middleware for RTK-Query API at reducerPath "${i.reducerPath}" has not been added to the store.
You must add the middleware for RTK-Query to function correctly!`)}}function g(u,P){const O=(E,{subscribe:N=!0,forceRefetch:A,subscriptionOptions:h,[Se]:c,...y}={})=>(d,R)=>{const C=e({queryArgs:E,endpointDefinition:P,endpointName:u});let q;const j={...y,type:"query",subscribe:N,forceRefetch:A,subscriptionOptions:h,endpointName:u,originalArgs:E,queryCacheKey:C,[Se]:c};if(Me(P))q=t(j);else{const{direction:K,initialPageParam:z}=y;q=n({...j,direction:K,initialPageParam:z})}const k=i.endpoints[u].select(E),Q=d(q),x=k(R());S(d);const{requestId:W,abort:Z}=Q,$=x.requestId!==W,B=f.get(d)?.[C],M=()=>k(R()),V=Object.assign(c?Q.then(M):$&&!B?Promise.resolve(x):Promise.all([B,Q]).then(M),{arg:E,requestId:W,subscriptionOptions:h,queryCacheKey:C,abort:Z,async unwrap(){const K=await V;if(K.isError)throw K.error;return K.data},refetch:()=>d(O(E,{subscribe:!1,forceRefetch:!0})),unsubscribe(){N&&d(T({queryCacheKey:C,requestId:W}))},updateSubscriptionOptions(K){V.subscriptionOptions=K,d(I({endpointName:u,requestId:W,queryCacheKey:C,options:K}))}});if(!B&&!$&&!c){const K=dn(f,d,{});K[C]=V,V.then(()=>{delete K[C],pe(K)||f.delete(d)})}return V};return O}function s(u,P){return g(u,P)}function _(u,P){return g(u,P)}function a(u){return(P,{track:O=!0,fixedCacheKey:E}={})=>(N,A)=>{const h=r({type:"mutation",endpointName:u,originalArgs:P,track:O,fixedCacheKey:E}),c=N(h);S(N);const{requestId:y,abort:d,unwrap:R}=c,C=mn(c.unwrap().then(Q=>({data:Q})),Q=>({error:Q})),q=()=>{N(w({requestId:y,fixedCacheKey:E}))},j=Object.assign(C,{arg:c.arg,requestId:y,abort:d,unwrap:R,reset:q}),k=v.get(N)||{};return v.set(N,k),k[y]=j,j.then(()=>{delete k[y],pe(k)||v.delete(N)}),E&&(k[E]=j,j.then(()=>{k[E]===j&&(delete k[E],pe(k)||v.delete(N))})),j}}}var Nt=class extends Ht{constructor(e,t,n,r){super(e),this.value=t,this.schemaName=n,this._bqMeta=r}};async function se(e,t,n,r){const i=await e["~standard"].validate(t);if(i.issues)throw new Nt(i.issues,t,n,r);return i.value}function vn(e){return e}var ye=(e={})=>({...e,[D.SHOULD_AUTOBATCH]:!0});function bn({reducerPath:e,baseQuery:t,context:{endpointDefinitions:n},serializeQueryArgs:r,api:i,assertTagType:p,selectors:f,onSchemaFailure:v,catchSchemaFailure:T,skipSchemaValidation:w}){const I=(c,y,d,R)=>(C,q)=>{const j=n[c],k=r({queryArgs:y,endpointDefinition:j,endpointName:c});if(C(i.internalActions.queryResultPatched({queryCacheKey:k,patches:d})),!R)return;const Q=i.endpoints[c].select(y)(q()),x=nt(j.providesTags,Q.data,void 0,y,{},p);C(i.internalActions.updateProvidedBy([{queryCacheKey:k,providedTags:x}]))};function b(c,y,d=0){const R=[y,...c];return d&&R.length>d?R.slice(0,-1):R}function o(c,y,d=0){const R=[...c,y];return d&&R.length>d?R.slice(1):R}const l=(c,y,d,R=!0)=>(C,q)=>{const k=i.endpoints[c].select(y)(q()),Q={patches:[],inversePatches:[],undo:()=>C(i.util.patchQueryData(c,y,Q.inversePatches,R))};if(k.status==="uninitialized")return Q;let x;if("data"in k)if(ne(k.data)){const[W,Z,$]=Dt(k.data,d);Q.patches.push(...Z),Q.inversePatches.push(...$),x=W}else x=d(k.data),Q.patches.push({op:"replace",path:[],value:x}),Q.inversePatches.push({op:"replace",path:[],value:k.data});return Q.patches.length===0||C(i.util.patchQueryData(c,y,Q.patches,R)),Q},m=(c,y,d)=>R=>R(i.endpoints[c].initiate(y,{subscribe:!1,forceRefetch:!0,[Se]:()=>({data:d})})),S=(c,y)=>c.query&&c[y]?c[y]:vn,g=async(c,{signal:y,abort:d,rejectWithValue:R,fulfillWithValue:C,dispatch:q,getState:j,extra:k})=>{const Q=n[c.endpointName],{metaSchema:x,skipSchemaValidation:W=w}=Q;try{let Z=S(Q,"transformResponse");const $={signal:y,abort:d,dispatch:q,getState:j,extra:k,endpoint:c.endpointName,type:c.type,forced:c.type==="query"?s(c,j()):void 0,queryCacheKey:c.type==="query"?c.queryCacheKey:void 0},B=c.type==="query"?c[Se]:void 0;let M;const V=async(z,F,L,le)=>{if(F==null&&z.pages.length)return Promise.resolve({data:z});const re={queryArg:c.originalArgs,pageParam:F},fe=await K(re),X=le?b:o;return{data:{pages:X(z.pages,fe.data,L),pageParams:X(z.pageParams,F,L)},meta:fe.meta}};async function K(z){let F;const{extraOptions:L,argSchema:le,rawResponseSchema:re,responseSchema:fe}=Q;if(le&&!W&&(z=await se(le,z,"argSchema",{})),B?F=B():Q.query?F=await t(Q.query(z),$,L):F=await Q.queryFn(z,$,L,Y=>t(Y,$,L)),typeof process<"u"&&process.env.NODE_ENV==="development"){const Y=Q.query?"`baseQuery`":"`queryFn`";let G;if(!F)G=`${Y} did not return anything.`;else if(typeof F!="object")G=`${Y} did not return an object.`;else if(F.error&&F.data)G=`${Y} returned an object containing both \`error\` and \`result\`.`;else if(F.error===void 0&&F.data===void 0)G=`${Y} returned an object containing neither a valid \`error\` and \`result\`. At least one of them should not be \`undefined\``;else for(const de of Object.keys(F))if(de!=="error"&&de!=="data"&&de!=="meta"){G=`The object returned by ${Y} has the unknown property ${de}.`;break}G&&console.error(`Error encountered handling the endpoint ${c.endpointName}.
                  ${G}
                  It needs to return an object with either the shape \`{ data: <value> }\` or \`{ error: <value> }\` that may contain an optional \`meta\` property.
                  Object returned was:`,F)}if(F.error)throw new ht(F.error,F.meta);let{data:X}=F;re&&!W&&(X=await se(re,F.data,"rawResponseSchema",F.meta));let ie=await Z(X,F.meta,z);return fe&&!W&&(ie=await se(fe,ie,"responseSchema",F.meta)),{...F,data:ie}}if(c.type==="query"&&"infiniteQueryOptions"in Q){const{infiniteQueryOptions:z}=Q,{maxPages:F=1/0}=z;let L;const le={pages:[],pageParams:[]},re=f.selectQueryEntry(j(),c.queryCacheKey)?.data,X=s(c,j())&&!c.direction||!re?le:re;if("direction"in c&&c.direction&&X.pages.length){const ie=c.direction==="backward",G=(ie?Ct:Ye)(z,X,c.originalArgs);L=await V(X,G,F,ie)}else{const{initialPageParam:ie=z.initialPageParam}=c,Y=re?.pageParams??[],G=Y[0]??ie,de=Y.length;L=await V(X,G,F),B&&(L={data:L.data.pages[0]});for(let rt=1;rt<de;rt++){const qt=Ye(z,L.data,c.originalArgs);L=await V(L.data,qt,F)}}M=L}else M=await K(c.originalArgs);return x&&!W&&M.meta&&(M.meta=await se(x,M.meta,"metaSchema",M.meta)),C(M.data,ye({fulfilledTimeStamp:Date.now(),baseQueryMeta:M.meta}))}catch(Z){let $=Z;if($ instanceof ht){let B=S(Q,"transformErrorResponse");const{rawErrorResponseSchema:M,errorResponseSchema:V}=Q;let{value:K,meta:z}=$;try{M&&!W&&(K=await se(M,K,"rawErrorResponseSchema",z)),x&&!W&&(z=await se(x,z,"metaSchema",z));let F=await B(K,z,c.originalArgs);return V&&!W&&(F=await se(V,F,"errorResponseSchema",z)),R(F,ye({baseQueryMeta:z}))}catch(F){$=F}}try{if($ instanceof Nt){const B={endpoint:c.endpointName,arg:c.originalArgs,type:c.type,queryCacheKey:c.type==="query"?c.queryCacheKey:void 0};Q.onSchemaFailure?.($,B),v?.($,B);const{catchSchemaFailure:M=T}=Q;if(M)return R(M($,B),ye({baseQueryMeta:$._bqMeta}))}}catch(B){$=B}throw typeof process<"u"&&process.env.NODE_ENV!=="production"?console.error(`An unhandled error occurred processing a request for the endpoint "${c.endpointName}".
In the case of an unhandled error, no tags will be "provided" or "invalidated".`,$):console.error($),$}};function s(c,y){const d=f.selectQueryEntry(y,c.queryCacheKey),R=f.selectConfig(y).refetchOnMountOrArgChange,C=d?.fulfilledTimeStamp,q=c.forceRefetch??(c.subscribe&&R);return q?q===!0||(Number(new Date)-Number(C))/1e3>=q:!1}const _=()=>D.createAsyncThunk(`${e}/executeQuery`,g,{getPendingMeta({arg:y}){const d=n[y.endpointName];return ye({startedTimeStamp:Date.now(),...Ee(d)?{direction:y.direction}:{}})},condition(y,{getState:d}){const R=d(),C=f.selectQueryEntry(R,y.queryCacheKey),q=C?.fulfilledTimeStamp,j=y.originalArgs,k=C?.originalArgs,Q=n[y.endpointName],x=y.direction;return Je(y)?!0:C?.status==="pending"?!1:s(y,R)||Me(Q)&&Q?.forceRefetch?.({currentArg:j,previousArg:k,endpointState:C,state:R})?!0:!(q&&!x)},dispatchConditionRejection:!0}),a=_(),u=_(),P=D.createAsyncThunk(`${e}/executeMutation`,g,{getPendingMeta(){return ye({startedTimeStamp:Date.now()})}}),O=c=>"force"in c,E=c=>"ifOlderThan"in c,N=(c,y,d)=>(R,C)=>{const q=O(d)&&d.force,j=E(d)&&d.ifOlderThan,k=(x=!0)=>{const W={forceRefetch:x,isPrefetch:!0};return i.endpoints[c].initiate(y,W)},Q=i.endpoints[c].select(y)(C());if(q)R(k());else if(j){const x=Q?.fulfilledTimeStamp;if(!x){R(k());return}(Number(new Date)-Number(new Date(x)))/1e3>=j&&R(k())}else R(k(!1))};function A(c){return y=>y?.meta?.arg?.endpointName===c}function h(c,y){return{matchPending:D.isAllOf(D.isPending(c),A(y)),matchFulfilled:D.isAllOf(D.isFulfilled(c),A(y)),matchRejected:D.isAllOf(D.isRejected(c),A(y))}}return{queryThunk:a,mutationThunk:P,infiniteQueryThunk:u,prefetch:N,updateQueryData:l,upsertQueryData:m,patchQueryData:I,buildMatchThunkActions:h}}function Ye(e,{pages:t,pageParams:n},r){const i=t.length-1;return e.getNextPageParam(t[i],t,n[i],n,r)}function Ct(e,{pages:t,pageParams:n},r){return e.getPreviousPageParam?.(t[0],t,n[0],n,r)}function Qt(e,t,n,r){return nt(n[e.meta.arg.endpointName][t],D.isFulfilled(e)?e.payload:void 0,D.isRejectedWithValue(e)?e.payload:void 0,e.meta.arg.originalArgs,"baseQueryMeta"in e.meta?e.meta.baseQueryMeta:void 0,r)}function Re(e,t,n){const r=e[t];r&&n(r)}function _e(e){return("arg"in e?e.arg.fixedCacheKey:e.fixedCacheKey)??e.requestId}function mt(e,t,n){const r=e[_e(t)];r&&n(r)}var Oe={};function Sn({reducerPath:e,queryThunk:t,mutationThunk:n,serializeQueryArgs:r,context:{endpointDefinitions:i,apiUid:p,extractRehydrationInfo:f,hasRehydrationInfo:v},assertTagType:T,config:w}){const I=D.createAction(`${e}/resetApiState`);function b(A,h,c,y){A[h.queryCacheKey]??={status:"uninitialized",endpointName:h.endpointName},Re(A,h.queryCacheKey,d=>{d.status="pending",d.requestId=c&&d.requestId?d.requestId:y.requestId,h.originalArgs!==void 0&&(d.originalArgs=h.originalArgs),d.startedTimeStamp=y.startedTimeStamp;const R=i[y.arg.endpointName];Ee(R)&&"direction"in h&&(d.direction=h.direction)})}function o(A,h,c,y){Re(A,h.arg.queryCacheKey,d=>{if(d.requestId!==h.requestId&&!y)return;const{merge:R}=i[h.arg.endpointName];if(d.status="fulfilled",R)if(d.data!==void 0){const{fulfilledTimeStamp:C,arg:q,baseQueryMeta:j,requestId:k}=h;let Q=D.createNextState(d.data,x=>R(x,c,{arg:q.originalArgs,baseQueryMeta:j,fulfilledTimeStamp:C,requestId:k}));d.data=Q}else d.data=c;else d.data=i[h.arg.endpointName].structuralSharing??!0?Tt(te(d.data)?Ft(d.data):d.data,c):c;delete d.error,d.fulfilledTimeStamp=h.fulfilledTimeStamp})}const l=D.createSlice({name:`${e}/queries`,initialState:Oe,reducers:{removeQueryResult:{reducer(A,{payload:{queryCacheKey:h}}){delete A[h]},prepare:D.prepareAutoBatched()},cacheEntriesUpserted:{reducer(A,h){for(const c of h.payload){const{queryDescription:y,value:d}=c;b(A,y,!0,{arg:y,requestId:h.meta.requestId,startedTimeStamp:h.meta.timestamp}),o(A,{arg:y,requestId:h.meta.requestId,fulfilledTimeStamp:h.meta.timestamp,baseQueryMeta:{}},d,!0)}},prepare:A=>({payload:A.map(y=>{const{endpointName:d,arg:R,value:C}=y,q=i[d];return{queryDescription:{type:"query",endpointName:d,originalArgs:y.arg,queryCacheKey:r({queryArgs:R,endpointDefinition:q,endpointName:d})},value:C}}),meta:{[D.SHOULD_AUTOBATCH]:!0,requestId:D.nanoid(),timestamp:Date.now()}})},queryResultPatched:{reducer(A,{payload:{queryCacheKey:h,patches:c}}){Re(A,h,y=>{y.data=at(y.data,c.concat())})},prepare:D.prepareAutoBatched()}},extraReducers(A){A.addCase(t.pending,(h,{meta:c,meta:{arg:y}})=>{const d=Je(y);b(h,y,d,c)}).addCase(t.fulfilled,(h,{meta:c,payload:y})=>{const d=Je(c.arg);o(h,c,y,d)}).addCase(t.rejected,(h,{meta:{condition:c,arg:y,requestId:d},error:R,payload:C})=>{Re(h,y.queryCacheKey,q=>{if(!c){if(q.requestId!==d)return;q.status="rejected",q.error=C??R}})}).addMatcher(v,(h,c)=>{const{queries:y}=f(c);for(const[d,R]of Object.entries(y))(R?.status==="fulfilled"||R?.status==="rejected")&&(h[d]=R)})}}),m=D.createSlice({name:`${e}/mutations`,initialState:Oe,reducers:{removeMutationResult:{reducer(A,{payload:h}){const c=_e(h);c in A&&delete A[c]},prepare:D.prepareAutoBatched()}},extraReducers(A){A.addCase(n.pending,(h,{meta:c,meta:{requestId:y,arg:d,startedTimeStamp:R}})=>{d.track&&(h[_e(c)]={requestId:y,status:"pending",endpointName:d.endpointName,startedTimeStamp:R})}).addCase(n.fulfilled,(h,{payload:c,meta:y})=>{y.arg.track&&mt(h,y,d=>{d.requestId===y.requestId&&(d.status="fulfilled",d.data=c,d.fulfilledTimeStamp=y.fulfilledTimeStamp)})}).addCase(n.rejected,(h,{payload:c,error:y,meta:d})=>{d.arg.track&&mt(h,d,R=>{R.requestId===d.requestId&&(R.status="rejected",R.error=c??y)})}).addMatcher(v,(h,c)=>{const{mutations:y}=f(c);for(const[d,R]of Object.entries(y))(R?.status==="fulfilled"||R?.status==="rejected")&&d!==R?.requestId&&(h[d]=R)})}}),S={tags:{},keys:{}},g=D.createSlice({name:`${e}/invalidation`,initialState:S,reducers:{updateProvidedBy:{reducer(A,h){for(const{queryCacheKey:c,providedTags:y}of h.payload){s(A,c);for(const{type:d,id:R}of y){const C=(A.tags[d]??={})[R||"__internal_without_id"]??=[];C.includes(c)||C.push(c)}A.keys[c]=y}},prepare:D.prepareAutoBatched()}},extraReducers(A){A.addCase(l.actions.removeQueryResult,(h,{payload:{queryCacheKey:c}})=>{s(h,c)}).addMatcher(v,(h,c)=>{const{provided:y}=f(c);for(const[d,R]of Object.entries(y))for(const[C,q]of Object.entries(R)){const j=(h.tags[d]??={})[C||"__internal_without_id"]??=[];for(const k of q)j.includes(k)||j.push(k)}}).addMatcher(D.isAnyOf(D.isFulfilled(t),D.isRejectedWithValue(t)),(h,c)=>{_(h,[c])}).addMatcher(l.actions.cacheEntriesUpserted.match,(h,c)=>{const y=c.payload.map(({queryDescription:d,value:R})=>({type:"UNKNOWN",payload:R,meta:{requestStatus:"fulfilled",requestId:"UNKNOWN",arg:d}}));_(h,y)})}});function s(A,h){const c=A.keys[h]??[];for(const y of c){const d=y.type,R=y.id??"__internal_without_id",C=A.tags[d]?.[R];C&&(A.tags[d][R]=C.filter(q=>q!==h))}delete A.keys[h]}function _(A,h){const c=h.map(y=>{const d=Qt(y,"providesTags",i,T),{queryCacheKey:R}=y.meta.arg;return{queryCacheKey:R,providedTags:d}});g.caseReducers.updateProvidedBy(A,g.actions.updateProvidedBy(c))}const a=D.createSlice({name:`${e}/subscriptions`,initialState:Oe,reducers:{updateSubscriptionOptions(A,h){},unsubscribeQueryResult(A,h){},internal_getRTKQSubscriptions(){}}}),u=D.createSlice({name:`${e}/internalSubscriptions`,initialState:Oe,reducers:{subscriptionsUpdated:{reducer(A,h){return at(A,h.payload)},prepare:D.prepareAutoBatched()}}}),P=D.createSlice({name:`${e}/config`,initialState:{online:fn(),focused:ln(),middlewareRegistered:!1,...w},reducers:{middlewareRegistered(A,{payload:h}){A.middlewareRegistered=A.middlewareRegistered==="conflict"||p!==h?"conflict":!0}},extraReducers:A=>{A.addCase(qe,h=>{h.online=!0}).addCase(tt,h=>{h.online=!1}).addCase(ke,h=>{h.focused=!0}).addCase(et,h=>{h.focused=!1}).addMatcher(v,h=>({...h}))}}),O=D.combineReducers({queries:l.reducer,mutations:m.reducer,provided:g.reducer,subscriptions:u.reducer,config:P.reducer}),E=(A,h)=>O(I.match(h)?void 0:A,h),N={...P.actions,...l.actions,...a.actions,...u.actions,...m.actions,...g.actions,resetApiState:I};return{reducer:E,actions:N}}var $e=Symbol.for("RTKQ/skipToken"),kt={status:"uninitialized"},gt=D.createNextState(kt,()=>{}),vt=D.createNextState(kt,()=>{});function _n({serializeQueryArgs:e,reducerPath:t,createSelector:n}){const r=a=>gt,i=a=>vt;return{buildQuerySelector:o,buildInfiniteQuerySelector:l,buildMutationSelector:m,selectInvalidatedBy:S,selectCachedArgsForQuery:g,selectApiState:f,selectQueries:v,selectMutations:w,selectQueryEntry:T,selectConfig:I};function p(a){return{...a,...dt(a.status)}}function f(a){const u=a[t];if(process.env.NODE_ENV!=="production"&&!u){if(f.triggered)return u;f.triggered=!0,console.error(`Error: No data found at \`state.${t}\`. Did you forget to add the reducer to the store?`)}return u}function v(a){return f(a)?.queries}function T(a,u){return v(a)?.[u]}function w(a){return f(a)?.mutations}function I(a){return f(a)?.config}function b(a,u,P){return O=>{if(O===$e)return n(r,P);const E=e({queryArgs:O,endpointDefinition:u,endpointName:a});return n(A=>T(A,E)??gt,P)}}function o(a,u){return b(a,u,p)}function l(a,u){const{infiniteQueryOptions:P}=u;function O(E){const N={...E,...dt(E.status)},{isLoading:A,isError:h,direction:c}=N,y=c==="forward",d=c==="backward";return{...N,hasNextPage:s(P,N.data,N.originalArgs),hasPreviousPage:_(P,N.data,N.originalArgs),isFetchingNextPage:A&&y,isFetchingPreviousPage:A&&d,isFetchNextPageError:h&&y,isFetchPreviousPageError:h&&d}}return b(a,u,O)}function m(){return a=>{let u;return typeof a=="object"?u=_e(a)??$e:u=a,n(u===$e?i:E=>f(E)?.mutations?.[u]??vt,p)}}function S(a,u){const P=a[t],O=new Set;for(const E of u.filter(Ne).map(He)){const N=P.provided.tags[E.type];if(!N)continue;let A=(E.id!==void 0?N[E.id]:yt(Object.values(N)))??[];for(const h of A)O.add(h)}return yt(Array.from(O.values()).map(E=>{const N=P.queries[E];return N?[{queryCacheKey:E,endpointName:N.endpointName,originalArgs:N.originalArgs}]:[]}))}function g(a,u){return Object.values(v(a)).filter(P=>P?.endpointName===u&&P.status!=="uninitialized").map(P=>P.originalArgs)}function s(a,u,P){return u?Ye(a,u,P)!=null:!1}function _(a,u,P){return!u||!a.getPreviousPageParam?!1:Ct(a,u,P)!=null}}var bt=WeakMap?new WeakMap:void 0,St=({endpointName:e,queryArgs:t})=>{let n="";const r=bt?.get(t);if(typeof r=="string")n=r;else{const i=JSON.stringify(t,(p,f)=>(f=typeof f=="bigint"?{$bigint:f.toString()}:f,f=D.isPlainObject(f)?Object.keys(f).sort().reduce((v,T)=>(v[T]=f[T],v),{}):f,f));D.isPlainObject(t)&&bt?.set(t,i),n=i}return`${e}(${n})`};function wn(...e){return function(n){const r=Te(w=>n.extractRehydrationInfo?.(w,{reducerPath:n.reducerPath??"api"})),i={reducerPath:"api",keepUnusedDataFor:60,refetchOnMountOrArgChange:!1,refetchOnFocus:!1,refetchOnReconnect:!1,invalidationBehavior:"delayed",...n,extractRehydrationInfo:r,serializeQueryArgs(w){let I=St;if("serializeQueryArgs"in w.endpointDefinition){const b=w.endpointDefinition.serializeQueryArgs;I=o=>{const l=b(o);return typeof l=="string"?l:St({...o,queryArgs:l})}}else n.serializeQueryArgs&&(I=n.serializeQueryArgs);return I(w)},tagTypes:[...n.tagTypes||[]]},p={endpointDefinitions:{},batch(w){w()},apiUid:D.nanoid(),extractRehydrationInfo:r,hasRehydrationInfo:Te(w=>r(w)!=null)},f={injectEndpoints:T,enhanceEndpoints({addTagTypes:w,endpoints:I}){if(w)for(const b of w)i.tagTypes.includes(b)||i.tagTypes.push(b);if(I)for(const[b,o]of Object.entries(I))typeof o=="function"?o(p.endpointDefinitions[b]):Object.assign(p.endpointDefinitions[b]||{},o);return f}},v=e.map(w=>w.init(f,i,p));function T(w){const I=w.endpoints({query:b=>({...b,type:"query"}),mutation:b=>({...b,type:"mutation"}),infiniteQuery:b=>({...b,type:"infinitequery"})});for(const[b,o]of Object.entries(I)){if(w.overrideExisting!==!0&&b in p.endpointDefinitions){if(w.overrideExisting==="throw")throw new Error(process.env.NODE_ENV==="production"?D.formatProdErrorMessage(39):`called \`injectEndpoints\` to override already-existing endpointName ${b} without specifying \`overrideExisting: true\``);typeof process<"u"&&process.env.NODE_ENV==="development"&&console.error(`called \`injectEndpoints\` to override already-existing endpointName ${b} without specifying \`overrideExisting: true\``);continue}if(typeof process<"u"&&process.env.NODE_ENV==="development"&&Ee(o)){const{infiniteQueryOptions:l}=o,{maxPages:m,getPreviousPageParam:S}=l;if(typeof m=="number"){if(m<1)throw new Error(process.env.NODE_ENV==="production"?D.formatProdErrorMessage(40):`maxPages for endpoint '${b}' must be a number greater than 0`);if(typeof S!="function")throw new Error(process.env.NODE_ENV==="production"?D.formatProdErrorMessage(41):`getPreviousPageParam for endpoint '${b}' must be a function if maxPages is used`)}}p.endpointDefinitions[b]=o;for(const l of v)l.injectEndpoint(b,o)}return f}return f.injectEndpoints({endpoints:n.endpoints})}}function ee(e,...t){return Object.assign(e,...t)}var Pn=({api:e,queryThunk:t,internalState:n})=>{const r=`${e.reducerPath}/subscriptions`;let i=null,p=null;const{updateSubscriptionOptions:f,unsubscribeQueryResult:v}=e.internalActions,T=(l,m)=>{if(f.match(m)){const{queryCacheKey:g,requestId:s,options:_}=m.payload;return l?.[g]?.[s]&&(l[g][s]=_),!0}if(v.match(m)){const{queryCacheKey:g,requestId:s}=m.payload;return l[g]&&delete l[g][s],!0}if(e.internalActions.removeQueryResult.match(m))return delete l[m.payload.queryCacheKey],!0;if(t.pending.match(m)){const{meta:{arg:g,requestId:s}}=m,_=l[g.queryCacheKey]??={};return _[`${s}_running`]={},g.subscribe&&(_[s]=g.subscriptionOptions??_[s]??{}),!0}let S=!1;if(t.fulfilled.match(m)||t.rejected.match(m)){const g=l[m.meta.arg.queryCacheKey]||{},s=`${m.meta.requestId}_running`;S||=!!g[s],delete g[s]}if(t.rejected.match(m)){const{meta:{condition:g,arg:s,requestId:_}}=m;if(g&&s.subscribe){const a=l[s.queryCacheKey]??={};a[_]=s.subscriptionOptions??a[_]??{},S=!0}}return S},w=()=>n.currentSubscriptions,o={getSubscriptions:w,getSubscriptionCount:l=>{const S=w()[l]??{};return pe(S)},isRequestSubscribed:(l,m)=>!!w()?.[l]?.[m]};return(l,m)=>{if(i||(i=JSON.parse(JSON.stringify(n.currentSubscriptions))),e.util.resetApiState.match(l))return i=n.currentSubscriptions={},p=null,[!0,!1];if(e.internalActions.internal_getRTKQSubscriptions.match(l))return[!1,o];const S=T(n.currentSubscriptions,l);let g=!0;if(S){p||(p=setTimeout(()=>{const a=JSON.parse(JSON.stringify(n.currentSubscriptions)),[,u]=Dt(i,()=>a);m.next(e.internalActions.subscriptionsUpdated(u)),i=a,p=null},500));const s=typeof l.type=="string"&&!!l.type.startsWith(r),_=t.rejected.match(l)&&l.meta.condition&&!!l.meta.arg.subscribe;g=!s&&!_}return[g,!1]}};function En(e){for(const t in e)return!1;return!0}var An=2147483647/1e3-1,Rn=({reducerPath:e,api:t,queryThunk:n,context:r,internalState:i,selectors:{selectQueryEntry:p,selectConfig:f}})=>{const{removeQueryResult:v,unsubscribeQueryResult:T,cacheEntriesUpserted:w}=t.internalActions,I=D.isAnyOf(T.match,n.fulfilled,n.rejected,w.match);function b(g){const s=i.currentSubscriptions[g];return!!s&&!En(s)}const o={},l=(g,s,_)=>{const a=s.getState(),u=f(a);if(I(g)){let P;if(w.match(g))P=g.payload.map(O=>O.queryDescription.queryCacheKey);else{const{queryCacheKey:O}=T.match(g)?g.payload:g.meta.arg;P=[O]}m(P,s,u)}if(t.util.resetApiState.match(g))for(const[P,O]of Object.entries(o))O&&clearTimeout(O),delete o[P];if(r.hasRehydrationInfo(g)){const{queries:P}=r.extractRehydrationInfo(g);m(Object.keys(P),s,u)}};function m(g,s,_){const a=s.getState();for(const u of g){const P=p(a,u);S(u,P?.endpointName,s,_)}}function S(g,s,_,a){const P=r.endpointDefinitions[s]?.keepUnusedDataFor??a.keepUnusedDataFor;if(P===1/0)return;const O=Math.max(0,Math.min(P,An));if(!b(g)){const E=o[g];E&&clearTimeout(E),o[g]=setTimeout(()=>{b(g)||_.dispatch(v({queryCacheKey:g})),delete o[g]},O*1e3)}}return l},_t=new Error("Promise never resolved before cacheEntryRemoved."),On=({api:e,reducerPath:t,context:n,queryThunk:r,mutationThunk:i,internalState:p,selectors:{selectQueryEntry:f,selectApiState:v}})=>{const T=D.isAsyncThunkAction(r),w=D.isAsyncThunkAction(i),I=D.isFulfilled(r,i),b={};function o(s,_,a){const u=b[s];u?.valueResolved&&(u.valueResolved({data:_,meta:a}),delete u.valueResolved)}function l(s){const _=b[s];_&&(delete b[s],_.cacheEntryRemoved())}const m=(s,_,a)=>{const u=S(s);function P(O,E,N,A){const h=f(a,E),c=f(_.getState(),E);!h&&c&&g(O,A,E,_,N)}if(r.pending.match(s))P(s.meta.arg.endpointName,u,s.meta.requestId,s.meta.arg.originalArgs);else if(e.internalActions.cacheEntriesUpserted.match(s))for(const{queryDescription:O,value:E}of s.payload){const{endpointName:N,originalArgs:A,queryCacheKey:h}=O;P(N,h,s.meta.requestId,A),o(h,E,{})}else if(i.pending.match(s))_.getState()[t].mutations[u]&&g(s.meta.arg.endpointName,s.meta.arg.originalArgs,u,_,s.meta.requestId);else if(I(s))o(u,s.payload,s.meta.baseQueryMeta);else if(e.internalActions.removeQueryResult.match(s)||e.internalActions.removeMutationResult.match(s))l(u);else if(e.util.resetApiState.match(s))for(const O of Object.keys(b))l(O)};function S(s){return T(s)?s.meta.arg.queryCacheKey:w(s)?s.meta.arg.fixedCacheKey??s.meta.requestId:e.internalActions.removeQueryResult.match(s)?s.payload.queryCacheKey:e.internalActions.removeMutationResult.match(s)?_e(s.payload):""}function g(s,_,a,u,P){const O=n.endpointDefinitions[s],E=O?.onCacheEntryAdded;if(!E)return;const N={},A=new Promise(C=>{N.cacheEntryRemoved=C}),h=Promise.race([new Promise(C=>{N.valueResolved=C}),A.then(()=>{throw _t})]);h.catch(()=>{}),b[a]=N;const c=e.endpoints[s].select(Ce(O)?_:a),y=u.dispatch((C,q,j)=>j),d={...u,getCacheEntry:()=>c(u.getState()),requestId:P,extra:y,updateCachedData:Ce(O)?C=>u.dispatch(e.util.updateQueryData(s,_,C)):void 0,cacheDataLoaded:h,cacheEntryRemoved:A},R=E(_,d);Promise.resolve(R).catch(C=>{if(C!==_t)throw C})}return m},In=({api:e,context:{apiUid:t},reducerPath:n})=>(r,i)=>{e.util.resetApiState.match(r)&&i.dispatch(e.internalActions.middlewareRegistered(t)),typeof process<"u"&&process.env.NODE_ENV==="development"&&e.internalActions.middlewareRegistered.match(r)&&r.payload===t&&i.getState()[n]?.config?.middlewareRegistered==="conflict"&&console.warn(`There is a mismatch between slice and middleware for the reducerPath "${n}".
You can only have one api per reducer path, this will lead to crashes in various situations!${n==="api"?`
If you have multiple apis, you *have* to specify the reducerPath option when using createApi!`:""}`)},Dn=({reducerPath:e,context:t,context:{endpointDefinitions:n},mutationThunk:r,queryThunk:i,api:p,assertTagType:f,refetchQuery:v,internalState:T})=>{const{removeQueryResult:w}=p.internalActions,I=D.isAnyOf(D.isFulfilled(r),D.isRejectedWithValue(r)),b=D.isAnyOf(D.isFulfilled(r,i),D.isRejected(r,i));let o=[];const l=(g,s)=>{I(g)?S(Qt(g,"invalidatesTags",n,f),s):b(g)?S([],s):p.util.invalidateTags.match(g)&&S(nt(g.payload,void 0,void 0,void 0,void 0,f),s)};function m(g){const{queries:s,mutations:_}=g;for(const a of[s,_])for(const u in a)if(a[u]?.status==="pending")return!0;return!1}function S(g,s){const _=s.getState(),a=_[e];if(o.push(...g),a.config.invalidationBehavior==="delayed"&&m(a))return;const u=o;if(o=[],u.length===0)return;const P=p.util.selectInvalidatedBy(_,u);t.batch(()=>{const O=Array.from(P.values());for(const{queryCacheKey:E}of O){const N=a.queries[E],A=T.currentSubscriptions[E]??{};N&&(pe(A)===0?s.dispatch(w({queryCacheKey:E})):N.status!=="uninitialized"&&s.dispatch(v(N)))}})}return l},Tn=({reducerPath:e,queryThunk:t,api:n,refetchQuery:r,internalState:i})=>{const p={},f=(o,l)=>{(n.internalActions.updateSubscriptionOptions.match(o)||n.internalActions.unsubscribeQueryResult.match(o))&&T(o.payload,l),(t.pending.match(o)||t.rejected.match(o)&&o.meta.condition)&&T(o.meta.arg,l),(t.fulfilled.match(o)||t.rejected.match(o)&&!o.meta.condition)&&v(o.meta.arg,l),n.util.resetApiState.match(o)&&I()};function v({queryCacheKey:o},l){const m=l.getState()[e],S=m.queries[o],g=i.currentSubscriptions[o];if(!S||S.status==="uninitialized")return;const{lowestPollingInterval:s,skipPollingIfUnfocused:_}=b(g);if(!Number.isFinite(s))return;const a=p[o];a?.timeout&&(clearTimeout(a.timeout),a.timeout=void 0);const u=Date.now()+s;p[o]={nextPollTimestamp:u,pollingInterval:s,timeout:setTimeout(()=>{(m.config.focused||!_)&&l.dispatch(r(S)),v({queryCacheKey:o},l)},s)}}function T({queryCacheKey:o},l){const S=l.getState()[e].queries[o],g=i.currentSubscriptions[o];if(!S||S.status==="uninitialized")return;const{lowestPollingInterval:s}=b(g);if(!Number.isFinite(s)){w(o);return}const _=p[o],a=Date.now()+s;(!_||a<_.nextPollTimestamp)&&v({queryCacheKey:o},l)}function w(o){const l=p[o];l?.timeout&&clearTimeout(l.timeout),delete p[o]}function I(){for(const o of Object.keys(p))w(o)}function b(o={}){let l=!1,m=Number.POSITIVE_INFINITY;for(let S in o)o[S].pollingInterval&&(m=Math.min(o[S].pollingInterval,m),l=o[S].skipPollingIfUnfocused||l);return{lowestPollingInterval:m,skipPollingIfUnfocused:l}}return f},Nn=({api:e,context:t,queryThunk:n,mutationThunk:r})=>{const i=D.isPending(n,r),p=D.isRejected(n,r),f=D.isFulfilled(n,r),v={};return(w,I)=>{if(i(w)){const{requestId:b,arg:{endpointName:o,originalArgs:l}}=w.meta,m=t.endpointDefinitions[o],S=m?.onQueryStarted;if(S){const g={},s=new Promise((P,O)=>{g.resolve=P,g.reject=O});s.catch(()=>{}),v[b]=g;const _=e.endpoints[o].select(Ce(m)?l:b),a=I.dispatch((P,O,E)=>E),u={...I,getCacheEntry:()=>_(I.getState()),requestId:b,extra:a,updateCachedData:Ce(m)?P=>I.dispatch(e.util.updateQueryData(o,l,P)):void 0,queryFulfilled:s};S(l,u)}}else if(f(w)){const{requestId:b,baseQueryMeta:o}=w.meta;v[b]?.resolve({data:w.payload,meta:o}),delete v[b]}else if(p(w)){const{requestId:b,rejectedWithValue:o,baseQueryMeta:l}=w.meta;v[b]?.reject({error:w.payload??w.error,isUnhandledError:!o,meta:l}),delete v[b]}}},Cn=({reducerPath:e,context:t,api:n,refetchQuery:r,internalState:i})=>{const{removeQueryResult:p}=n.internalActions,f=(T,w)=>{ke.match(T)&&v(w,"refetchOnFocus"),qe.match(T)&&v(w,"refetchOnReconnect")};function v(T,w){const I=T.getState()[e],b=I.queries,o=i.currentSubscriptions;t.batch(()=>{for(const l of Object.keys(o)){const m=b[l],S=o[l];if(!S||!m)continue;(Object.values(S).some(s=>s[w]===!0)||Object.values(S).every(s=>s[w]===void 0)&&I.config[w])&&(pe(S)===0?T.dispatch(p({queryCacheKey:l})):m.status!=="uninitialized"&&T.dispatch(r(m)))}})}return f};function Qn(e){const{reducerPath:t,queryThunk:n,api:r,context:i}=e,{apiUid:p}=i,f={invalidateTags:D.createAction(`${t}/invalidateTags`)},v=b=>b.type.startsWith(`${t}/`),T=[In,Rn,Dn,Tn,On,Nn];return{middleware:b=>{let o=!1;const m={...e,internalState:{currentSubscriptions:{}},refetchQuery:I,isThisApiSliceAction:v},S=T.map(_=>_(m)),g=Pn(m),s=Cn(m);return _=>a=>{if(!D.isAction(a))return _(a);o||(o=!0,b.dispatch(r.internalActions.middlewareRegistered(p)));const u={...b,next:_},P=b.getState(),[O,E]=g(a,u,P);let N;if(O?N=_(a):N=E,b.getState()[t]&&(s(a,u,P),v(a)||i.hasRehydrationInfo(a)))for(const A of S)A(a,u,P);return N}},actions:f};function I(b){return e.api.endpoints[b.endpointName].initiate(b.originalArgs,{subscribe:!1,forceRefetch:!0})}}var wt=Symbol(),kn=({createSelector:e=D.createSelector}={})=>({name:wt,init(t,{baseQuery:n,tagTypes:r,reducerPath:i,serializeQueryArgs:p,keepUnusedDataFor:f,refetchOnMountOrArgChange:v,refetchOnFocus:T,refetchOnReconnect:w,invalidationBehavior:I,onSchemaFailure:b,catchSchemaFailure:o,skipSchemaValidation:l},m){Lt();const S=M=>(typeof process<"u"&&process.env.NODE_ENV==="development"&&(r.includes(M.type)||console.error(`Tag type '${M.type}' was used, but not specified in \`tagTypes\`!`)),M);Object.assign(t,{reducerPath:i,endpoints:{},internalActions:{onOnline:qe,onOffline:tt,onFocus:ke,onFocusLost:et},util:{}});const g=_n({serializeQueryArgs:p,reducerPath:i,createSelector:e}),{selectInvalidatedBy:s,selectCachedArgsForQuery:_,buildQuerySelector:a,buildInfiniteQuerySelector:u,buildMutationSelector:P}=g;ee(t.util,{selectInvalidatedBy:s,selectCachedArgsForQuery:_});const{queryThunk:O,infiniteQueryThunk:E,mutationThunk:N,patchQueryData:A,updateQueryData:h,upsertQueryData:c,prefetch:y,buildMatchThunkActions:d}=bn({baseQuery:n,reducerPath:i,context:m,api:t,serializeQueryArgs:p,assertTagType:S,selectors:g,onSchemaFailure:b,catchSchemaFailure:o,skipSchemaValidation:l}),{reducer:R,actions:C}=Sn({context:m,queryThunk:O,mutationThunk:N,serializeQueryArgs:p,reducerPath:i,assertTagType:S,config:{refetchOnFocus:T,refetchOnReconnect:w,refetchOnMountOrArgChange:v,keepUnusedDataFor:f,reducerPath:i,invalidationBehavior:I}});ee(t.util,{patchQueryData:A,updateQueryData:h,upsertQueryData:c,prefetch:y,resetApiState:C.resetApiState,upsertQueryEntries:C.cacheEntriesUpserted}),ee(t.internalActions,C);const{middleware:q,actions:j}=Qn({reducerPath:i,context:m,queryThunk:O,mutationThunk:N,infiniteQueryThunk:E,api:t,assertTagType:S,selectors:g});ee(t.util,j),ee(t,{reducer:R,middleware:q});const{buildInitiateQuery:k,buildInitiateInfiniteQuery:Q,buildInitiateMutation:x,getRunningMutationThunk:W,getRunningMutationsThunk:Z,getRunningQueriesThunk:$,getRunningQueryThunk:B}=gn({queryThunk:O,mutationThunk:N,infiniteQueryThunk:E,api:t,serializeQueryArgs:p,context:m});return ee(t.util,{getRunningMutationThunk:W,getRunningMutationsThunk:Z,getRunningQueryThunk:B,getRunningQueriesThunk:$}),{name:wt,injectEndpoint(M,V){const K=t,z=K.endpoints[M]??={};Me(V)&&ee(z,{name:M,select:a(M,V),initiate:k(M,V)},d(O,M)),yn(V)&&ee(z,{name:M,select:P(),initiate:x(M)},d(N,M)),Ee(V)&&ee(z,{name:M,select:u(M,V),initiate:Q(M,V)},d(O,M))}}}});kn();function qn({reducer:e,middlewares:t=[],preloadedState:n={}}){const r=D.configureStore({reducer:e,middleware:i=>i().concat(t),preloadedState:n});return pn(r.dispatch),r}exports.makeStore=qn;
//# sourceMappingURL=store.cjs.js.map
