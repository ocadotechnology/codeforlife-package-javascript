{"version":3,"file":"form-BvDvbYiq.js","sources":["../src/hooks/api.tsx","../src/utils/form.ts"],"sourcesContent":["import { type Dispatch, type SetStateAction, useState } from \"react\"\n\nexport type Pagination = { page: number; limit: number; offset: number }\nexport type SetPagination = Dispatch<\n  SetStateAction<{ page: number; limit: number }>\n>\nexport type UsePaginationOptions = Partial<{\n  page: number\n  limit: number\n}>\n\nexport function usePagination(\n  options?: UsePaginationOptions,\n): [Pagination, SetPagination] {\n  const { page = 0, limit = 150 } = options || {}\n\n  const [pagination, _setPagination] = useState<Pagination>({\n    page,\n    limit,\n    offset: page * limit,\n  })\n\n  const setPagination: SetPagination = value => {\n    _setPagination(({ page: previousPage, limit: previousLimit }) => {\n      const pagination =\n        typeof value === \"function\"\n          ? value({ page: previousPage, limit: previousLimit })\n          : value\n      let page = pagination.page\n      const limit = pagination.limit\n\n      if (limit !== previousLimit) page = 0\n\n      return { page, limit, offset: page * limit }\n    })\n  }\n\n  return [pagination, setPagination]\n}\n","import type { FieldValidator, FormikHelpers } from \"formik\"\nimport { type Schema, type ValidateOptions, ValidationError } from \"yup\"\nimport type { TypedMutationTrigger } from \"@reduxjs/toolkit/query/react\"\n\nimport { excludeKeyPaths, getKeyPaths, getNestedProperty } from \"./general\"\n\nexport type FormValues = Record<string, any>\n\nexport function isFormError(error: unknown): boolean {\n  return (\n    typeof error === \"object\" &&\n    error !== null &&\n    \"status\" in error &&\n    error.status === 400 &&\n    \"data\" in error &&\n    typeof error.data === \"object\" &&\n    error.data !== null\n  )\n}\n\nexport function setFormErrors(\n  error: unknown,\n  setErrors: (errors: object) => void,\n): void {\n  if (!isFormError(error)) throw error\n\n  const data = Object.fromEntries(\n    Object.entries((error as { data: object }).data).map(([field, errors]) => {\n      if (Array.isArray(errors)) errors = errors.join(\". \")\n      return [field, errors]\n    }),\n  )\n\n  setErrors(data)\n}\n\nexport type SubmitFormOptions<\n  Values extends FormValues,\n  QueryArg extends FormValues,\n  ResultType,\n> = Partial<{\n  exclude: string[]\n  include: string[]\n  onlyDirtyValues: boolean\n  then: (\n    result: ResultType,\n    values: Values,\n    helpers: FormikHelpers<Values>,\n  ) => void\n  catch: (\n    error: unknown,\n    values: Values,\n    helpers: FormikHelpers<Values>,\n  ) => void\n  finally: (values: Values, helpers: FormikHelpers<Values>) => void\n}> &\n  (Values extends QueryArg\n    ? { clean?: (values: Values) => QueryArg }\n    : { clean: (values: Values) => QueryArg })\n\nexport type SubmitFormHandler<Values extends FormValues> = (\n  values: Values,\n  helpers: FormikHelpers<Values>,\n) => void | Promise<any>\n\nexport function submitForm<\n  Values extends QueryArg,\n  QueryArg extends FormValues,\n  ResultType,\n>(\n  trigger: TypedMutationTrigger<ResultType, QueryArg, any>,\n  initialValues: Values,\n  options?: SubmitFormOptions<Values, QueryArg, ResultType>,\n): SubmitFormHandler<Values>\n\nexport function submitForm<\n  Values extends FormValues,\n  QueryArg extends FormValues,\n  ResultType,\n>(\n  trigger: TypedMutationTrigger<ResultType, QueryArg, any>,\n  initialValues: Values,\n  options: SubmitFormOptions<Values, QueryArg, ResultType>,\n): SubmitFormHandler<Values>\n\nexport function submitForm<\n  Values extends FormValues,\n  QueryArg extends FormValues,\n  ResultType,\n>(\n  trigger: TypedMutationTrigger<ResultType, QueryArg, any>,\n  initialValues: Values,\n  options?: SubmitFormOptions<Values, QueryArg, ResultType>,\n): SubmitFormHandler<Values> {\n  const {\n    include,\n    onlyDirtyValues = false,\n    then,\n    catch: _catch,\n    finally: _finally,\n  } = options || {}\n  let { exclude = [] } = options || {}\n\n  return (values, helpers) => {\n    let arg =\n      options && options.clean\n        ? options.clean(values as QueryArg & FormValues)\n        : (values as unknown as QueryArg)\n\n    if (onlyDirtyValues) {\n      exclude = [\n        ...exclude,\n        ...getCleanNames(values, initialValues).filter(\n          cleanName => !exclude.includes(cleanName),\n        ),\n      ]\n    }\n\n    if (include) exclude = exclude.filter(name => !include.includes(name))\n\n    if (exclude.length) arg = excludeKeyPaths(arg, exclude) as QueryArg\n\n    trigger(arg)\n      .unwrap()\n      .then(result => {\n        if (then) then(result, values, helpers)\n      })\n      .catch(error => {\n        if (_catch) _catch(error, values, helpers)\n        setFormErrors(error, helpers.setErrors)\n      })\n      .finally(() => {\n        if (_finally) _finally(values, helpers)\n      })\n  }\n}\n\nexport function schemaToFieldValidator(\n  schema: Schema,\n  options?: ValidateOptions,\n): FieldValidator {\n  return async value => {\n    try {\n      await schema.validate(value, options)\n    } catch (error) {\n      if (error instanceof ValidationError) {\n        return error.errors.join(\". \")\n      }\n\n      throw error\n    }\n  }\n}\n\n// Checking if individual fields are dirty is not currently supported.\n// https://github.com/jaredpalmer/formik/issues/1421\nexport function getDirty<Values extends FormValues>(\n  values: Values,\n  initialValues: Values,\n  names?: string[],\n): Record<string, boolean> {\n  if (!names) names = getKeyPaths(values)\n\n  return Object.fromEntries(\n    names.map(name => [name, isDirty(values, initialValues, name)]),\n  )\n}\n\nexport function isDirty<Values extends FormValues>(\n  values: Values,\n  initialValues: Values,\n  name: string,\n): boolean {\n  const value: unknown = getNestedProperty(values, name)\n  const initialValue: unknown = getNestedProperty(initialValues, name)\n\n  return value !== initialValue\n}\n\nexport function getCleanNames<Values extends FormValues>(\n  values: Values,\n  initialValues: Values,\n  names?: string[],\n): string[] {\n  return Object.entries(getDirty(values, initialValues, names))\n    .filter(\n      ([\n        _, // eslint-disable-line @typescript-eslint/no-unused-vars\n        isDirty,\n      ]) => !isDirty,\n    )\n    .map(([name]) => name)\n}\n"],"names":["usePagination","options","page","limit","pagination","_setPagination","useState","value","previousPage","previousLimit","isFormError","error","setFormErrors","setErrors","data","field","errors","submitForm","trigger","initialValues","include","onlyDirtyValues","then","_catch","_finally","exclude","values","helpers","arg","getCleanNames","cleanName","name","excludeKeyPaths","result","schemaToFieldValidator","schema","ValidationError","getDirty","names","getKeyPaths","isDirty","getNestedProperty","initialValue","_"],"mappings":";;;AAWO,SAASA,EACdC,GAC6B;AAC7B,QAAM,EAAE,MAAAC,IAAO,GAAG,OAAAC,IAAQ,IAAA,IAAQF,KAAW,CAAA,GAEvC,CAACG,GAAYC,CAAc,IAAIC,EAAqB;AAAA,IACxD,MAAAJ;AAAA,IACA,OAAAC;AAAA,IACA,QAAQD,IAAOC;AAAA,EAAA,CAChB;AAiBD,SAAO,CAACC,GAf6B,CAAAG,MAAS;AAC5C,IAAAF,EAAe,CAAC,EAAE,MAAMG,GAAc,OAAOC,QAAoB;AAC/D,YAAML,IACJ,OAAOG,KAAU,aACbA,EAAM,EAAE,MAAMC,GAAc,OAAOC,EAAA,CAAe,IAClDF;AACN,UAAIL,IAAOE,EAAW;AACtB,YAAMD,IAAQC,EAAW;AAEzB,aAAID,MAAUM,MAAeP,IAAO,IAE7B,EAAE,MAAAA,GAAM,OAAAC,GAAO,QAAQD,IAAOC,EAAAA;AAAAA,IACvC,CAAC;AAAA,EACH,CAEiC;AACnC;;;;AC9BO,SAASO,EAAYC,GAAyB;AACnD,SACE,OAAOA,KAAU,YACjBA,MAAU,QACV,YAAYA,KACZA,EAAM,WAAW,OACjB,UAAUA,KACV,OAAOA,EAAM,QAAS,YACtBA,EAAM,SAAS;AAEnB;AAEO,SAASC,EACdD,GACAE,GACM;AACN,MAAI,CAACH,EAAYC,CAAK,EAAG,OAAMA;AAE/B,QAAMG,IAAO,OAAO;AAAA,IAClB,OAAO,QAASH,EAA2B,IAAI,EAAE,IAAI,CAAC,CAACI,GAAOC,CAAM,OAC9D,MAAM,QAAQA,CAAM,MAAGA,IAASA,EAAO,KAAK,IAAI,IAC7C,CAACD,GAAOC,CAAM,EACtB;AAAA,EAAA;AAGH,EAAAH,EAAUC,CAAI;AAChB;AAmDO,SAASG,EAKdC,GACAC,GACAlB,GAC2B;AAC3B,QAAM;AAAA,IACJ,SAAAmB;AAAA,IACA,iBAAAC,IAAkB;AAAA,IAClB,MAAAC;AAAA,IACA,OAAOC;AAAA,IACP,SAASC;AAAA,EAAA,IACPvB,KAAW,CAAA;AACf,MAAI,EAAE,SAAAwB,IAAU,GAAC,IAAMxB,KAAW,CAAA;AAElC,SAAO,CAACyB,GAAQC,MAAY;AAC1B,QAAIC,IACF3B,KAAWA,EAAQ,QACfA,EAAQ,MAAMyB,CAA+B,IAC5CA;AAEP,IAAIL,MACFI,IAAU;AAAA,MACR,GAAGA;AAAA,MACH,GAAGI,EAAcH,GAAQP,CAAa,EAAE;AAAA,QACtC,CAAAW,MAAa,CAACL,EAAQ,SAASK,CAAS;AAAA,MAAA;AAAA,IAC1C,IAIAV,UAAmBK,EAAQ,OAAO,OAAQ,CAACL,EAAQ,SAASW,CAAI,CAAC,IAEjEN,EAAQ,WAAQG,IAAMI,EAAgBJ,GAAKH,CAAO,IAEtDP,EAAQU,CAAG,EACR,OAAA,EACA,KAAK,CAAAK,MAAU;AACd,MAAIX,KAAMA,EAAKW,GAAQP,GAAQC,CAAO;AAAA,IACxC,CAAC,EACA,MAAM,CAAAhB,MAAS;AACd,MAAIY,KAAQA,EAAOZ,GAAOe,GAAQC,CAAO,GACzCf,EAAcD,GAAOgB,EAAQ,SAAS;AAAA,IACxC,CAAC,EACA,QAAQ,MAAM;AACb,MAAIH,KAAUA,EAASE,GAAQC,CAAO;AAAA,IACxC,CAAC;AAAA,EACL;AACF;AAEO,SAASO,EACdC,GACAlC,GACgB;AAChB,SAAO,OAAMM,MAAS;AACpB,QAAI;AACF,YAAM4B,EAAO,SAAS5B,GAAON,CAAO;AAAA,IACtC,SAASU,GAAO;AACd,UAAIA,aAAiByB;AACnB,eAAOzB,EAAM,OAAO,KAAK,IAAI;AAG/B,YAAMA;AAAA,IACR;AAAA,EACF;AACF;AAIO,SAAS0B,EACdX,GACAP,GACAmB,GACyB;AACzB,SAAKA,MAAOA,IAAQC,EAAYb,CAAM,IAE/B,OAAO;AAAA,IACZY,EAAM,IAAI,CAAAP,MAAQ,CAACA,GAAMS,EAAQd,GAAQP,GAAeY,CAAI,CAAC,CAAC;AAAA,EAAA;AAElE;AAEO,SAASS,EACdd,GACAP,GACAY,GACS;AACT,QAAMxB,IAAiBkC,EAAkBf,GAAQK,CAAI,GAC/CW,IAAwBD,EAAkBtB,GAAeY,CAAI;AAEnE,SAAOxB,MAAUmC;AACnB;AAEO,SAASb,EACdH,GACAP,GACAmB,GACU;AACV,SAAO,OAAO,QAAQD,EAASX,GAAQP,GAAemB,CAAK,CAAC,EACzD;AAAA,IACC,CAAC;AAAA,MACCK;AAAA;AAAA,MACAH;AAAAA,IAAA,MACI,CAACA;AAAAA,EAAA,EAER,IAAI,CAAC,CAACT,CAAI,MAAMA,CAAI;AACzB;;;;;;;;;;;"}