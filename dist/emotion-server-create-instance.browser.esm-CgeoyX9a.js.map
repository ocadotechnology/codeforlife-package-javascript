{"version":3,"file":"emotion-server-create-instance.browser.esm-CgeoyX9a.js","sources":["../node_modules/through/index.js","../node_modules/buffer-from/index.js","../node_modules/readable-stream/node_modules/isarray/index.js","../node_modules/core-util-is/lib/util.js","../node_modules/inherits/inherits_browser.js","../node_modules/string_decoder/index.js","../node_modules/readable-stream/lib/_stream_readable.js","../node_modules/readable-stream/lib/_stream_duplex.js","../node_modules/readable-stream/lib/_stream_writable.js","../node_modules/readable-stream/lib/_stream_transform.js","../node_modules/readable-stream/lib/_stream_passthrough.js","../node_modules/readable-stream/readable.js","../node_modules/html-tokenize/index.js","../node_modules/process-nextick-args/index.js","../node_modules/duplexer2/node_modules/isarray/index.js","../node_modules/duplexer2/node_modules/readable-stream/lib/internal/streams/stream-browser.js","../node_modules/duplexer2/node_modules/safe-buffer/index.js","../node_modules/duplexer2/node_modules/readable-stream/lib/internal/streams/BufferList.js","../node_modules/duplexer2/node_modules/readable-stream/lib/internal/streams/destroy.js","../node_modules/util-deprecate/browser.js","../node_modules/duplexer2/node_modules/readable-stream/lib/_stream_writable.js","../node_modules/duplexer2/node_modules/readable-stream/lib/_stream_duplex.js","../node_modules/duplexer2/node_modules/string_decoder/lib/string_decoder.js","../node_modules/duplexer2/node_modules/readable-stream/lib/_stream_readable.js","../node_modules/duplexer2/node_modules/readable-stream/lib/_stream_transform.js","../node_modules/duplexer2/node_modules/readable-stream/lib/_stream_passthrough.js","../node_modules/duplexer2/node_modules/readable-stream/readable-browser.js","../node_modules/duplexer2/index.js","../node_modules/object-assign/index.js","../node_modules/multipipe/index.js","../node_modules/@emotion/server/create-instance/dist/emotion-server-create-instance.browser.esm.js"],"sourcesContent":["var Stream = require('stream')\n\n// through\n//\n// a stream that does nothing but re-emit the input.\n// useful for aggregating a series of changing but not ending streams into one stream)\n\nexports = module.exports = through\nthrough.through = through\n\n//create a readable writable stream.\n\nfunction through (write, end, opts) {\n  write = write || function (data) { this.queue(data) }\n  end = end || function () { this.queue(null) }\n\n  var ended = false, destroyed = false, buffer = [], _ended = false\n  var stream = new Stream()\n  stream.readable = stream.writable = true\n  stream.paused = false\n\n//  stream.autoPause   = !(opts && opts.autoPause   === false)\n  stream.autoDestroy = !(opts && opts.autoDestroy === false)\n\n  stream.write = function (data) {\n    write.call(this, data)\n    return !stream.paused\n  }\n\n  function drain() {\n    while(buffer.length && !stream.paused) {\n      var data = buffer.shift()\n      if(null === data)\n        return stream.emit('end')\n      else\n        stream.emit('data', data)\n    }\n  }\n\n  stream.queue = stream.push = function (data) {\n//    console.error(ended)\n    if(_ended) return stream\n    if(data === null) _ended = true\n    buffer.push(data)\n    drain()\n    return stream\n  }\n\n  //this will be registered as the first 'end' listener\n  //must call destroy next tick, to make sure we're after any\n  //stream piped from here.\n  //this is only a problem if end is not emitted synchronously.\n  //a nicer way to do this is to make sure this is the last listener for 'end'\n\n  stream.on('end', function () {\n    stream.readable = false\n    if(!stream.writable && stream.autoDestroy)\n      process.nextTick(function () {\n        stream.destroy()\n      })\n  })\n\n  function _end () {\n    stream.writable = false\n    end.call(stream)\n    if(!stream.readable && stream.autoDestroy)\n      stream.destroy()\n  }\n\n  stream.end = function (data) {\n    if(ended) return\n    ended = true\n    if(arguments.length) stream.write(data)\n    _end() // will emit or queue\n    return stream\n  }\n\n  stream.destroy = function () {\n    if(destroyed) return\n    destroyed = true\n    ended = true\n    buffer.length = 0\n    stream.writable = stream.readable = false\n    stream.emit('close')\n    return stream\n  }\n\n  stream.pause = function () {\n    if(stream.paused) return\n    stream.paused = true\n    return stream\n  }\n\n  stream.resume = function () {\n    if(stream.paused) {\n      stream.paused = false\n      stream.emit('resume')\n    }\n    drain()\n    //may have become paused again,\n    //as drain emits 'data'.\n    if(!stream.paused)\n      stream.emit('drain')\n    return stream\n  }\n  return stream\n}\n\n","var toString = Object.prototype.toString\n\nvar isModern = (\n  typeof Buffer.alloc === 'function' &&\n  typeof Buffer.allocUnsafe === 'function' &&\n  typeof Buffer.from === 'function'\n)\n\nfunction isArrayBuffer (input) {\n  return toString.call(input).slice(8, -1) === 'ArrayBuffer'\n}\n\nfunction fromArrayBuffer (obj, byteOffset, length) {\n  byteOffset >>>= 0\n\n  var maxLength = obj.byteLength - byteOffset\n\n  if (maxLength < 0) {\n    throw new RangeError(\"'offset' is out of bounds\")\n  }\n\n  if (length === undefined) {\n    length = maxLength\n  } else {\n    length >>>= 0\n\n    if (length > maxLength) {\n      throw new RangeError(\"'length' is out of bounds\")\n    }\n  }\n\n  return isModern\n    ? Buffer.from(obj.slice(byteOffset, byteOffset + length))\n    : new Buffer(new Uint8Array(obj.slice(byteOffset, byteOffset + length)))\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  return isModern\n    ? Buffer.from(string, encoding)\n    : new Buffer(string, encoding)\n}\n\nfunction bufferFrom (value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (isArrayBuffer(value)) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  return isModern\n    ? Buffer.from(value)\n    : new Buffer(value)\n}\n\nmodule.exports = bufferFrom\n","module.exports = Array.isArray || function (arr) {\n  return Object.prototype.toString.call(arr) == '[object Array]';\n};\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\n\nfunction isArray(arg) {\n  if (Array.isArray) {\n    return Array.isArray(arg);\n  }\n  return objectToString(arg) === '[object Array]';\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = require('buffer').Buffer.isBuffer;\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n          value: ctor,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      })\n    }\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      var TempCtor = function () {}\n      TempCtor.prototype = superCtor.prototype\n      ctor.prototype = new TempCtor()\n      ctor.prototype.constructor = ctor\n    }\n  }\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar Buffer = require('buffer').Buffer;\n\nvar isBufferEncoding = Buffer.isEncoding\n  || function(encoding) {\n       switch (encoding && encoding.toLowerCase()) {\n         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;\n         default: return false;\n       }\n     }\n\n\nfunction assertEncoding(encoding) {\n  if (encoding && !isBufferEncoding(encoding)) {\n    throw new Error('Unknown encoding: ' + encoding);\n  }\n}\n\n// StringDecoder provides an interface for efficiently splitting a series of\n// buffers into a series of JS strings without breaking apart multi-byte\n// characters. CESU-8 is handled as part of the UTF-8 encoding.\n//\n// @TODO Handling all encodings inside a single object makes it very difficult\n// to reason about this code, so it should be split up in the future.\n// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code\n// points as used by CESU-8.\nvar StringDecoder = exports.StringDecoder = function(encoding) {\n  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');\n  assertEncoding(encoding);\n  switch (this.encoding) {\n    case 'utf8':\n      // CESU-8 represents each of Surrogate Pair by 3-bytes\n      this.surrogateSize = 3;\n      break;\n    case 'ucs2':\n    case 'utf16le':\n      // UTF-16 represents each of Surrogate Pair by 2-bytes\n      this.surrogateSize = 2;\n      this.detectIncompleteChar = utf16DetectIncompleteChar;\n      break;\n    case 'base64':\n      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.\n      this.surrogateSize = 3;\n      this.detectIncompleteChar = base64DetectIncompleteChar;\n      break;\n    default:\n      this.write = passThroughWrite;\n      return;\n  }\n\n  // Enough space to store all bytes of a single character. UTF-8 needs 4\n  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).\n  this.charBuffer = new Buffer(6);\n  // Number of bytes received for the current incomplete multi-byte character.\n  this.charReceived = 0;\n  // Number of bytes expected for the current incomplete multi-byte character.\n  this.charLength = 0;\n};\n\n\n// write decodes the given buffer and returns it as JS string that is\n// guaranteed to not contain any partial multi-byte characters. Any partial\n// character found at the end of the buffer is buffered up, and will be\n// returned when calling write again with the remaining bytes.\n//\n// Note: Converting a Buffer containing an orphan surrogate to a String\n// currently works, but converting a String to a Buffer (via `new Buffer`, or\n// Buffer#write) will replace incomplete surrogates with the unicode\n// replacement character. See https://codereview.chromium.org/121173009/ .\nStringDecoder.prototype.write = function(buffer) {\n  var charStr = '';\n  // if our last write ended with an incomplete multibyte character\n  while (this.charLength) {\n    // determine how many remaining bytes this buffer has to offer for this char\n    var available = (buffer.length >= this.charLength - this.charReceived) ?\n        this.charLength - this.charReceived :\n        buffer.length;\n\n    // add the new bytes to the char buffer\n    buffer.copy(this.charBuffer, this.charReceived, 0, available);\n    this.charReceived += available;\n\n    if (this.charReceived < this.charLength) {\n      // still not enough chars in this buffer? wait for more ...\n      return '';\n    }\n\n    // remove bytes belonging to the current character from the buffer\n    buffer = buffer.slice(available, buffer.length);\n\n    // get the character that was split\n    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);\n\n    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character\n    var charCode = charStr.charCodeAt(charStr.length - 1);\n    if (charCode >= 0xD800 && charCode <= 0xDBFF) {\n      this.charLength += this.surrogateSize;\n      charStr = '';\n      continue;\n    }\n    this.charReceived = this.charLength = 0;\n\n    // if there are no more bytes in this buffer, just emit our char\n    if (buffer.length === 0) {\n      return charStr;\n    }\n    break;\n  }\n\n  // determine and set charLength / charReceived\n  this.detectIncompleteChar(buffer);\n\n  var end = buffer.length;\n  if (this.charLength) {\n    // buffer the incomplete character bytes we got\n    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);\n    end -= this.charReceived;\n  }\n\n  charStr += buffer.toString(this.encoding, 0, end);\n\n  var end = charStr.length - 1;\n  var charCode = charStr.charCodeAt(end);\n  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character\n  if (charCode >= 0xD800 && charCode <= 0xDBFF) {\n    var size = this.surrogateSize;\n    this.charLength += size;\n    this.charReceived += size;\n    this.charBuffer.copy(this.charBuffer, size, 0, size);\n    buffer.copy(this.charBuffer, 0, 0, size);\n    return charStr.substring(0, end);\n  }\n\n  // or just emit the charStr\n  return charStr;\n};\n\n// detectIncompleteChar determines if there is an incomplete UTF-8 character at\n// the end of the given buffer. If so, it sets this.charLength to the byte\n// length that character, and sets this.charReceived to the number of bytes\n// that are available for this character.\nStringDecoder.prototype.detectIncompleteChar = function(buffer) {\n  // determine how many bytes we have to check at the end of this buffer\n  var i = (buffer.length >= 3) ? 3 : buffer.length;\n\n  // Figure out if one of the last i bytes of our buffer announces an\n  // incomplete char.\n  for (; i > 0; i--) {\n    var c = buffer[buffer.length - i];\n\n    // See http://en.wikipedia.org/wiki/UTF-8#Description\n\n    // 110XXXXX\n    if (i == 1 && c >> 5 == 0x06) {\n      this.charLength = 2;\n      break;\n    }\n\n    // 1110XXXX\n    if (i <= 2 && c >> 4 == 0x0E) {\n      this.charLength = 3;\n      break;\n    }\n\n    // 11110XXX\n    if (i <= 3 && c >> 3 == 0x1E) {\n      this.charLength = 4;\n      break;\n    }\n  }\n  this.charReceived = i;\n};\n\nStringDecoder.prototype.end = function(buffer) {\n  var res = '';\n  if (buffer && buffer.length)\n    res = this.write(buffer);\n\n  if (this.charReceived) {\n    var cr = this.charReceived;\n    var buf = this.charBuffer;\n    var enc = this.encoding;\n    res += buf.slice(0, cr).toString(enc);\n  }\n\n  return res;\n};\n\nfunction passThroughWrite(buffer) {\n  return buffer.toString(this.encoding);\n}\n\nfunction utf16DetectIncompleteChar(buffer) {\n  this.charReceived = buffer.length % 2;\n  this.charLength = this.charReceived ? 2 : 0;\n}\n\nfunction base64DetectIncompleteChar(buffer) {\n  this.charReceived = buffer.length % 3;\n  this.charLength = this.charReceived ? 3 : 0;\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nmodule.exports = Readable;\n\n/*<replacement>*/\nvar isArray = require('isarray');\n/*</replacement>*/\n\n\n/*<replacement>*/\nvar Buffer = require('buffer').Buffer;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n\nvar EE = require('events').EventEmitter;\n\n/*<replacement>*/\nif (!EE.listenerCount) EE.listenerCount = function(emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\nvar Stream = require('stream');\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nvar StringDecoder;\n\nutil.inherits(Readable, Stream);\n\nfunction ReadableState(options, stream) {\n  options = options || {};\n\n  // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n  var hwm = options.highWaterMark;\n  this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;\n\n  // cast to ints.\n  this.highWaterMark = ~~this.highWaterMark;\n\n  this.buffer = [];\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = false;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false;\n\n  // In streams that never have any data, and do push(null) right away,\n  // the consumer can miss the 'end' event if they do some I/O before\n  // consuming the stream.  So, we don't emit('end') until some reading\n  // happens.\n  this.calledRead = false;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, becuase any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n\n\n  // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n  this.objectMode = !!options.objectMode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // when piping, we only care about 'readable' events that happen\n  // after read()ing all the bytes and not getting any pushback.\n  this.ranOut = false;\n\n  // the number of writers that are awaiting a drain event in .pipe()s\n  this.awaitDrain = 0;\n\n  // if true, a maybeReadMore has been scheduled\n  this.readingMore = false;\n\n  this.decoder = null;\n  this.encoding = null;\n  if (options.encoding) {\n    if (!StringDecoder)\n      StringDecoder = require('string_decoder/').StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\nfunction Readable(options) {\n  if (!(this instanceof Readable))\n    return new Readable(options);\n\n  this._readableState = new ReadableState(options, this);\n\n  // legacy\n  this.readable = true;\n\n  Stream.call(this);\n}\n\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function(chunk, encoding) {\n  var state = this._readableState;\n\n  if (typeof chunk === 'string' && !state.objectMode) {\n    encoding = encoding || state.defaultEncoding;\n    if (encoding !== state.encoding) {\n      chunk = new Buffer(chunk, encoding);\n      encoding = '';\n    }\n  }\n\n  return readableAddChunk(this, state, chunk, encoding, false);\n};\n\n// Unshift should *always* be something directly out of read()\nReadable.prototype.unshift = function(chunk) {\n  var state = this._readableState;\n  return readableAddChunk(this, state, chunk, '', true);\n};\n\nfunction readableAddChunk(stream, state, chunk, encoding, addToFront) {\n  var er = chunkInvalid(state, chunk);\n  if (er) {\n    stream.emit('error', er);\n  } else if (chunk === null || chunk === undefined) {\n    state.reading = false;\n    if (!state.ended)\n      onEofChunk(stream, state);\n  } else if (state.objectMode || chunk && chunk.length > 0) {\n    if (state.ended && !addToFront) {\n      var e = new Error('stream.push() after EOF');\n      stream.emit('error', e);\n    } else if (state.endEmitted && addToFront) {\n      var e = new Error('stream.unshift() after end event');\n      stream.emit('error', e);\n    } else {\n      if (state.decoder && !addToFront && !encoding)\n        chunk = state.decoder.write(chunk);\n\n      // update the buffer info.\n      state.length += state.objectMode ? 1 : chunk.length;\n      if (addToFront) {\n        state.buffer.unshift(chunk);\n      } else {\n        state.reading = false;\n        state.buffer.push(chunk);\n      }\n\n      if (state.needReadable)\n        emitReadable(stream);\n\n      maybeReadMore(stream, state);\n    }\n  } else if (!addToFront) {\n    state.reading = false;\n  }\n\n  return needMoreData(state);\n}\n\n\n\n// if it's past the high water mark, we can push in some more.\n// Also, if we have no data yet, we can stand some\n// more bytes.  This is to work around cases where hwm=0,\n// such as the repl.  Also, if the push() triggered a\n// readable event, and the user called read(largeNumber) such that\n// needReadable was set, then we ought to push more, so that another\n// 'readable' event will be triggered.\nfunction needMoreData(state) {\n  return !state.ended &&\n         (state.needReadable ||\n          state.length < state.highWaterMark ||\n          state.length === 0);\n}\n\n// backwards compatibility.\nReadable.prototype.setEncoding = function(enc) {\n  if (!StringDecoder)\n    StringDecoder = require('string_decoder/').StringDecoder;\n  this._readableState.decoder = new StringDecoder(enc);\n  this._readableState.encoding = enc;\n};\n\n// Don't raise the hwm > 128MB\nvar MAX_HWM = 0x800000;\nfunction roundUpToNextPowerOf2(n) {\n  if (n >= MAX_HWM) {\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2\n    n--;\n    for (var p = 1; p < 32; p <<= 1) n |= n >> p;\n    n++;\n  }\n  return n;\n}\n\nfunction howMuchToRead(n, state) {\n  if (state.length === 0 && state.ended)\n    return 0;\n\n  if (state.objectMode)\n    return n === 0 ? 0 : 1;\n\n  if (n === null || isNaN(n)) {\n    // only flow one buffer at a time\n    if (state.flowing && state.buffer.length)\n      return state.buffer[0].length;\n    else\n      return state.length;\n  }\n\n  if (n <= 0)\n    return 0;\n\n  // If we're asking for more than the target buffer level,\n  // then raise the water mark.  Bump up to the next highest\n  // power of 2, to prevent increasing it excessively in tiny\n  // amounts.\n  if (n > state.highWaterMark)\n    state.highWaterMark = roundUpToNextPowerOf2(n);\n\n  // don't have that much.  return null, unless we've ended.\n  if (n > state.length) {\n    if (!state.ended) {\n      state.needReadable = true;\n      return 0;\n    } else\n      return state.length;\n  }\n\n  return n;\n}\n\n// you can override either this method, or the async _read(n) below.\nReadable.prototype.read = function(n) {\n  var state = this._readableState;\n  state.calledRead = true;\n  var nOrig = n;\n  var ret;\n\n  if (typeof n !== 'number' || n > 0)\n    state.emittedReadable = false;\n\n  // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n  if (n === 0 &&\n      state.needReadable &&\n      (state.length >= state.highWaterMark || state.ended)) {\n    emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n, state);\n\n  // if we've ended, and we're now clear, then finish it up.\n  if (n === 0 && state.ended) {\n    ret = null;\n\n    // In cases where the decoder did not receive enough data\n    // to produce a full chunk, then immediately received an\n    // EOF, state.buffer will contain [<Buffer >, <Buffer 00 ...>].\n    // howMuchToRead will see this and coerce the amount to\n    // read to zero (because it's looking at the length of the\n    // first <Buffer > in state.buffer), and we'll end up here.\n    //\n    // This can only happen via state.decoder -- no other venue\n    // exists for pushing a zero-length chunk into state.buffer\n    // and triggering this behavior. In this case, we return our\n    // remaining data and end the stream, if appropriate.\n    if (state.length > 0 && state.decoder) {\n      ret = fromList(n, state);\n      state.length -= ret.length;\n    }\n\n    if (state.length === 0)\n      endReadable(this);\n\n    return ret;\n  }\n\n  // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n\n  // if we need a readable event, then we need to do some reading.\n  var doRead = state.needReadable;\n\n  // if we currently have less than the highWaterMark, then also read some\n  if (state.length - n <= state.highWaterMark)\n    doRead = true;\n\n  // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n  if (state.ended || state.reading)\n    doRead = false;\n\n  if (doRead) {\n    state.reading = true;\n    state.sync = true;\n    // if the length is currently zero, then we *need* a readable event.\n    if (state.length === 0)\n      state.needReadable = true;\n    // call internal read method\n    this._read(state.highWaterMark);\n    state.sync = false;\n  }\n\n  // If _read called its callback synchronously, then `reading`\n  // will be false, and we need to re-evaluate how much data we\n  // can return to the user.\n  if (doRead && !state.reading)\n    n = howMuchToRead(nOrig, state);\n\n  if (n > 0)\n    ret = fromList(n, state);\n  else\n    ret = null;\n\n  if (ret === null) {\n    state.needReadable = true;\n    n = 0;\n  }\n\n  state.length -= n;\n\n  // If we have nothing in the buffer, then we want to know\n  // as soon as we *do* get something into the buffer.\n  if (state.length === 0 && !state.ended)\n    state.needReadable = true;\n\n  // If we happened to read() exactly the remaining amount in the\n  // buffer, and the EOF has been seen at this point, then make sure\n  // that we emit 'end' on the very next tick.\n  if (state.ended && !state.endEmitted && state.length === 0)\n    endReadable(this);\n\n  return ret;\n};\n\nfunction chunkInvalid(state, chunk) {\n  var er = null;\n  if (!Buffer.isBuffer(chunk) &&\n      'string' !== typeof chunk &&\n      chunk !== null &&\n      chunk !== undefined &&\n      !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  return er;\n}\n\n\nfunction onEofChunk(stream, state) {\n  if (state.decoder && !state.ended) {\n    var chunk = state.decoder.end();\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n  state.ended = true;\n\n  // if we've ended and we have some data left, then emit\n  // 'readable' now to make sure it gets picked up.\n  if (state.length > 0)\n    emitReadable(stream);\n  else\n    endReadable(stream);\n}\n\n// Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  state.needReadable = false;\n  if (state.emittedReadable)\n    return;\n\n  state.emittedReadable = true;\n  if (state.sync)\n    process.nextTick(function() {\n      emitReadable_(stream);\n    });\n  else\n    emitReadable_(stream);\n}\n\nfunction emitReadable_(stream) {\n  stream.emit('readable');\n}\n\n\n// at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    process.nextTick(function() {\n      maybeReadMore_(stream, state);\n    });\n  }\n}\n\nfunction maybeReadMore_(stream, state) {\n  var len = state.length;\n  while (!state.reading && !state.flowing && !state.ended &&\n         state.length < state.highWaterMark) {\n    stream.read(0);\n    if (len === state.length)\n      // didn't get any data, stop spinning.\n      break;\n    else\n      len = state.length;\n  }\n  state.readingMore = false;\n}\n\n// abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\nReadable.prototype._read = function(n) {\n  this.emit('error', new Error('not implemented'));\n};\n\nReadable.prototype.pipe = function(dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n  state.pipesCount += 1;\n\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&\n              dest !== process.stdout &&\n              dest !== process.stderr;\n\n  var endFn = doEnd ? onend : cleanup;\n  if (state.endEmitted)\n    process.nextTick(endFn);\n  else\n    src.once('end', endFn);\n\n  dest.on('unpipe', onunpipe);\n  function onunpipe(readable) {\n    if (readable !== src) return;\n    cleanup();\n  }\n\n  function onend() {\n    dest.end();\n  }\n\n  // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n\n  function cleanup() {\n    // cleanup event handlers once the pipe is broken\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', cleanup);\n\n    // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n    if (!dest._writableState || dest._writableState.needDrain)\n      ondrain();\n  }\n\n  // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n  function onerror(er) {\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EE.listenerCount(dest, 'error') === 0)\n      dest.emit('error', er);\n  }\n  // This is a brutally ugly hack to make sure that our error handler\n  // is attached before any userland ones.  NEVER DO THIS.\n  if (!dest._events || !dest._events.error)\n    dest.on('error', onerror);\n  else if (isArray(dest._events.error))\n    dest._events.error.unshift(onerror);\n  else\n    dest._events.error = [onerror, dest._events.error];\n\n\n\n  // Both close and finish should trigger unpipe, but only once.\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n  dest.once('close', onclose);\n  function onfinish() {\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n  dest.once('finish', onfinish);\n\n  function unpipe() {\n    src.unpipe(dest);\n  }\n\n  // tell the dest that it's being piped to\n  dest.emit('pipe', src);\n\n  // start the flow if it hasn't been started already.\n  if (!state.flowing) {\n    // the handler that waits for readable events after all\n    // the data gets sucked out in flow.\n    // This would be easier to follow with a .once() handler\n    // in flow(), but that is too slow.\n    this.on('readable', pipeOnReadable);\n\n    state.flowing = true;\n    process.nextTick(function() {\n      flow(src);\n    });\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src) {\n  return function() {\n    var dest = this;\n    var state = src._readableState;\n    state.awaitDrain--;\n    if (state.awaitDrain === 0)\n      flow(src);\n  };\n}\n\nfunction flow(src) {\n  var state = src._readableState;\n  var chunk;\n  state.awaitDrain = 0;\n\n  function write(dest, i, list) {\n    var written = dest.write(chunk);\n    if (false === written) {\n      state.awaitDrain++;\n    }\n  }\n\n  while (state.pipesCount && null !== (chunk = src.read())) {\n\n    if (state.pipesCount === 1)\n      write(state.pipes, 0, null);\n    else\n      forEach(state.pipes, write);\n\n    src.emit('data', chunk);\n\n    // if anyone needs a drain, then we have to wait for that.\n    if (state.awaitDrain > 0)\n      return;\n  }\n\n  // if every destination was unpiped, either before entering this\n  // function, or in the while loop, then stop flowing.\n  //\n  // NB: This is a pretty rare edge case.\n  if (state.pipesCount === 0) {\n    state.flowing = false;\n\n    // if there were data event listeners added, then switch to old mode.\n    if (EE.listenerCount(src, 'data') > 0)\n      emitDataEvents(src);\n    return;\n  }\n\n  // at this point, no one needed a drain, so we just ran out of data\n  // on the next readable event, start it over again.\n  state.ranOut = true;\n}\n\nfunction pipeOnReadable() {\n  if (this._readableState.ranOut) {\n    this._readableState.ranOut = false;\n    flow(this);\n  }\n}\n\n\nReadable.prototype.unpipe = function(dest) {\n  var state = this._readableState;\n\n  // if we're not piping anywhere, then do nothing.\n  if (state.pipesCount === 0)\n    return this;\n\n  // just one destination.  most common case.\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes)\n      return this;\n\n    if (!dest)\n      dest = state.pipes;\n\n    // got a match.\n    state.pipes = null;\n    state.pipesCount = 0;\n    this.removeListener('readable', pipeOnReadable);\n    state.flowing = false;\n    if (dest)\n      dest.emit('unpipe', this);\n    return this;\n  }\n\n  // slow case. multiple pipe destinations.\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    this.removeListener('readable', pipeOnReadable);\n    state.flowing = false;\n\n    for (var i = 0; i < len; i++)\n      dests[i].emit('unpipe', this);\n    return this;\n  }\n\n  // try to find the right one.\n  var i = indexOf(state.pipes, dest);\n  if (i === -1)\n    return this;\n\n  state.pipes.splice(i, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1)\n    state.pipes = state.pipes[0];\n\n  dest.emit('unpipe', this);\n\n  return this;\n};\n\n// set up data events if they are asked for\n// Ensure readable listeners eventually get something\nReadable.prototype.on = function(ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n\n  if (ev === 'data' && !this._readableState.flowing)\n    emitDataEvents(this);\n\n  if (ev === 'readable' && this.readable) {\n    var state = this._readableState;\n    if (!state.readableListening) {\n      state.readableListening = true;\n      state.emittedReadable = false;\n      state.needReadable = true;\n      if (!state.reading) {\n        this.read(0);\n      } else if (state.length) {\n        emitReadable(this, state);\n      }\n    }\n  }\n\n  return res;\n};\nReadable.prototype.addListener = Readable.prototype.on;\n\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\nReadable.prototype.resume = function() {\n  emitDataEvents(this);\n  this.read(0);\n  this.emit('resume');\n};\n\nReadable.prototype.pause = function() {\n  emitDataEvents(this, true);\n  this.emit('pause');\n};\n\nfunction emitDataEvents(stream, startPaused) {\n  var state = stream._readableState;\n\n  if (state.flowing) {\n    // https://github.com/isaacs/readable-stream/issues/16\n    throw new Error('Cannot switch to old mode now.');\n  }\n\n  var paused = startPaused || false;\n  var readable = false;\n\n  // convert to an old-style stream.\n  stream.readable = true;\n  stream.pipe = Stream.prototype.pipe;\n  stream.on = stream.addListener = Stream.prototype.on;\n\n  stream.on('readable', function() {\n    readable = true;\n\n    var c;\n    while (!paused && (null !== (c = stream.read())))\n      stream.emit('data', c);\n\n    if (c === null) {\n      readable = false;\n      stream._readableState.needReadable = true;\n    }\n  });\n\n  stream.pause = function() {\n    paused = true;\n    this.emit('pause');\n  };\n\n  stream.resume = function() {\n    paused = false;\n    if (readable)\n      process.nextTick(function() {\n        stream.emit('readable');\n      });\n    else\n      this.read(0);\n    this.emit('resume');\n  };\n\n  // now make it start, just in case it hadn't already.\n  stream.emit('readable');\n}\n\n// wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function(stream) {\n  var state = this._readableState;\n  var paused = false;\n\n  var self = this;\n  stream.on('end', function() {\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length)\n        self.push(chunk);\n    }\n\n    self.push(null);\n  });\n\n  stream.on('data', function(chunk) {\n    if (state.decoder)\n      chunk = state.decoder.write(chunk);\n\n    // don't skip over falsy values in objectMode\n    //if (state.objectMode && util.isNullOrUndefined(chunk))\n    if (state.objectMode && (chunk === null || chunk === undefined))\n      return;\n    else if (!state.objectMode && (!chunk || !chunk.length))\n      return;\n\n    var ret = self.push(chunk);\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  });\n\n  // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n  for (var i in stream) {\n    if (typeof stream[i] === 'function' &&\n        typeof this[i] === 'undefined') {\n      this[i] = function(method) { return function() {\n        return stream[method].apply(stream, arguments);\n      }}(i);\n    }\n  }\n\n  // proxy certain important events.\n  var events = ['error', 'close', 'destroy', 'pause', 'resume'];\n  forEach(events, function(ev) {\n    stream.on(ev, self.emit.bind(self, ev));\n  });\n\n  // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n  self._read = function(n) {\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  return self;\n};\n\n\n\n// exposed for testing purposes only.\nReadable._fromList = fromList;\n\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\nfunction fromList(n, state) {\n  var list = state.buffer;\n  var length = state.length;\n  var stringMode = !!state.decoder;\n  var objectMode = !!state.objectMode;\n  var ret;\n\n  // nothing in the list, definitely empty.\n  if (list.length === 0)\n    return null;\n\n  if (length === 0)\n    ret = null;\n  else if (objectMode)\n    ret = list.shift();\n  else if (!n || n >= length) {\n    // read it all, truncate the array.\n    if (stringMode)\n      ret = list.join('');\n    else\n      ret = Buffer.concat(list, length);\n    list.length = 0;\n  } else {\n    // read just some of it.\n    if (n < list[0].length) {\n      // just take a part of the first list item.\n      // slice is the same for buffers and strings.\n      var buf = list[0];\n      ret = buf.slice(0, n);\n      list[0] = buf.slice(n);\n    } else if (n === list[0].length) {\n      // first list is a perfect match\n      ret = list.shift();\n    } else {\n      // complex case.\n      // we have enough to cover it, but it spans past the first buffer.\n      if (stringMode)\n        ret = '';\n      else\n        ret = new Buffer(n);\n\n      var c = 0;\n      for (var i = 0, l = list.length; i < l && c < n; i++) {\n        var buf = list[0];\n        var cpy = Math.min(n - c, buf.length);\n\n        if (stringMode)\n          ret += buf.slice(0, cpy);\n        else\n          buf.copy(ret, c, 0, cpy);\n\n        if (cpy < buf.length)\n          list[0] = buf.slice(cpy);\n        else\n          list.shift();\n\n        c += cpy;\n      }\n    }\n  }\n\n  return ret;\n}\n\nfunction endReadable(stream) {\n  var state = stream._readableState;\n\n  // If we get here before consuming all the bytes, then that is a\n  // bug in node.  Should never happen.\n  if (state.length > 0)\n    throw new Error('endReadable called on non-empty stream');\n\n  if (!state.endEmitted && state.calledRead) {\n    state.ended = true;\n    process.nextTick(function() {\n      // Check that we didn't get one last unshift.\n      if (!state.endEmitted && state.length === 0) {\n        state.endEmitted = true;\n        stream.readable = false;\n        stream.emit('end');\n      }\n    });\n  }\n}\n\nfunction forEach (xs, f) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    f(xs[i], i);\n  }\n}\n\nfunction indexOf (xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n  return -1;\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\n\nmodule.exports = Duplex;\n\n/*<replacement>*/\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) keys.push(key);\n  return keys;\n}\n/*</replacement>*/\n\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nvar Readable = require('./_stream_readable');\nvar Writable = require('./_stream_writable');\n\nutil.inherits(Duplex, Readable);\n\nforEach(objectKeys(Writable.prototype), function(method) {\n  if (!Duplex.prototype[method])\n    Duplex.prototype[method] = Writable.prototype[method];\n});\n\nfunction Duplex(options) {\n  if (!(this instanceof Duplex))\n    return new Duplex(options);\n\n  Readable.call(this, options);\n  Writable.call(this, options);\n\n  if (options && options.readable === false)\n    this.readable = false;\n\n  if (options && options.writable === false)\n    this.writable = false;\n\n  this.allowHalfOpen = true;\n  if (options && options.allowHalfOpen === false)\n    this.allowHalfOpen = false;\n\n  this.once('end', onend);\n}\n\n// the no-half-open enforcer\nfunction onend() {\n  // if we allow half-open state, or if the writable side ended,\n  // then we're ok.\n  if (this.allowHalfOpen || this._writableState.ended)\n    return;\n\n  // no more data can be written.\n  // But allow more writes to happen in this tick.\n  process.nextTick(this.end.bind(this));\n}\n\nfunction forEach (xs, f) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    f(xs[i], i);\n  }\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, cb), and it'll handle all\n// the drain event emission and buffering.\n\nmodule.exports = Writable;\n\n/*<replacement>*/\nvar Buffer = require('buffer').Buffer;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nvar Stream = require('stream');\n\nutil.inherits(Writable, Stream);\n\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n}\n\nfunction WritableState(options, stream) {\n  options = options || {};\n\n  // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n  var hwm = options.highWaterMark;\n  this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;\n\n  // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  this.objectMode = !!options.objectMode;\n\n  // cast to ints.\n  this.highWaterMark = ~~this.highWaterMark;\n\n  this.needDrain = false;\n  // at the start of calling end()\n  this.ending = false;\n  // when end() has been called, and returned\n  this.ended = false;\n  // when 'finish' is emitted\n  this.finished = false;\n\n  // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0;\n\n  // a flag to see when we're in the middle of a write.\n  this.writing = false;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, becuase any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n  this.bufferProcessing = false;\n\n  // the callback that's passed to _write(chunk,cb)\n  this.onwrite = function(er) {\n    onwrite(stream, er);\n  };\n\n  // the callback that the user supplies to write(chunk,encoding,cb)\n  this.writecb = null;\n\n  // the amount that is being written when _write is called.\n  this.writelen = 0;\n\n  this.buffer = [];\n\n  // True if the error was already emitted and should not be thrown again\n  this.errorEmitted = false;\n}\n\nfunction Writable(options) {\n  var Duplex = require('./_stream_duplex');\n\n  // Writable ctor is applied to Duplexes, though they're not\n  // instanceof Writable, they're instanceof Readable.\n  if (!(this instanceof Writable) && !(this instanceof Duplex))\n    return new Writable(options);\n\n  this._writableState = new WritableState(options, this);\n\n  // legacy.\n  this.writable = true;\n\n  Stream.call(this);\n}\n\n// Otherwise people can pipe Writable streams, which is just wrong.\nWritable.prototype.pipe = function() {\n  this.emit('error', new Error('Cannot pipe. Not readable.'));\n};\n\n\nfunction writeAfterEnd(stream, state, cb) {\n  var er = new Error('write after end');\n  // TODO: defer error events consistently everywhere, not just the cb\n  stream.emit('error', er);\n  process.nextTick(function() {\n    cb(er);\n  });\n}\n\n// If we get something that is not a buffer, string, null, or undefined,\n// and we're not in objectMode, then that's an error.\n// Otherwise stream chunks are all considered to be of length=1, and the\n// watermarks determine how many objects to keep in the buffer, rather than\n// how many bytes or characters.\nfunction validChunk(stream, state, chunk, cb) {\n  var valid = true;\n  if (!Buffer.isBuffer(chunk) &&\n      'string' !== typeof chunk &&\n      chunk !== null &&\n      chunk !== undefined &&\n      !state.objectMode) {\n    var er = new TypeError('Invalid non-string/buffer chunk');\n    stream.emit('error', er);\n    process.nextTick(function() {\n      cb(er);\n    });\n    valid = false;\n  }\n  return valid;\n}\n\nWritable.prototype.write = function(chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (Buffer.isBuffer(chunk))\n    encoding = 'buffer';\n  else if (!encoding)\n    encoding = state.defaultEncoding;\n\n  if (typeof cb !== 'function')\n    cb = function() {};\n\n  if (state.ended)\n    writeAfterEnd(this, state, cb);\n  else if (validChunk(this, state, chunk, cb))\n    ret = writeOrBuffer(this, state, chunk, encoding, cb);\n\n  return ret;\n};\n\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode &&\n      state.decodeStrings !== false &&\n      typeof chunk === 'string') {\n    chunk = new Buffer(chunk, encoding);\n  }\n  return chunk;\n}\n\n// if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction writeOrBuffer(stream, state, chunk, encoding, cb) {\n  chunk = decodeChunk(state, chunk, encoding);\n  if (Buffer.isBuffer(chunk))\n    encoding = 'buffer';\n  var len = state.objectMode ? 1 : chunk.length;\n\n  state.length += len;\n\n  var ret = state.length < state.highWaterMark;\n  // we must ensure that previous needDrain will not be reset to false.\n  if (!ret)\n    state.needDrain = true;\n\n  if (state.writing)\n    state.buffer.push(new WriteReq(chunk, encoding, cb));\n  else\n    doWrite(stream, state, len, chunk, encoding, cb);\n\n  return ret;\n}\n\nfunction doWrite(stream, state, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream, state, sync, er, cb) {\n  if (sync)\n    process.nextTick(function() {\n      cb(er);\n    });\n  else\n    cb(er);\n\n  stream._writableState.errorEmitted = true;\n  stream.emit('error', er);\n}\n\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n\n  onwriteStateUpdate(state);\n\n  if (er)\n    onwriteError(stream, state, sync, er, cb);\n  else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(stream, state);\n\n    if (!finished && !state.bufferProcessing && state.buffer.length)\n      clearBuffer(stream, state);\n\n    if (sync) {\n      process.nextTick(function() {\n        afterWrite(stream, state, finished, cb);\n      });\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\n\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished)\n    onwriteDrain(stream, state);\n  cb();\n  if (finished)\n    finishMaybe(stream, state);\n}\n\n// Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n}\n\n\n// if there's something in the buffer waiting, then process it\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n\n  for (var c = 0; c < state.buffer.length; c++) {\n    var entry = state.buffer[c];\n    var chunk = entry.chunk;\n    var encoding = entry.encoding;\n    var cb = entry.callback;\n    var len = state.objectMode ? 1 : chunk.length;\n\n    doWrite(stream, state, len, chunk, encoding, cb);\n\n    // if we didn't call the onwrite immediately, then\n    // it means that we need to wait until it does.\n    // also, that means that the chunk and cb are currently\n    // being processed, so move the buffer counter past them.\n    if (state.writing) {\n      c++;\n      break;\n    }\n  }\n\n  state.bufferProcessing = false;\n  if (c < state.buffer.length)\n    state.buffer = state.buffer.slice(c);\n  else\n    state.buffer.length = 0;\n}\n\nWritable.prototype._write = function(chunk, encoding, cb) {\n  cb(new Error('not implemented'));\n};\n\nWritable.prototype.end = function(chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (typeof chunk !== 'undefined' && chunk !== null)\n    this.write(chunk, encoding);\n\n  // ignore unnecessary end() calls.\n  if (!state.ending && !state.finished)\n    endWritable(this, state, cb);\n};\n\n\nfunction needFinish(stream, state) {\n  return (state.ending &&\n          state.length === 0 &&\n          !state.finished &&\n          !state.writing);\n}\n\nfunction finishMaybe(stream, state) {\n  var need = needFinish(stream, state);\n  if (need) {\n    state.finished = true;\n    stream.emit('finish');\n  }\n  return need;\n}\n\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n  if (cb) {\n    if (state.finished)\n      process.nextTick(cb);\n    else\n      stream.once('finish', cb);\n  }\n  state.ended = true;\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\nmodule.exports = Transform;\n\nvar Duplex = require('./_stream_duplex');\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nutil.inherits(Transform, Duplex);\n\n\nfunction TransformState(options, stream) {\n  this.afterTransform = function(er, data) {\n    return afterTransform(stream, er, data);\n  };\n\n  this.needTransform = false;\n  this.transforming = false;\n  this.writecb = null;\n  this.writechunk = null;\n}\n\nfunction afterTransform(stream, er, data) {\n  var ts = stream._transformState;\n  ts.transforming = false;\n\n  var cb = ts.writecb;\n\n  if (!cb)\n    return stream.emit('error', new Error('no writecb in Transform class'));\n\n  ts.writechunk = null;\n  ts.writecb = null;\n\n  if (data !== null && data !== undefined)\n    stream.push(data);\n\n  if (cb)\n    cb(er);\n\n  var rs = stream._readableState;\n  rs.reading = false;\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    stream._read(rs.highWaterMark);\n  }\n}\n\n\nfunction Transform(options) {\n  if (!(this instanceof Transform))\n    return new Transform(options);\n\n  Duplex.call(this, options);\n\n  var ts = this._transformState = new TransformState(options, this);\n\n  // when the writable side finishes, then flush out anything remaining.\n  var stream = this;\n\n  // start out asking for a readable event once data is transformed.\n  this._readableState.needReadable = true;\n\n  // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n  this._readableState.sync = false;\n\n  this.once('finish', function() {\n    if ('function' === typeof this._flush)\n      this._flush(function(er) {\n        done(stream, er);\n      });\n    else\n      done(stream);\n  });\n}\n\nTransform.prototype.push = function(chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n};\n\n// This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\nTransform.prototype._transform = function(chunk, encoding, cb) {\n  throw new Error('not implemented');\n};\n\nTransform.prototype._write = function(chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform ||\n        rs.needReadable ||\n        rs.length < rs.highWaterMark)\n      this._read(rs.highWaterMark);\n  }\n};\n\n// Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\nTransform.prototype._read = function(n) {\n  var ts = this._transformState;\n\n  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {\n    ts.transforming = true;\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\n\n\nfunction done(stream, er) {\n  if (er)\n    return stream.emit('error', er);\n\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n  var ws = stream._writableState;\n  var rs = stream._readableState;\n  var ts = stream._transformState;\n\n  if (ws.length)\n    throw new Error('calling transform done when ws.length != 0');\n\n  if (ts.transforming)\n    throw new Error('calling transform done when still transforming');\n\n  return stream.push(null);\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\n\nmodule.exports = PassThrough;\n\nvar Transform = require('./_stream_transform');\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nutil.inherits(PassThrough, Transform);\n\nfunction PassThrough(options) {\n  if (!(this instanceof PassThrough))\n    return new PassThrough(options);\n\n  Transform.call(this, options);\n}\n\nPassThrough.prototype._transform = function(chunk, encoding, cb) {\n  cb(null, chunk);\n};\n","var Stream = require('stream'); // hack to fix a circular dependency issue when used with browserify\nexports = module.exports = require('./lib/_stream_readable.js');\nexports.Stream = Stream;\nexports.Readable = exports;\nexports.Writable = require('./lib/_stream_writable.js');\nexports.Duplex = require('./lib/_stream_duplex.js');\nexports.Transform = require('./lib/_stream_transform.js');\nexports.PassThrough = require('./lib/_stream_passthrough.js');\nif (!process.browser && process.env.READABLE_STREAM === 'disable') {\n  module.exports = require('stream');\n}\n","var bufferFrom = require('buffer-from')\nvar Transform = require('readable-stream').Transform;\nvar inherits = require('inherits');\n\ninherits(Tokenize, Transform);\nmodule.exports = Tokenize;\n\nvar codes = {\n    lt: '<'.charCodeAt(0),\n    gt: '>'.charCodeAt(0),\n    slash: '/'.charCodeAt(0),\n    dquote: '\"'.charCodeAt(0),\n    squote: \"'\".charCodeAt(0),\n    equal: '='.charCodeAt(0)\n};\n\nvar strings = {\n    endScript: bufferFrom('</script'),\n    endStyle: bufferFrom('</style'),\n    endTitle: bufferFrom('</title'),\n    comment: bufferFrom('<!--'),\n    endComment: bufferFrom('-->'),\n    cdata: bufferFrom('<![CDATA['),\n    endCdata: bufferFrom(']]>')\n};\n\nvar states = {\n    'TagNameState': 1,\n    'AttributeNameState': 2,\n    'BeforeAttributeValueState': 3,\n    'AttributeValueState':4\n}\n\nfunction Tokenize () {\n    if (!(this instanceof Tokenize)) return new Tokenize;\n    Transform.call(this);\n    this._readableState.objectMode = true;\n    this.state = 'text';\n    this.tagState = null;\n    this.quoteState = null;\n    this.raw = null;\n    this.buffers = [];\n    this._last = [];\n}\n\nTokenize.prototype._transform = function (buf, enc, next) {\n    var i = 0;\n    var offset = 0;\n    \n    if (this._prev) {\n        buf = Buffer.concat([ this._prev, buf ]);\n        i = this._prev.length - 1;\n        offset = this._offset;\n        this._prev = null;\n        this._offset = 0;\n    }\n    \n    for (; i < buf.length; i++) {\n        var b = buf[i];\n        this._last.push(b);\n        if (this._last.length > 9) this._last.shift();\n        // detect end of raw character mode (comment, script,..)\n        if (this.raw) {\n            var parts = this._testRaw(buf, offset, i);\n            if (parts) {\n                this.push([ 'text', parts[0] ]);\n                \n                if (this.raw === strings.endComment\n                || this.raw === strings.endCdata) {\n                    this.state = 'text';\n                    this.buffers = [];\n                    this.push([ 'close', parts[1] ]);\n                }\n                else {\n                    this.state = 'open';\n                    this.buffers = [ parts[1] ];\n                }\n                \n                this.raw = null;\n                offset = i + 1;\n            }\n        }\n        // ask for more data if last byte is '<' \n        else if (this.state === 'text' && b === codes.lt\n        && i === buf.length - 1) {\n            this._prev = buf;\n            this._offset = offset;\n            return next();\n        }\n        // detect a tag opening\n        else if (this.state === 'text' && b === codes.lt\n        && !isWhiteSpace(buf[i+1])) {\n            if (i > 0 && i - offset > 0) {\n                this.buffers.push(buf.slice(offset, i));\n            }\n            offset = i;\n            this.state = 'open';\n            this.tagState = states.TagNameState;\n            this._pushState('text');\n        }\n        else if (\n            this.tagState === states.TagNameState &&\n            isWhiteSpace(b)\n        ) {\n            this.tagState = states.AttributeNameState\n        }\n        else if (\n            this.tagState === states.AttributeNameState &&\n            b === codes.equal\n        ) {\n            this.tagState = states.BeforeAttributeValueState\n        }\n        else if (\n            this.tagState === states.BeforeAttributeValueState &&\n            isWhiteSpace(b)\n        ) {}\n        else if (\n            this.tagState === states.BeforeAttributeValueState\n            && b !== codes.gt\n        ) {\n            this.tagState = states.AttributeValueState;\n            if (b === codes.dquote) {\n                this.quoteState = 'double';\n            } else if (b === codes.squote) {\n                this.quoteState = 'single';\n            } else {\n                this.quoteState = null;\n            }\n        }\n        else if (\n            this.tagState === states.AttributeValueState &&\n            !this.quoteState &&\n            isWhiteSpace(b)\n        ) {\n            this.tagState = states.AttributeNameState;\n        }\n        else if (\n            this.tagState === states.AttributeValueState &&\n            this.quoteState === 'double' &&\n            b === codes.dquote\n        ) {\n            this.quoteState = null;\n            this.tagState = states.AttributeNameState;\n        }\n        else if (\n            this.tagState === states.AttributeValueState &&\n            this.quoteState === 'single' &&\n            b === codes.squote\n        ) {\n            this.quoteState = null;\n            this.tagState = states.AttributeNameState;\n        }\n        else if (this.state === 'open' && b === codes.gt && !this.quoteState) {\n            this.buffers.push(buf.slice(offset, i + 1));\n            offset = i + 1;\n            this.state = 'text';\n            this.tagState = null;\n            if (this._getChar(1) === codes.slash) {\n                this._pushState('close');\n            }\n            else {\n                var tag = this._getTag();\n                if (tag === 'script') this.raw = strings.endScript;\n                if (tag === 'style') this.raw = strings.endStyle;\n                if (tag === 'title') this.raw = strings.endTitle;\n                this._pushState('open');\n            }\n        }\n        else if (this.state === 'open' && compare(this._last, strings.comment)) {\n            this.buffers.push(buf.slice(offset, i + 1));\n            offset = i + 1;\n            this.state = 'text';\n            this.raw = strings.endComment;\n            this._pushState('open');\n        }\n        else if (this.state === 'open' && compare(this._last, strings.cdata)) {\n            this.buffers.push(buf.slice(offset, i + 1));\n            offset = i + 1;\n            this.state = 'text';\n            this.raw = strings.endCdata;\n            this._pushState('open');\n        }\n    }\n    if (offset < buf.length) this.buffers.push(buf.slice(offset));\n    next();\n};\n\nTokenize.prototype._flush = function (next) {\n    if (this.state === 'text') this._pushState('text');\n    this.push(null);\n    next();\n};\n\nTokenize.prototype._pushState = function (ev) {\n    if (this.buffers.length === 0) return;\n    var buf = Buffer.concat(this.buffers);\n    this.buffers = [];\n    this.push([ ev, buf ]);\n};\n\nTokenize.prototype._getChar = function (i) {\n    var offset = 0;\n    for (var j = 0; j < this.buffers.length; j++) {\n        var buf = this.buffers[j];\n        if (offset + buf.length > i) {\n            return buf[i - offset];\n        }\n        offset += buf;\n    }\n};\n\nTokenize.prototype._getTag = function () {\n    var offset = 0;\n    var tag = '';\n    for (var j = 0; j < this.buffers.length; j++) {\n        var buf = this.buffers[j];\n        for (var k = 0; k < buf.length; k++) {\n            if (offset === 0 && k === 0) continue;\n            var c = String.fromCharCode(buf[k]);\n            if (/[^\\w-!\\[\\]]/.test(c)) {\n                return tag.toLowerCase();\n            }\n            else tag += c;\n        }\n        offset += buf.length;\n    }\n};\n\nTokenize.prototype._testRaw = function (buf, offset, index) {\n    var raw = this.raw, last = this._last;\n    if (!compare(last, raw)) return;\n    \n    this.buffers.push(buf.slice(offset, index + 1));\n    var buf = Buffer.concat(this.buffers);\n    var k = buf.length - raw.length;\n    return [ buf.slice(0, k), buf.slice(k) ];\n};\n\nfunction compare (a, b) {\n    if (a.length < b.length) return false;\n    for (var i=a.length-1, j=b.length-1; i >= 0 && j >= 0; i--, j--) {\n        if (lower(a[i]) !== lower(b[j])) return false;\n    }\n    return true;\n}\n\nfunction lower (n) {\n    if (n >= 65 && n <= 90) return n + 32;\n    return n;\n}\n\nfunction isWhiteSpace(b) {\n  return b === 0x20 || b === 0x09 || b === 0x0A || b === 0x0C || b === 0x0D;\n}\n","'use strict';\n\nif (typeof process === 'undefined' ||\n    !process.version ||\n    process.version.indexOf('v0.') === 0 ||\n    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {\n  module.exports = { nextTick: nextTick };\n} else {\n  module.exports = process\n}\n\nfunction nextTick(fn, arg1, arg2, arg3) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('\"callback\" argument must be a function');\n  }\n  var len = arguments.length;\n  var args, i;\n  switch (len) {\n  case 0:\n  case 1:\n    return process.nextTick(fn);\n  case 2:\n    return process.nextTick(function afterTickOne() {\n      fn.call(null, arg1);\n    });\n  case 3:\n    return process.nextTick(function afterTickTwo() {\n      fn.call(null, arg1, arg2);\n    });\n  case 4:\n    return process.nextTick(function afterTickThree() {\n      fn.call(null, arg1, arg2, arg3);\n    });\n  default:\n    args = new Array(len - 1);\n    i = 0;\n    while (i < args.length) {\n      args[i++] = arguments[i];\n    }\n    return process.nextTick(function afterTick() {\n      fn.apply(null, args);\n    });\n  }\n}\n\n","var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n","module.exports = require('events').EventEmitter;\n","/* eslint-disable node/no-deprecated-api */\nvar buffer = require('buffer')\nvar Buffer = buffer.Buffer\n\n// alternative to using Object.keys for old browsers\nfunction copyProps (src, dst) {\n  for (var key in src) {\n    dst[key] = src[key]\n  }\n}\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n  module.exports = buffer\n} else {\n  // Copy properties from require('buffer')\n  copyProps(buffer, exports)\n  exports.Buffer = SafeBuffer\n}\n\nfunction SafeBuffer (arg, encodingOrOffset, length) {\n  return Buffer(arg, encodingOrOffset, length)\n}\n\n// Copy static methods from Buffer\ncopyProps(Buffer, SafeBuffer)\n\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\n  if (typeof arg === 'number') {\n    throw new TypeError('Argument must not be a number')\n  }\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.alloc = function (size, fill, encoding) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  var buf = Buffer(size)\n  if (fill !== undefined) {\n    if (typeof encoding === 'string') {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n  } else {\n    buf.fill(0)\n  }\n  return buf\n}\n\nSafeBuffer.allocUnsafe = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return Buffer(size)\n}\n\nSafeBuffer.allocUnsafeSlow = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return buffer.SlowBuffer(size)\n}\n","'use strict';\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Buffer = require('safe-buffer').Buffer;\nvar util = require('util');\n\nfunction copyBuffer(src, target, offset) {\n  src.copy(target, offset);\n}\n\nmodule.exports = function () {\n  function BufferList() {\n    _classCallCheck(this, BufferList);\n\n    this.head = null;\n    this.tail = null;\n    this.length = 0;\n  }\n\n  BufferList.prototype.push = function push(v) {\n    var entry = { data: v, next: null };\n    if (this.length > 0) this.tail.next = entry;else this.head = entry;\n    this.tail = entry;\n    ++this.length;\n  };\n\n  BufferList.prototype.unshift = function unshift(v) {\n    var entry = { data: v, next: this.head };\n    if (this.length === 0) this.tail = entry;\n    this.head = entry;\n    ++this.length;\n  };\n\n  BufferList.prototype.shift = function shift() {\n    if (this.length === 0) return;\n    var ret = this.head.data;\n    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;\n    --this.length;\n    return ret;\n  };\n\n  BufferList.prototype.clear = function clear() {\n    this.head = this.tail = null;\n    this.length = 0;\n  };\n\n  BufferList.prototype.join = function join(s) {\n    if (this.length === 0) return '';\n    var p = this.head;\n    var ret = '' + p.data;\n    while (p = p.next) {\n      ret += s + p.data;\n    }return ret;\n  };\n\n  BufferList.prototype.concat = function concat(n) {\n    if (this.length === 0) return Buffer.alloc(0);\n    var ret = Buffer.allocUnsafe(n >>> 0);\n    var p = this.head;\n    var i = 0;\n    while (p) {\n      copyBuffer(p.data, ret, i);\n      i += p.data.length;\n      p = p.next;\n    }\n    return ret;\n  };\n\n  return BufferList;\n}();\n\nif (util && util.inspect && util.inspect.custom) {\n  module.exports.prototype[util.inspect.custom] = function () {\n    var obj = util.inspect({ length: this.length });\n    return this.constructor.name + ' ' + obj;\n  };\n}","'use strict';\n\n/*<replacement>*/\n\nvar pna = require('process-nextick-args');\n/*</replacement>*/\n\n// undocumented cb() API, needed for core, not for public API\nfunction destroy(err, cb) {\n  var _this = this;\n\n  var readableDestroyed = this._readableState && this._readableState.destroyed;\n  var writableDestroyed = this._writableState && this._writableState.destroyed;\n\n  if (readableDestroyed || writableDestroyed) {\n    if (cb) {\n      cb(err);\n    } else if (err) {\n      if (!this._writableState) {\n        pna.nextTick(emitErrorNT, this, err);\n      } else if (!this._writableState.errorEmitted) {\n        this._writableState.errorEmitted = true;\n        pna.nextTick(emitErrorNT, this, err);\n      }\n    }\n\n    return this;\n  }\n\n  // we set destroyed to true before firing error callbacks in order\n  // to make it re-entrance safe in case destroy() is called within callbacks\n\n  if (this._readableState) {\n    this._readableState.destroyed = true;\n  }\n\n  // if this is a duplex stream mark the writable part as destroyed as well\n  if (this._writableState) {\n    this._writableState.destroyed = true;\n  }\n\n  this._destroy(err || null, function (err) {\n    if (!cb && err) {\n      if (!_this._writableState) {\n        pna.nextTick(emitErrorNT, _this, err);\n      } else if (!_this._writableState.errorEmitted) {\n        _this._writableState.errorEmitted = true;\n        pna.nextTick(emitErrorNT, _this, err);\n      }\n    } else if (cb) {\n      cb(err);\n    }\n  });\n\n  return this;\n}\n\nfunction undestroy() {\n  if (this._readableState) {\n    this._readableState.destroyed = false;\n    this._readableState.reading = false;\n    this._readableState.ended = false;\n    this._readableState.endEmitted = false;\n  }\n\n  if (this._writableState) {\n    this._writableState.destroyed = false;\n    this._writableState.ended = false;\n    this._writableState.ending = false;\n    this._writableState.finalCalled = false;\n    this._writableState.prefinished = false;\n    this._writableState.finished = false;\n    this._writableState.errorEmitted = false;\n  }\n}\n\nfunction emitErrorNT(self, err) {\n  self.emit('error', err);\n}\n\nmodule.exports = {\n  destroy: destroy,\n  undestroy: undestroy\n};","\n/**\n * Module exports.\n */\n\nmodule.exports = deprecate;\n\n/**\n * Mark that a method should not be used.\n * Returns a modified function which warns once by default.\n *\n * If `localStorage.noDeprecation = true` is set, then it is a no-op.\n *\n * If `localStorage.throwDeprecation = true` is set, then deprecated functions\n * will throw an Error when invoked.\n *\n * If `localStorage.traceDeprecation = true` is set, then deprecated functions\n * will invoke `console.trace()` instead of `console.error()`.\n *\n * @param {Function} fn - the function to deprecate\n * @param {String} msg - the string to print to the console when `fn` is invoked\n * @returns {Function} a new \"deprecated\" version of `fn`\n * @api public\n */\n\nfunction deprecate (fn, msg) {\n  if (config('noDeprecation')) {\n    return fn;\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (config('throwDeprecation')) {\n        throw new Error(msg);\n      } else if (config('traceDeprecation')) {\n        console.trace(msg);\n      } else {\n        console.warn(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n}\n\n/**\n * Checks `localStorage` for boolean values for the given `name`.\n *\n * @param {String} name\n * @returns {Boolean}\n * @api private\n */\n\nfunction config (name) {\n  // accessing global.localStorage can trigger a DOMException in sandboxed iframes\n  try {\n    if (!global.localStorage) return false;\n  } catch (_) {\n    return false;\n  }\n  var val = global.localStorage[name];\n  if (null == val) return false;\n  return String(val).toLowerCase() === 'true';\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n// the drain event emission and buffering.\n\n'use strict';\n\n/*<replacement>*/\n\nvar pna = require('process-nextick-args');\n/*</replacement>*/\n\nmodule.exports = Writable;\n\n/* <replacement> */\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n  this.next = null;\n}\n\n// It seems a linked list but it is not\n// there will be only 2 of these for each stream\nfunction CorkedRequest(state) {\n  var _this = this;\n\n  this.next = null;\n  this.entry = null;\n  this.finish = function () {\n    onCorkedFinish(_this, state);\n  };\n}\n/* </replacement> */\n\n/*<replacement>*/\nvar asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;\n/*</replacement>*/\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n\n/*<replacement>*/\nvar util = Object.create(require('core-util-is'));\nutil.inherits = require('inherits');\n/*</replacement>*/\n\n/*<replacement>*/\nvar internalUtil = {\n  deprecate: require('util-deprecate')\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream = require('./internal/streams/stream');\n/*</replacement>*/\n\n/*<replacement>*/\n\nvar Buffer = require('safe-buffer').Buffer;\nvar OurUint8Array = (typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n\n/*</replacement>*/\n\nvar destroyImpl = require('./internal/streams/destroy');\n\nutil.inherits(Writable, Stream);\n\nfunction nop() {}\n\nfunction WritableState(options, stream) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  options = options || {};\n\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n  var isDuplex = stream instanceof Duplex;\n\n  // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  this.objectMode = !!options.objectMode;\n\n  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;\n\n  // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n  var hwm = options.highWaterMark;\n  var writableHwm = options.writableHighWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n\n  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = Math.floor(this.highWaterMark);\n\n  // if _final has been called\n  this.finalCalled = false;\n\n  // drain event flag.\n  this.needDrain = false;\n  // at the start of calling end()\n  this.ending = false;\n  // when end() has been called, and returned\n  this.ended = false;\n  // when 'finish' is emitted\n  this.finished = false;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0;\n\n  // a flag to see when we're in the middle of a write.\n  this.writing = false;\n\n  // when true all writes will be buffered until .uncork() call\n  this.corked = 0;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n  this.bufferProcessing = false;\n\n  // the callback that's passed to _write(chunk,cb)\n  this.onwrite = function (er) {\n    onwrite(stream, er);\n  };\n\n  // the callback that the user supplies to write(chunk,encoding,cb)\n  this.writecb = null;\n\n  // the amount that is being written when _write is called.\n  this.writelen = 0;\n\n  this.bufferedRequest = null;\n  this.lastBufferedRequest = null;\n\n  // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n  this.pendingcb = 0;\n\n  // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n  this.prefinished = false;\n\n  // True if the error was already emitted and should not be thrown again\n  this.errorEmitted = false;\n\n  // count buffered requests\n  this.bufferedRequestCount = 0;\n\n  // allocate the first CorkedRequest, there is always\n  // one allocated and free to use, and we maintain at most two\n  this.corkedRequestsFree = new CorkedRequest(this);\n}\n\nWritableState.prototype.getBuffer = function getBuffer() {\n  var current = this.bufferedRequest;\n  var out = [];\n  while (current) {\n    out.push(current);\n    current = current.next;\n  }\n  return out;\n};\n\n(function () {\n  try {\n    Object.defineProperty(WritableState.prototype, 'buffer', {\n      get: internalUtil.deprecate(function () {\n        return this.getBuffer();\n      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')\n    });\n  } catch (_) {}\n})();\n\n// Test _writableState for inheritance to account for Duplex streams,\n// whose prototype chain only points to Readable.\nvar realHasInstance;\nif (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {\n  realHasInstance = Function.prototype[Symbol.hasInstance];\n  Object.defineProperty(Writable, Symbol.hasInstance, {\n    value: function (object) {\n      if (realHasInstance.call(this, object)) return true;\n      if (this !== Writable) return false;\n\n      return object && object._writableState instanceof WritableState;\n    }\n  });\n} else {\n  realHasInstance = function (object) {\n    return object instanceof this;\n  };\n}\n\nfunction Writable(options) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  // Writable ctor is applied to Duplexes, too.\n  // `realHasInstance` is necessary because using plain `instanceof`\n  // would return false, as no `_writableState` property is attached.\n\n  // Trying to use the custom `instanceof` for Writable here will also break the\n  // Node.js LazyTransform implementation, which has a non-trivial getter for\n  // `_writableState` that would lead to infinite recursion.\n  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {\n    return new Writable(options);\n  }\n\n  this._writableState = new WritableState(options, this);\n\n  // legacy.\n  this.writable = true;\n\n  if (options) {\n    if (typeof options.write === 'function') this._write = options.write;\n\n    if (typeof options.writev === 'function') this._writev = options.writev;\n\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n\n    if (typeof options.final === 'function') this._final = options.final;\n  }\n\n  Stream.call(this);\n}\n\n// Otherwise people can pipe Writable streams, which is just wrong.\nWritable.prototype.pipe = function () {\n  this.emit('error', new Error('Cannot pipe, not readable'));\n};\n\nfunction writeAfterEnd(stream, cb) {\n  var er = new Error('write after end');\n  // TODO: defer error events consistently everywhere, not just the cb\n  stream.emit('error', er);\n  pna.nextTick(cb, er);\n}\n\n// Checks that a user-supplied chunk is valid, especially for the particular\n// mode the stream is in. Currently this means that `null` is never accepted\n// and undefined/non-string values are only allowed in object mode.\nfunction validChunk(stream, state, chunk, cb) {\n  var valid = true;\n  var er = false;\n\n  if (chunk === null) {\n    er = new TypeError('May not write null values to stream');\n  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  if (er) {\n    stream.emit('error', er);\n    pna.nextTick(cb, er);\n    valid = false;\n  }\n  return valid;\n}\n\nWritable.prototype.write = function (chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n  var isBuf = !state.objectMode && _isUint8Array(chunk);\n\n  if (isBuf && !Buffer.isBuffer(chunk)) {\n    chunk = _uint8ArrayToBuffer(chunk);\n  }\n\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\n\n  if (typeof cb !== 'function') cb = nop;\n\n  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);\n  }\n\n  return ret;\n};\n\nWritable.prototype.cork = function () {\n  var state = this._writableState;\n\n  state.corked++;\n};\n\nWritable.prototype.uncork = function () {\n  var state = this._writableState;\n\n  if (state.corked) {\n    state.corked--;\n\n    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\n  }\n};\n\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string') encoding = encoding.toLowerCase();\n  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);\n  this._writableState.defaultEncoding = encoding;\n  return this;\n};\n\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\n    chunk = Buffer.from(chunk, encoding);\n  }\n  return chunk;\n}\n\nObject.defineProperty(Writable.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function () {\n    return this._writableState.highWaterMark;\n  }\n});\n\n// if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {\n  if (!isBuf) {\n    var newChunk = decodeChunk(state, chunk, encoding);\n    if (chunk !== newChunk) {\n      isBuf = true;\n      encoding = 'buffer';\n      chunk = newChunk;\n    }\n  }\n  var len = state.objectMode ? 1 : chunk.length;\n\n  state.length += len;\n\n  var ret = state.length < state.highWaterMark;\n  // we must ensure that previous needDrain will not be reset to false.\n  if (!ret) state.needDrain = true;\n\n  if (state.writing || state.corked) {\n    var last = state.lastBufferedRequest;\n    state.lastBufferedRequest = {\n      chunk: chunk,\n      encoding: encoding,\n      isBuf: isBuf,\n      callback: cb,\n      next: null\n    };\n    if (last) {\n      last.next = state.lastBufferedRequest;\n    } else {\n      state.bufferedRequest = state.lastBufferedRequest;\n    }\n    state.bufferedRequestCount += 1;\n  } else {\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n  }\n\n  return ret;\n}\n\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream, state, sync, er, cb) {\n  --state.pendingcb;\n\n  if (sync) {\n    // defer the callback if we are being called synchronously\n    // to avoid piling up things on the stack\n    pna.nextTick(cb, er);\n    // this can emit finish, and it will always happen\n    // after error\n    pna.nextTick(finishMaybe, stream, state);\n    stream._writableState.errorEmitted = true;\n    stream.emit('error', er);\n  } else {\n    // the caller expect this to happen before if\n    // it is async\n    cb(er);\n    stream._writableState.errorEmitted = true;\n    stream.emit('error', er);\n    // this can emit finish, but finish must\n    // always follow error\n    finishMaybe(stream, state);\n  }\n}\n\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n\n  onwriteStateUpdate(state);\n\n  if (er) onwriteError(stream, state, sync, er, cb);else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(state);\n\n    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n      clearBuffer(stream, state);\n    }\n\n    if (sync) {\n      /*<replacement>*/\n      asyncWrite(afterWrite, stream, state, finished, cb);\n      /*</replacement>*/\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\n\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished) onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n}\n\n// Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n}\n\n// if there's something in the buffer waiting, then process it\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n  var entry = state.bufferedRequest;\n\n  if (stream._writev && entry && entry.next) {\n    // Fast case, write everything using _writev()\n    var l = state.bufferedRequestCount;\n    var buffer = new Array(l);\n    var holder = state.corkedRequestsFree;\n    holder.entry = entry;\n\n    var count = 0;\n    var allBuffers = true;\n    while (entry) {\n      buffer[count] = entry;\n      if (!entry.isBuf) allBuffers = false;\n      entry = entry.next;\n      count += 1;\n    }\n    buffer.allBuffers = allBuffers;\n\n    doWrite(stream, state, true, state.length, buffer, '', holder.finish);\n\n    // doWrite is almost always async, defer these to save a bit of time\n    // as the hot path ends with doWrite\n    state.pendingcb++;\n    state.lastBufferedRequest = null;\n    if (holder.next) {\n      state.corkedRequestsFree = holder.next;\n      holder.next = null;\n    } else {\n      state.corkedRequestsFree = new CorkedRequest(state);\n    }\n    state.bufferedRequestCount = 0;\n  } else {\n    // Slow case, write chunks one-by-one\n    while (entry) {\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n      entry = entry.next;\n      state.bufferedRequestCount--;\n      // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n      if (state.writing) {\n        break;\n      }\n    }\n\n    if (entry === null) state.lastBufferedRequest = null;\n  }\n\n  state.bufferedRequest = entry;\n  state.bufferProcessing = false;\n}\n\nWritable.prototype._write = function (chunk, encoding, cb) {\n  cb(new Error('_write() is not implemented'));\n};\n\nWritable.prototype._writev = null;\n\nWritable.prototype.end = function (chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);\n\n  // .end() fully uncorks\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  }\n\n  // ignore unnecessary end() calls.\n  if (!state.ending) endWritable(this, state, cb);\n};\n\nfunction needFinish(state) {\n  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\n}\nfunction callFinal(stream, state) {\n  stream._final(function (err) {\n    state.pendingcb--;\n    if (err) {\n      stream.emit('error', err);\n    }\n    state.prefinished = true;\n    stream.emit('prefinish');\n    finishMaybe(stream, state);\n  });\n}\nfunction prefinish(stream, state) {\n  if (!state.prefinished && !state.finalCalled) {\n    if (typeof stream._final === 'function') {\n      state.pendingcb++;\n      state.finalCalled = true;\n      pna.nextTick(callFinal, stream, state);\n    } else {\n      state.prefinished = true;\n      stream.emit('prefinish');\n    }\n  }\n}\n\nfunction finishMaybe(stream, state) {\n  var need = needFinish(state);\n  if (need) {\n    prefinish(stream, state);\n    if (state.pendingcb === 0) {\n      state.finished = true;\n      stream.emit('finish');\n    }\n  }\n  return need;\n}\n\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n  if (cb) {\n    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);\n  }\n  state.ended = true;\n  stream.writable = false;\n}\n\nfunction onCorkedFinish(corkReq, state, err) {\n  var entry = corkReq.entry;\n  corkReq.entry = null;\n  while (entry) {\n    var cb = entry.callback;\n    state.pendingcb--;\n    cb(err);\n    entry = entry.next;\n  }\n\n  // reuse the free corkReq.\n  state.corkedRequestsFree.next = corkReq;\n}\n\nObject.defineProperty(Writable.prototype, 'destroyed', {\n  get: function () {\n    if (this._writableState === undefined) {\n      return false;\n    }\n    return this._writableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._writableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._writableState.destroyed = value;\n  }\n});\n\nWritable.prototype.destroy = destroyImpl.destroy;\nWritable.prototype._undestroy = destroyImpl.undestroy;\nWritable.prototype._destroy = function (err, cb) {\n  this.end();\n  cb(err);\n};","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\n\n'use strict';\n\n/*<replacement>*/\n\nvar pna = require('process-nextick-args');\n/*</replacement>*/\n\n/*<replacement>*/\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) {\n    keys.push(key);\n  }return keys;\n};\n/*</replacement>*/\n\nmodule.exports = Duplex;\n\n/*<replacement>*/\nvar util = Object.create(require('core-util-is'));\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nvar Readable = require('./_stream_readable');\nvar Writable = require('./_stream_writable');\n\nutil.inherits(Duplex, Readable);\n\n{\n  // avoid scope creep, the keys array can then be collected\n  var keys = objectKeys(Writable.prototype);\n  for (var v = 0; v < keys.length; v++) {\n    var method = keys[v];\n    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];\n  }\n}\n\nfunction Duplex(options) {\n  if (!(this instanceof Duplex)) return new Duplex(options);\n\n  Readable.call(this, options);\n  Writable.call(this, options);\n\n  if (options && options.readable === false) this.readable = false;\n\n  if (options && options.writable === false) this.writable = false;\n\n  this.allowHalfOpen = true;\n  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;\n\n  this.once('end', onend);\n}\n\nObject.defineProperty(Duplex.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function () {\n    return this._writableState.highWaterMark;\n  }\n});\n\n// the no-half-open enforcer\nfunction onend() {\n  // if we allow half-open state, or if the writable side ended,\n  // then we're ok.\n  if (this.allowHalfOpen || this._writableState.ended) return;\n\n  // no more data can be written.\n  // But allow more writes to happen in this tick.\n  pna.nextTick(onEndNT, this);\n}\n\nfunction onEndNT(self) {\n  self.end();\n}\n\nObject.defineProperty(Duplex.prototype, 'destroyed', {\n  get: function () {\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return false;\n    }\n    return this._readableState.destroyed && this._writableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._readableState.destroyed = value;\n    this._writableState.destroyed = value;\n  }\n});\n\nDuplex.prototype._destroy = function (err, cb) {\n  this.push(null);\n  this.end();\n\n  pna.nextTick(cb, err);\n};","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n/*<replacement>*/\n\nvar Buffer = require('safe-buffer').Buffer;\n/*</replacement>*/\n\nvar isEncoding = Buffer.isEncoding || function (encoding) {\n  encoding = '' + encoding;\n  switch (encoding && encoding.toLowerCase()) {\n    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':\n      return true;\n    default:\n      return false;\n  }\n};\n\nfunction _normalizeEncoding(enc) {\n  if (!enc) return 'utf8';\n  var retried;\n  while (true) {\n    switch (enc) {\n      case 'utf8':\n      case 'utf-8':\n        return 'utf8';\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return 'utf16le';\n      case 'latin1':\n      case 'binary':\n        return 'latin1';\n      case 'base64':\n      case 'ascii':\n      case 'hex':\n        return enc;\n      default:\n        if (retried) return; // undefined\n        enc = ('' + enc).toLowerCase();\n        retried = true;\n    }\n  }\n};\n\n// Do not cache `Buffer.isEncoding` when checking encoding names as some\n// modules monkey-patch it to support additional encodings\nfunction normalizeEncoding(enc) {\n  var nenc = _normalizeEncoding(enc);\n  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);\n  return nenc || enc;\n}\n\n// StringDecoder provides an interface for efficiently splitting a series of\n// buffers into a series of JS strings without breaking apart multi-byte\n// characters.\nexports.StringDecoder = StringDecoder;\nfunction StringDecoder(encoding) {\n  this.encoding = normalizeEncoding(encoding);\n  var nb;\n  switch (this.encoding) {\n    case 'utf16le':\n      this.text = utf16Text;\n      this.end = utf16End;\n      nb = 4;\n      break;\n    case 'utf8':\n      this.fillLast = utf8FillLast;\n      nb = 4;\n      break;\n    case 'base64':\n      this.text = base64Text;\n      this.end = base64End;\n      nb = 3;\n      break;\n    default:\n      this.write = simpleWrite;\n      this.end = simpleEnd;\n      return;\n  }\n  this.lastNeed = 0;\n  this.lastTotal = 0;\n  this.lastChar = Buffer.allocUnsafe(nb);\n}\n\nStringDecoder.prototype.write = function (buf) {\n  if (buf.length === 0) return '';\n  var r;\n  var i;\n  if (this.lastNeed) {\n    r = this.fillLast(buf);\n    if (r === undefined) return '';\n    i = this.lastNeed;\n    this.lastNeed = 0;\n  } else {\n    i = 0;\n  }\n  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);\n  return r || '';\n};\n\nStringDecoder.prototype.end = utf8End;\n\n// Returns only complete characters in a Buffer\nStringDecoder.prototype.text = utf8Text;\n\n// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer\nStringDecoder.prototype.fillLast = function (buf) {\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);\n  this.lastNeed -= buf.length;\n};\n\n// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a\n// continuation byte. If an invalid byte is detected, -2 is returned.\nfunction utf8CheckByte(byte) {\n  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;\n  return byte >> 6 === 0x02 ? -1 : -2;\n}\n\n// Checks at most 3 bytes at the end of a Buffer in order to detect an\n// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)\n// needed to complete the UTF-8 character (if applicable) are returned.\nfunction utf8CheckIncomplete(self, buf, i) {\n  var j = buf.length - 1;\n  if (j < i) return 0;\n  var nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 1;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 2;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) {\n      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;\n    }\n    return nb;\n  }\n  return 0;\n}\n\n// Validates as many continuation bytes for a multi-byte UTF-8 character as\n// needed or are available. If we see a non-continuation byte where we expect\n// one, we \"replace\" the validated continuation bytes we've seen so far with\n// a single UTF-8 replacement character ('\\ufffd'), to match v8's UTF-8 decoding\n// behavior. The continuation byte check is included three times in the case\n// where all of the continuation bytes for a character exist in the same buffer.\n// It is also done this way as a slight performance increase instead of using a\n// loop.\nfunction utf8CheckExtraBytes(self, buf, p) {\n  if ((buf[0] & 0xC0) !== 0x80) {\n    self.lastNeed = 0;\n    return '\\ufffd';\n  }\n  if (self.lastNeed > 1 && buf.length > 1) {\n    if ((buf[1] & 0xC0) !== 0x80) {\n      self.lastNeed = 1;\n      return '\\ufffd';\n    }\n    if (self.lastNeed > 2 && buf.length > 2) {\n      if ((buf[2] & 0xC0) !== 0x80) {\n        self.lastNeed = 2;\n        return '\\ufffd';\n      }\n    }\n  }\n}\n\n// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.\nfunction utf8FillLast(buf) {\n  var p = this.lastTotal - this.lastNeed;\n  var r = utf8CheckExtraBytes(this, buf, p);\n  if (r !== undefined) return r;\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, p, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, p, 0, buf.length);\n  this.lastNeed -= buf.length;\n}\n\n// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a\n// partial character, the character's bytes are buffered until the required\n// number of bytes are available.\nfunction utf8Text(buf, i) {\n  var total = utf8CheckIncomplete(this, buf, i);\n  if (!this.lastNeed) return buf.toString('utf8', i);\n  this.lastTotal = total;\n  var end = buf.length - (total - this.lastNeed);\n  buf.copy(this.lastChar, 0, end);\n  return buf.toString('utf8', i, end);\n}\n\n// For UTF-8, a replacement character is added when ending on a partial\n// character.\nfunction utf8End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + '\\ufffd';\n  return r;\n}\n\n// UTF-16LE typically needs two bytes per character, but even if we have an even\n// number of bytes available, we need to check if we end on a leading/high\n// surrogate. In that case, we need to wait for the next two bytes in order to\n// decode the last character properly.\nfunction utf16Text(buf, i) {\n  if ((buf.length - i) % 2 === 0) {\n    var r = buf.toString('utf16le', i);\n    if (r) {\n      var c = r.charCodeAt(r.length - 1);\n      if (c >= 0xD800 && c <= 0xDBFF) {\n        this.lastNeed = 2;\n        this.lastTotal = 4;\n        this.lastChar[0] = buf[buf.length - 2];\n        this.lastChar[1] = buf[buf.length - 1];\n        return r.slice(0, -1);\n      }\n    }\n    return r;\n  }\n  this.lastNeed = 1;\n  this.lastTotal = 2;\n  this.lastChar[0] = buf[buf.length - 1];\n  return buf.toString('utf16le', i, buf.length - 1);\n}\n\n// For UTF-16LE we do not explicitly append special replacement characters if we\n// end on a partial character, we simply let v8 handle that.\nfunction utf16End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) {\n    var end = this.lastTotal - this.lastNeed;\n    return r + this.lastChar.toString('utf16le', 0, end);\n  }\n  return r;\n}\n\nfunction base64Text(buf, i) {\n  var n = (buf.length - i) % 3;\n  if (n === 0) return buf.toString('base64', i);\n  this.lastNeed = 3 - n;\n  this.lastTotal = 3;\n  if (n === 1) {\n    this.lastChar[0] = buf[buf.length - 1];\n  } else {\n    this.lastChar[0] = buf[buf.length - 2];\n    this.lastChar[1] = buf[buf.length - 1];\n  }\n  return buf.toString('base64', i, buf.length - n);\n}\n\nfunction base64End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);\n  return r;\n}\n\n// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)\nfunction simpleWrite(buf) {\n  return buf.toString(this.encoding);\n}\n\nfunction simpleEnd(buf) {\n  return buf && buf.length ? this.write(buf) : '';\n}","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n/*<replacement>*/\n\nvar pna = require('process-nextick-args');\n/*</replacement>*/\n\nmodule.exports = Readable;\n\n/*<replacement>*/\nvar isArray = require('isarray');\n/*</replacement>*/\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n\n/*<replacement>*/\nvar EE = require('events').EventEmitter;\n\nvar EElistenerCount = function (emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream = require('./internal/streams/stream');\n/*</replacement>*/\n\n/*<replacement>*/\n\nvar Buffer = require('safe-buffer').Buffer;\nvar OurUint8Array = (typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n\n/*</replacement>*/\n\n/*<replacement>*/\nvar util = Object.create(require('core-util-is'));\nutil.inherits = require('inherits');\n/*</replacement>*/\n\n/*<replacement>*/\nvar debugUtil = require('util');\nvar debug = void 0;\nif (debugUtil && debugUtil.debuglog) {\n  debug = debugUtil.debuglog('stream');\n} else {\n  debug = function () {};\n}\n/*</replacement>*/\n\nvar BufferList = require('./internal/streams/BufferList');\nvar destroyImpl = require('./internal/streams/destroy');\nvar StringDecoder;\n\nutil.inherits(Readable, Stream);\n\nvar kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];\n\nfunction prependListener(emitter, event, fn) {\n  // Sadly this is not cacheable as some libraries bundle their own\n  // event emitter implementation with them.\n  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);\n\n  // This is a hack to make sure that our error handler is attached before any\n  // userland ones.  NEVER DO THIS. This is here only because this code needs\n  // to continue to work with older versions of Node.js that do not include\n  // the prependListener() method. The goal is to eventually remove this hack.\n  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];\n}\n\nfunction ReadableState(options, stream) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  options = options || {};\n\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n  var isDuplex = stream instanceof Duplex;\n\n  // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n  this.objectMode = !!options.objectMode;\n\n  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;\n\n  // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n  var hwm = options.highWaterMark;\n  var readableHwm = options.readableHighWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n\n  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = Math.floor(this.highWaterMark);\n\n  // A linked list is used to store data chunks instead of an array because the\n  // linked list can remove elements from the beginning faster than\n  // array.shift()\n  this.buffer = new BufferList();\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false;\n\n  // a flag to be able to tell if the event 'readable'/'data' is emitted\n  // immediately, or on a later tick.  We set this to true at first, because\n  // any actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first read call.\n  this.sync = true;\n\n  // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n  this.resumeScheduled = false;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // the number of writers that are awaiting a drain event in .pipe()s\n  this.awaitDrain = 0;\n\n  // if true, a maybeReadMore has been scheduled\n  this.readingMore = false;\n\n  this.decoder = null;\n  this.encoding = null;\n  if (options.encoding) {\n    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\nfunction Readable(options) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  if (!(this instanceof Readable)) return new Readable(options);\n\n  this._readableState = new ReadableState(options, this);\n\n  // legacy\n  this.readable = true;\n\n  if (options) {\n    if (typeof options.read === 'function') this._read = options.read;\n\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n  }\n\n  Stream.call(this);\n}\n\nObject.defineProperty(Readable.prototype, 'destroyed', {\n  get: function () {\n    if (this._readableState === undefined) {\n      return false;\n    }\n    return this._readableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._readableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._readableState.destroyed = value;\n  }\n});\n\nReadable.prototype.destroy = destroyImpl.destroy;\nReadable.prototype._undestroy = destroyImpl.undestroy;\nReadable.prototype._destroy = function (err, cb) {\n  this.push(null);\n  cb(err);\n};\n\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function (chunk, encoding) {\n  var state = this._readableState;\n  var skipChunkCheck;\n\n  if (!state.objectMode) {\n    if (typeof chunk === 'string') {\n      encoding = encoding || state.defaultEncoding;\n      if (encoding !== state.encoding) {\n        chunk = Buffer.from(chunk, encoding);\n        encoding = '';\n      }\n      skipChunkCheck = true;\n    }\n  } else {\n    skipChunkCheck = true;\n  }\n\n  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);\n};\n\n// Unshift should *always* be something directly out of read()\nReadable.prototype.unshift = function (chunk) {\n  return readableAddChunk(this, chunk, null, true, false);\n};\n\nfunction readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {\n  var state = stream._readableState;\n  if (chunk === null) {\n    state.reading = false;\n    onEofChunk(stream, state);\n  } else {\n    var er;\n    if (!skipChunkCheck) er = chunkInvalid(state, chunk);\n    if (er) {\n      stream.emit('error', er);\n    } else if (state.objectMode || chunk && chunk.length > 0) {\n      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {\n        chunk = _uint8ArrayToBuffer(chunk);\n      }\n\n      if (addToFront) {\n        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);\n      } else if (state.ended) {\n        stream.emit('error', new Error('stream.push() after EOF'));\n      } else {\n        state.reading = false;\n        if (state.decoder && !encoding) {\n          chunk = state.decoder.write(chunk);\n          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);\n        } else {\n          addChunk(stream, state, chunk, false);\n        }\n      }\n    } else if (!addToFront) {\n      state.reading = false;\n    }\n  }\n\n  return needMoreData(state);\n}\n\nfunction addChunk(stream, state, chunk, addToFront) {\n  if (state.flowing && state.length === 0 && !state.sync) {\n    stream.emit('data', chunk);\n    stream.read(0);\n  } else {\n    // update the buffer info.\n    state.length += state.objectMode ? 1 : chunk.length;\n    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\n\n    if (state.needReadable) emitReadable(stream);\n  }\n  maybeReadMore(stream, state);\n}\n\nfunction chunkInvalid(state, chunk) {\n  var er;\n  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  return er;\n}\n\n// if it's past the high water mark, we can push in some more.\n// Also, if we have no data yet, we can stand some\n// more bytes.  This is to work around cases where hwm=0,\n// such as the repl.  Also, if the push() triggered a\n// readable event, and the user called read(largeNumber) such that\n// needReadable was set, then we ought to push more, so that another\n// 'readable' event will be triggered.\nfunction needMoreData(state) {\n  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);\n}\n\nReadable.prototype.isPaused = function () {\n  return this._readableState.flowing === false;\n};\n\n// backwards compatibility.\nReadable.prototype.setEncoding = function (enc) {\n  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n  this._readableState.decoder = new StringDecoder(enc);\n  this._readableState.encoding = enc;\n  return this;\n};\n\n// Don't raise the hwm > 8MB\nvar MAX_HWM = 0x800000;\nfunction computeNewHighWaterMark(n) {\n  if (n >= MAX_HWM) {\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\n    // tiny amounts\n    n--;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    n++;\n  }\n  return n;\n}\n\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction howMuchToRead(n, state) {\n  if (n <= 0 || state.length === 0 && state.ended) return 0;\n  if (state.objectMode) return 1;\n  if (n !== n) {\n    // Only flow one buffer at a time\n    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;\n  }\n  // If we're asking for more than the current hwm, then raise the hwm.\n  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n  if (n <= state.length) return n;\n  // Don't have enough\n  if (!state.ended) {\n    state.needReadable = true;\n    return 0;\n  }\n  return state.length;\n}\n\n// you can override either this method, or the async _read(n) below.\nReadable.prototype.read = function (n) {\n  debug('read', n);\n  n = parseInt(n, 10);\n  var state = this._readableState;\n  var nOrig = n;\n\n  if (n !== 0) state.emittedReadable = false;\n\n  // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n, state);\n\n  // if we've ended, and we're now clear, then finish it up.\n  if (n === 0 && state.ended) {\n    if (state.length === 0) endReadable(this);\n    return null;\n  }\n\n  // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n\n  // if we need a readable event, then we need to do some reading.\n  var doRead = state.needReadable;\n  debug('need readable', doRead);\n\n  // if we currently have less than the highWaterMark, then also read some\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  }\n\n  // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);\n  } else if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true;\n    // if the length is currently zero, then we *need* a readable event.\n    if (state.length === 0) state.needReadable = true;\n    // call internal read method\n    this._read(state.highWaterMark);\n    state.sync = false;\n    // If _read pushed data synchronously, then `reading` will be false,\n    // and we need to re-evaluate how much data we can return to the user.\n    if (!state.reading) n = howMuchToRead(nOrig, state);\n  }\n\n  var ret;\n  if (n > 0) ret = fromList(n, state);else ret = null;\n\n  if (ret === null) {\n    state.needReadable = true;\n    n = 0;\n  } else {\n    state.length -= n;\n  }\n\n  if (state.length === 0) {\n    // If we have nothing in the buffer, then we want to know\n    // as soon as we *do* get something into the buffer.\n    if (!state.ended) state.needReadable = true;\n\n    // If we tried to read() past the EOF, then emit end on the next tick.\n    if (nOrig !== n && state.ended) endReadable(this);\n  }\n\n  if (ret !== null) this.emit('data', ret);\n\n  return ret;\n};\n\nfunction onEofChunk(stream, state) {\n  if (state.ended) return;\n  if (state.decoder) {\n    var chunk = state.decoder.end();\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n  state.ended = true;\n\n  // emit 'readable' now to make sure it gets picked up.\n  emitReadable(stream);\n}\n\n// Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  state.needReadable = false;\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);\n  }\n}\n\nfunction emitReadable_(stream) {\n  debug('emit readable');\n  stream.emit('readable');\n  flow(stream);\n}\n\n// at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    pna.nextTick(maybeReadMore_, stream, state);\n  }\n}\n\nfunction maybeReadMore_(stream, state) {\n  var len = state.length;\n  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length)\n      // didn't get any data, stop spinning.\n      break;else len = state.length;\n  }\n  state.readingMore = false;\n}\n\n// abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\nReadable.prototype._read = function (n) {\n  this.emit('error', new Error('_read() is not implemented'));\n};\n\nReadable.prototype.pipe = function (dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n\n  var endFn = doEnd ? onend : unpipe;\n  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);\n\n  dest.on('unpipe', onunpipe);\n  function onunpipe(readable, unpipeInfo) {\n    debug('onunpipe');\n    if (readable === src) {\n      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n        unpipeInfo.hasUnpiped = true;\n        cleanup();\n      }\n    }\n  }\n\n  function onend() {\n    debug('onend');\n    dest.end();\n  }\n\n  // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n\n  var cleanedUp = false;\n  function cleanup() {\n    debug('cleanup');\n    // cleanup event handlers once the pipe is broken\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', unpipe);\n    src.removeListener('data', ondata);\n\n    cleanedUp = true;\n\n    // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n  }\n\n  // If the user pushes more data while we're writing to dest then we'll end up\n  // in ondata again. However, we only want to increase awaitDrain once because\n  // dest will only emit one 'drain' event for the multiple writes.\n  // => Introduce a guard on increasing awaitDrain.\n  var increasedAwaitDrain = false;\n  src.on('data', ondata);\n  function ondata(chunk) {\n    debug('ondata');\n    increasedAwaitDrain = false;\n    var ret = dest.write(chunk);\n    if (false === ret && !increasedAwaitDrain) {\n      // If the user unpiped during `dest.write()`, it is possible\n      // to get stuck in a permanently paused state if that write\n      // also returned false.\n      // => Check whether `dest` is still a piping destination.\n      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\n        debug('false write response, pause', state.awaitDrain);\n        state.awaitDrain++;\n        increasedAwaitDrain = true;\n      }\n      src.pause();\n    }\n  }\n\n  // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);\n  }\n\n  // Make sure our error handler is attached before userland ones.\n  prependListener(dest, 'error', onerror);\n\n  // Both close and finish should trigger unpipe, but only once.\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n  dest.once('close', onclose);\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n  dest.once('finish', onfinish);\n\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  }\n\n  // tell the dest that it's being piped to\n  dest.emit('pipe', src);\n\n  // start the flow if it hasn't been started already.\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src) {\n  return function () {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain) state.awaitDrain--;\n    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\n\nReadable.prototype.unpipe = function (dest) {\n  var state = this._readableState;\n  var unpipeInfo = { hasUnpiped: false };\n\n  // if we're not piping anywhere, then do nothing.\n  if (state.pipesCount === 0) return this;\n\n  // just one destination.  most common case.\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes) return this;\n\n    if (!dest) dest = state.pipes;\n\n    // got a match.\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest) dest.emit('unpipe', this, unpipeInfo);\n    return this;\n  }\n\n  // slow case. multiple pipe destinations.\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n\n    for (var i = 0; i < len; i++) {\n      dests[i].emit('unpipe', this, { hasUnpiped: false });\n    }return this;\n  }\n\n  // try to find the right one.\n  var index = indexOf(state.pipes, dest);\n  if (index === -1) return this;\n\n  state.pipes.splice(index, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1) state.pipes = state.pipes[0];\n\n  dest.emit('unpipe', this, unpipeInfo);\n\n  return this;\n};\n\n// set up data events if they are asked for\n// Ensure readable listeners eventually get something\nReadable.prototype.on = function (ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n\n  if (ev === 'data') {\n    // Start flowing on next tick if stream isn't explicitly paused\n    if (this._readableState.flowing !== false) this.resume();\n  } else if (ev === 'readable') {\n    var state = this._readableState;\n    if (!state.endEmitted && !state.readableListening) {\n      state.readableListening = state.needReadable = true;\n      state.emittedReadable = false;\n      if (!state.reading) {\n        pna.nextTick(nReadingNextTick, this);\n      } else if (state.length) {\n        emitReadable(this);\n      }\n    }\n  }\n\n  return res;\n};\nReadable.prototype.addListener = Readable.prototype.on;\n\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0');\n  self.read(0);\n}\n\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\nReadable.prototype.resume = function () {\n  var state = this._readableState;\n  if (!state.flowing) {\n    debug('resume');\n    state.flowing = true;\n    resume(this, state);\n  }\n  return this;\n};\n\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    pna.nextTick(resume_, stream, state);\n  }\n}\n\nfunction resume_(stream, state) {\n  if (!state.reading) {\n    debug('resume read 0');\n    stream.read(0);\n  }\n\n  state.resumeScheduled = false;\n  state.awaitDrain = 0;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading) stream.read(0);\n}\n\nReadable.prototype.pause = function () {\n  debug('call pause flowing=%j', this._readableState.flowing);\n  if (false !== this._readableState.flowing) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n  return this;\n};\n\nfunction flow(stream) {\n  var state = stream._readableState;\n  debug('flow', state.flowing);\n  while (state.flowing && stream.read() !== null) {}\n}\n\n// wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function (stream) {\n  var _this = this;\n\n  var state = this._readableState;\n  var paused = false;\n\n  stream.on('end', function () {\n    debug('wrapped end');\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length) _this.push(chunk);\n    }\n\n    _this.push(null);\n  });\n\n  stream.on('data', function (chunk) {\n    debug('wrapped data');\n    if (state.decoder) chunk = state.decoder.write(chunk);\n\n    // don't skip over falsy values in objectMode\n    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\n\n    var ret = _this.push(chunk);\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  });\n\n  // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n  for (var i in stream) {\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = function (method) {\n        return function () {\n          return stream[method].apply(stream, arguments);\n        };\n      }(i);\n    }\n  }\n\n  // proxy certain important events.\n  for (var n = 0; n < kProxyEvents.length; n++) {\n    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));\n  }\n\n  // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n  this._read = function (n) {\n    debug('wrapped _read', n);\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  return this;\n};\n\nObject.defineProperty(Readable.prototype, 'readableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function () {\n    return this._readableState.highWaterMark;\n  }\n});\n\n// exposed for testing purposes only.\nReadable._fromList = fromList;\n\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromList(n, state) {\n  // nothing buffered\n  if (state.length === 0) return null;\n\n  var ret;\n  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {\n    // read it all, truncate the list\n    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);\n    state.buffer.clear();\n  } else {\n    // read part of list\n    ret = fromListPartial(n, state.buffer, state.decoder);\n  }\n\n  return ret;\n}\n\n// Extracts only enough buffered data to satisfy the amount requested.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromListPartial(n, list, hasStrings) {\n  var ret;\n  if (n < list.head.data.length) {\n    // slice is the same for buffers and strings\n    ret = list.head.data.slice(0, n);\n    list.head.data = list.head.data.slice(n);\n  } else if (n === list.head.data.length) {\n    // first chunk is a perfect match\n    ret = list.shift();\n  } else {\n    // result spans more than one buffer\n    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);\n  }\n  return ret;\n}\n\n// Copies a specified amount of characters from the list of buffered data\n// chunks.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction copyFromBufferString(n, list) {\n  var p = list.head;\n  var c = 1;\n  var ret = p.data;\n  n -= ret.length;\n  while (p = p.next) {\n    var str = p.data;\n    var nb = n > str.length ? str.length : n;\n    if (nb === str.length) ret += str;else ret += str.slice(0, n);\n    n -= nb;\n    if (n === 0) {\n      if (nb === str.length) {\n        ++c;\n        if (p.next) list.head = p.next;else list.head = list.tail = null;\n      } else {\n        list.head = p;\n        p.data = str.slice(nb);\n      }\n      break;\n    }\n    ++c;\n  }\n  list.length -= c;\n  return ret;\n}\n\n// Copies a specified amount of bytes from the list of buffered data chunks.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction copyFromBuffer(n, list) {\n  var ret = Buffer.allocUnsafe(n);\n  var p = list.head;\n  var c = 1;\n  p.data.copy(ret);\n  n -= p.data.length;\n  while (p = p.next) {\n    var buf = p.data;\n    var nb = n > buf.length ? buf.length : n;\n    buf.copy(ret, ret.length - n, 0, nb);\n    n -= nb;\n    if (n === 0) {\n      if (nb === buf.length) {\n        ++c;\n        if (p.next) list.head = p.next;else list.head = list.tail = null;\n      } else {\n        list.head = p;\n        p.data = buf.slice(nb);\n      }\n      break;\n    }\n    ++c;\n  }\n  list.length -= c;\n  return ret;\n}\n\nfunction endReadable(stream) {\n  var state = stream._readableState;\n\n  // If we get here before consuming all the bytes, then that is a\n  // bug in node.  Should never happen.\n  if (state.length > 0) throw new Error('\"endReadable()\" called on non-empty stream');\n\n  if (!state.endEmitted) {\n    state.ended = true;\n    pna.nextTick(endReadableNT, state, stream);\n  }\n}\n\nfunction endReadableNT(state, stream) {\n  // Check that we didn't get one last unshift.\n  if (!state.endEmitted && state.length === 0) {\n    state.endEmitted = true;\n    stream.readable = false;\n    stream.emit('end');\n  }\n}\n\nfunction indexOf(xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n  return -1;\n}","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\n'use strict';\n\nmodule.exports = Transform;\n\nvar Duplex = require('./_stream_duplex');\n\n/*<replacement>*/\nvar util = Object.create(require('core-util-is'));\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nutil.inherits(Transform, Duplex);\n\nfunction afterTransform(er, data) {\n  var ts = this._transformState;\n  ts.transforming = false;\n\n  var cb = ts.writecb;\n\n  if (!cb) {\n    return this.emit('error', new Error('write callback called multiple times'));\n  }\n\n  ts.writechunk = null;\n  ts.writecb = null;\n\n  if (data != null) // single equals check for both `null` and `undefined`\n    this.push(data);\n\n  cb(er);\n\n  var rs = this._readableState;\n  rs.reading = false;\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    this._read(rs.highWaterMark);\n  }\n}\n\nfunction Transform(options) {\n  if (!(this instanceof Transform)) return new Transform(options);\n\n  Duplex.call(this, options);\n\n  this._transformState = {\n    afterTransform: afterTransform.bind(this),\n    needTransform: false,\n    transforming: false,\n    writecb: null,\n    writechunk: null,\n    writeencoding: null\n  };\n\n  // start out asking for a readable event once data is transformed.\n  this._readableState.needReadable = true;\n\n  // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n  this._readableState.sync = false;\n\n  if (options) {\n    if (typeof options.transform === 'function') this._transform = options.transform;\n\n    if (typeof options.flush === 'function') this._flush = options.flush;\n  }\n\n  // When the writable side finishes, then flush out anything remaining.\n  this.on('prefinish', prefinish);\n}\n\nfunction prefinish() {\n  var _this = this;\n\n  if (typeof this._flush === 'function') {\n    this._flush(function (er, data) {\n      done(_this, er, data);\n    });\n  } else {\n    done(this, null, null);\n  }\n}\n\nTransform.prototype.push = function (chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n};\n\n// This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\nTransform.prototype._transform = function (chunk, encoding, cb) {\n  throw new Error('_transform() is not implemented');\n};\n\nTransform.prototype._write = function (chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\n  }\n};\n\n// Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\nTransform.prototype._read = function (n) {\n  var ts = this._transformState;\n\n  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {\n    ts.transforming = true;\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\n\nTransform.prototype._destroy = function (err, cb) {\n  var _this2 = this;\n\n  Duplex.prototype._destroy.call(this, err, function (err2) {\n    cb(err2);\n    _this2.emit('close');\n  });\n};\n\nfunction done(stream, er, data) {\n  if (er) return stream.emit('error', er);\n\n  if (data != null) // single equals check for both `null` and `undefined`\n    stream.push(data);\n\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');\n\n  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');\n\n  return stream.push(null);\n}","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\n\n'use strict';\n\nmodule.exports = PassThrough;\n\nvar Transform = require('./_stream_transform');\n\n/*<replacement>*/\nvar util = Object.create(require('core-util-is'));\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nutil.inherits(PassThrough, Transform);\n\nfunction PassThrough(options) {\n  if (!(this instanceof PassThrough)) return new PassThrough(options);\n\n  Transform.call(this, options);\n}\n\nPassThrough.prototype._transform = function (chunk, encoding, cb) {\n  cb(null, chunk);\n};","exports = module.exports = require('./lib/_stream_readable.js');\nexports.Stream = exports;\nexports.Readable = exports;\nexports.Writable = require('./lib/_stream_writable.js');\nexports.Duplex = require('./lib/_stream_duplex.js');\nexports.Transform = require('./lib/_stream_transform.js');\nexports.PassThrough = require('./lib/_stream_passthrough.js');\n","\"use strict\";\n\nvar stream = require(\"readable-stream\");\n\nfunction DuplexWrapper(options, writable, readable) {\n  if (typeof readable === \"undefined\") {\n    readable = writable;\n    writable = options;\n    options = null;\n  }\n\n  stream.Duplex.call(this, options);\n\n  if (typeof readable.read !== \"function\") {\n    readable = (new stream.Readable(options)).wrap(readable);\n  }\n\n  this._writable = writable;\n  this._readable = readable;\n  this._waiting = false;\n\n  var self = this;\n\n  writable.once(\"finish\", function() {\n    self.end();\n  });\n\n  this.once(\"finish\", function() {\n    writable.end();\n  });\n\n  readable.on(\"readable\", function() {\n    if (self._waiting) {\n      self._waiting = false;\n      self._read();\n    }\n  });\n\n  readable.once(\"end\", function() {\n    self.push(null);\n  });\n\n  if (!options || typeof options.bubbleErrors === \"undefined\" || options.bubbleErrors) {\n    writable.on(\"error\", function(err) {\n      self.emit(\"error\", err);\n    });\n\n    readable.on(\"error\", function(err) {\n      self.emit(\"error\", err);\n    });\n  }\n}\n\nDuplexWrapper.prototype = Object.create(stream.Duplex.prototype, {constructor: {value: DuplexWrapper}});\n\nDuplexWrapper.prototype._write = function _write(input, encoding, done) {\n  this._writable.write(input, encoding, done);\n};\n\nDuplexWrapper.prototype._read = function _read() {\n  var buf;\n  var reads = 0;\n  while ((buf = this._readable.read()) !== null) {\n    this.push(buf);\n    reads++;\n  }\n  if (reads === 0) {\n    this._waiting = true;\n  }\n};\n\nmodule.exports = function duplex2(options, writable, readable) {\n  return new DuplexWrapper(options, writable, readable);\n};\n\nmodule.exports.DuplexWrapper = DuplexWrapper;\n","/*\nobject-assign\n(c) Sindre Sorhus\n@license MIT\n*/\n\n'use strict';\n/* eslint-disable no-unused-vars */\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nfunction toObject(val) {\n\tif (val === null || val === undefined) {\n\t\tthrow new TypeError('Object.assign cannot be called with null or undefined');\n\t}\n\n\treturn Object(val);\n}\n\nfunction shouldUseNative() {\n\ttry {\n\t\tif (!Object.assign) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Detect buggy property enumeration order in older V8 versions.\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=4118\n\t\tvar test1 = new String('abc');  // eslint-disable-line no-new-wrappers\n\t\ttest1[5] = 'de';\n\t\tif (Object.getOwnPropertyNames(test1)[0] === '5') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test2 = {};\n\t\tfor (var i = 0; i < 10; i++) {\n\t\t\ttest2['_' + String.fromCharCode(i)] = i;\n\t\t}\n\t\tvar order2 = Object.getOwnPropertyNames(test2).map(function (n) {\n\t\t\treturn test2[n];\n\t\t});\n\t\tif (order2.join('') !== '0123456789') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test3 = {};\n\t\t'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\n\t\t\ttest3[letter] = letter;\n\t\t});\n\t\tif (Object.keys(Object.assign({}, test3)).join('') !==\n\t\t\t\t'abcdefghijklmnopqrst') {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t} catch (err) {\n\t\t// We don't expect any of the above to throw, but better to be safe.\n\t\treturn false;\n\t}\n}\n\nmodule.exports = shouldUseNative() ? Object.assign : function (target, source) {\n\tvar from;\n\tvar to = toObject(target);\n\tvar symbols;\n\n\tfor (var s = 1; s < arguments.length; s++) {\n\t\tfrom = Object(arguments[s]);\n\n\t\tfor (var key in from) {\n\t\t\tif (hasOwnProperty.call(from, key)) {\n\t\t\t\tto[key] = from[key];\n\t\t\t}\n\t\t}\n\n\t\tif (getOwnPropertySymbols) {\n\t\t\tsymbols = getOwnPropertySymbols(from);\n\t\t\tfor (var i = 0; i < symbols.length; i++) {\n\t\t\t\tif (propIsEnumerable.call(from, symbols[i])) {\n\t\t\t\t\tto[symbols[i]] = from[symbols[i]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn to;\n};\n","\n/**\n * Module dependencies.\n */\n\nvar duplexer = require('duplexer2');\nvar PassThrough = require('stream').PassThrough;\nvar Readable = require('stream').PassThrough;\nvar objectAssign = require('object-assign');\n\n/**\n * Slice reference.\n */\n\nvar slice = [].slice;\n\n/**\n * Duplexer options.\n */\n\nvar defaultOpts = {\n  bubbleErrors: false,\n  objectMode: true\n};\n\n/**\n * Expose `pipe`.\n */\n\nmodule.exports = pipe;\n\n/**\n * Pipe.\n *\n * @param streams Array[Stream,...]\n * @param opts [Object]\n * @param cb [Function]\n * @return {Stream}\n * @api public\n */\n\nfunction pipe(streams, opts, cb){\n  if (!Array.isArray(streams)) {\n    streams = slice.call(arguments);\n    opts = null;\n    cb = null;\n  }\n\n  var lastArg = streams[streams.length - 1];\n  if ('function' == typeof lastArg) {\n    cb = streams.splice(-1)[0];\n    lastArg = streams[streams.length - 1];\n  }\n  if ('object' == typeof lastArg && typeof lastArg.pipe != 'function') {\n    opts = streams.splice(-1)[0];\n  }\n  var first = streams[0];\n  var last = streams[streams.length - 1];\n  var ret;\n  opts = objectAssign({}, defaultOpts, opts)\n\n  if (!first) {\n    if (cb) process.nextTick(cb);\n    return new PassThrough(opts);\n  }\n  \n  if (first.writable && last.readable) ret = duplexer(opts, first, last);\n  else if (streams.length == 1) ret = new Readable(opts).wrap(streams[0]);\n  else if (first.writable) ret = first;\n  else if (last.readable) ret = last;\n  else ret = new PassThrough(opts);\n  \n  streams.forEach(function(stream, i){\n    var next = streams[i+1];\n    if (next) stream.pipe(next);\n    if (stream != ret) stream.on('error', ret.emit.bind(ret, 'error'));\n  });\n\n  if (cb) {\n    var ended = false;\n    ret.on('error', end);\n    last.on('finish', function(){ end() });\n    last.on('close', function(){ end() });\n    function end(err){\n      if (ended) return;\n      ended = true;\n      cb(err);\n    }\n  }\n\n  return ret;\n}\n\n","import through from 'through';\nimport tokenize from 'html-tokenize';\nimport pipe from 'multipipe';\n\nvar createExtractCritical = function createExtractCritical(cache) {\n  return function (html) {\n    // parse out ids from html\n    // reconstruct css/rules/cache to pass\n    var RGX = new RegExp(cache.key + \"-([a-zA-Z0-9-_]+)\", 'gm');\n    var o = {\n      html: html,\n      ids: [],\n      css: ''\n    };\n    var match;\n    var ids = {};\n\n    while ((match = RGX.exec(html)) !== null) {\n      // $FlowFixMe\n      if (ids[match[1]] === undefined) {\n        // $FlowFixMe\n        ids[match[1]] = true;\n      }\n    }\n\n    o.ids = Object.keys(cache.inserted).filter(function (id) {\n      if ((ids[id] !== undefined || cache.registered[cache.key + \"-\" + id] === undefined) && cache.inserted[id] !== true) {\n        o.css += cache.inserted[id];\n        return true;\n      }\n    });\n    return o;\n  };\n};\n\nvar createExtractCriticalToChunks = function createExtractCriticalToChunks(cache) {\n  return function (html) {\n    // parse out ids from html\n    // reconstruct css/rules/cache to pass\n    var RGX = new RegExp(cache.key + \"-([a-zA-Z0-9-_]+)\", 'gm');\n    var o = {\n      html: html,\n      styles: []\n    };\n    var match;\n    var ids = {};\n\n    while ((match = RGX.exec(html)) !== null) {\n      // $FlowFixMe\n      if (ids[match[1]] === undefined) {\n        // $FlowFixMe\n        ids[match[1]] = true;\n      }\n    }\n\n    var regularCssIds = [];\n    var regularCss = '';\n    Object.keys(cache.inserted).forEach(function (id) {\n      if ((ids[id] !== undefined || cache.registered[cache.key + \"-\" + id] === undefined) && cache.inserted[id] !== true) {\n        if (cache.registered[cache.key + \"-\" + id]) {\n          // regular css can be added in one style tag\n          regularCssIds.push(id); // $FlowFixMe\n\n          regularCss += cache.inserted[id];\n        } else {\n          // each global styles require a new entry so it can be independently flushed\n          o.styles.push({\n            key: cache.key + \"-global\",\n            ids: [id],\n            css: cache.inserted[id]\n          });\n        }\n      }\n    }); // make sure that regular css is added after the global styles\n\n    o.styles.push({\n      key: cache.key,\n      ids: regularCssIds,\n      css: regularCss\n    });\n    return o;\n  };\n};\n\nfunction generateStyleTag(cssKey, ids, styles, nonceString) {\n  return \"<style data-emotion=\\\"\" + cssKey + \" \" + ids + \"\\\"\" + nonceString + \">\" + styles + \"</style>\";\n}\n\nvar createRenderStylesToString = function createRenderStylesToString(cache, nonceString) {\n  return function (html) {\n    var inserted = cache.inserted,\n        cssKey = cache.key,\n        registered = cache.registered;\n    var regex = new RegExp(\"<|\" + cssKey + \"-([a-zA-Z0-9-_]+)\", 'gm');\n    var seen = {};\n    var result = '';\n    var globalIds = '';\n    var globalStyles = '';\n\n    for (var id in inserted) {\n      // eslint-disable-next-line no-prototype-builtins\n      if (inserted.hasOwnProperty(id)) {\n        var style = inserted[id];\n        var key = cssKey + \"-\" + id;\n\n        if (style !== true && registered[key] === undefined) {\n          globalStyles += style;\n          globalIds += \" \" + id;\n        }\n      }\n    }\n\n    if (globalStyles !== '') {\n      result = generateStyleTag(cssKey, globalIds.substring(1), globalStyles, nonceString);\n    }\n\n    var ids = '';\n    var styles = '';\n    var lastInsertionPoint = 0;\n    var match;\n\n    while ((match = regex.exec(html)) !== null) {\n      // $FlowFixMe\n      if (match[0] === '<') {\n        if (ids !== '') {\n          result += generateStyleTag(cssKey, ids.substring(1), styles, nonceString);\n          ids = '';\n          styles = '';\n        } // $FlowFixMe\n\n\n        result += html.substring(lastInsertionPoint, match.index); // $FlowFixMe\n\n        lastInsertionPoint = match.index;\n        continue;\n      } // $FlowFixMe\n\n\n      var _id = match[1];\n      var _style = inserted[_id];\n\n      if (_style === true || _style === undefined || seen[_id]) {\n        continue;\n      }\n\n      seen[_id] = true;\n      styles += _style;\n      ids += \" \" + _id;\n    }\n\n    result += html.substring(lastInsertionPoint);\n    return result;\n  };\n};\n\nvar createRenderStylesToNodeStream = function createRenderStylesToNodeStream(cache, nonceString) {\n  return function () {\n    var insed = {};\n    var tokenStream = tokenize();\n    var inlineStream = through(function write(thing) {\n      var type = thing[0],\n          data = thing[1];\n\n      if (type === 'open') {\n        var css = '';\n        var ids = {};\n        var match;\n        var fragment = data.toString();\n        var regex = new RegExp(cache.key + \"-([a-zA-Z0-9-_]+)\", 'gm');\n\n        while ((match = regex.exec(fragment)) !== null) {\n          if (match !== null && insed[match[1]] === undefined) {\n            ids[match[1]] = true;\n          }\n        }\n\n        Object.keys(cache.inserted).forEach(function (id) {\n          if (cache.inserted[id] !== true && insed[id] === undefined && (ids[id] === true || cache.registered[cache.key + \"-\" + id] === undefined && (ids[id] = true))) {\n            insed[id] = true; // $FlowFixMe flow thinks emotion.caches.inserted[id] can be true even though it's checked earlier\n\n            css += cache.inserted[id];\n          }\n        });\n\n        if (css !== '') {\n          this.queue(\"<style data-emotion=\\\"\" + cache.key + \" \" + Object.keys(ids).join(' ') + \"\\\"\" + nonceString + \">\" + css + \"</style>\");\n        }\n      }\n\n      this.queue(data);\n    }, function end() {\n      this.queue(null);\n    });\n    return pipe(tokenStream, inlineStream);\n  };\n};\n\nvar createConstructStyleTagsFromChunks = function createConstructStyleTagsFromChunks(cache, nonceString) {\n  return function (criticalData) {\n    var styleTagsString = '';\n    criticalData.styles.forEach(function (item) {\n      styleTagsString += generateStyleTag(item.key, item.ids.join(' '), item.css, nonceString);\n    });\n    return styleTagsString;\n  };\n};\n\nfunction createEmotionServer (cache) {\n  if (cache.compat !== true) {\n    // is this good? should we do this automatically?\n    // this is only for when using the new apis (not emotion or create-emotion)\n    cache.compat = true;\n  }\n\n  var nonceString = cache.nonce !== undefined ? \" nonce=\\\"\" + cache.nonce + \"\\\"\" : '';\n  return {\n    extractCritical: createExtractCritical(cache),\n    extractCriticalToChunks: createExtractCriticalToChunks(cache),\n    renderStylesToString: createRenderStylesToString(cache, nonceString),\n    renderStylesToNodeStream: createRenderStylesToNodeStream(cache, nonceString),\n    constructStyleTagsFromChunks: createConstructStyleTagsFromChunks(cache, nonceString)\n  };\n}\n\nexport { createEmotionServer as default };\n"],"names":["Stream","require$$0","module","through","write","end","opts","data","ended","destroyed","buffer","_ended","stream","drain","_end","toString","isModern","isArrayBuffer","input","fromArrayBuffer","obj","byteOffset","length","maxLength","fromString","string","encoding","bufferFrom","value","encodingOrOffset","bufferFrom_1","isarray","arr","isArray","arg","objectToString","util","isBoolean","isNull","isNullOrUndefined","isNumber","isString","isSymbol","isUndefined","isRegExp","re","isObject","isDate","d","isError","e","isFunction","isPrimitive","o","inherits_browserModule","ctor","superCtor","TempCtor","Buffer","isBufferEncoding","assertEncoding","StringDecoder","string_decoder","utf16DetectIncompleteChar","base64DetectIncompleteChar","passThroughWrite","charStr","available","charCode","size","i","res","cr","buf","enc","_stream_readable","Readable","require$$1","ReadableState","EE","require$$2","emitter","type","require$$3","require$$4","require$$5","options","hwm","require$$6","chunk","state","readableAddChunk","addToFront","er","chunkInvalid","onEofChunk","emitReadable","maybeReadMore","needMoreData","MAX_HWM","roundUpToNextPowerOf2","n","p","howMuchToRead","nOrig","ret","fromList","endReadable","doRead","emitReadable_","maybeReadMore_","len","dest","pipeOpts","src","doEnd","endFn","onend","cleanup","onunpipe","readable","ondrain","pipeOnDrain","onclose","onfinish","onerror","unpipe","pipeOnReadable","flow","list","written","forEach","emitDataEvents","dests","indexOf","ev","fn","startPaused","paused","c","self","method","events","stringMode","objectMode","l","cpy","xs","f","x","_stream_duplex","Duplex","objectKeys","keys","key","Writable","_stream_writable","WritableState","WriteReq","cb","noDecode","onwrite","writeAfterEnd","validChunk","valid","writeOrBuffer","decodeChunk","doWrite","onwriteError","sync","onwriteStateUpdate","finished","needFinish","clearBuffer","afterWrite","onwriteDrain","finishMaybe","entry","endWritable","need","_stream_transform","Transform","TransformState","afterTransform","ts","rs","done","ws","_stream_passthrough","PassThrough","exports","inherits","Tokenize","htmlTokenize","codes","strings","states","next","offset","b","parts","isWhiteSpace","tag","compare","j","k","index","raw","last","a","lower","processNextickArgsModule","nextTick","arg1","arg2","arg3","args","streamBrowser","copyProps","dst","SafeBuffer","fill","_classCallCheck","instance","Constructor","copyBuffer","target","BufferList","v","s","pna","destroy","err","_this","readableDestroyed","writableDestroyed","emitErrorNT","undestroy","destroy_1","browser","deprecate","msg","config","warned","deprecated","name","global","val","CorkedRequest","onCorkedFinish","asyncWrite","internalUtil","OurUint8Array","_uint8ArrayToBuffer","_isUint8Array","destroyImpl","nop","require$$7","isDuplex","writableHwm","defaultHwm","current","out","realHasInstance","object","isBuf","newChunk","writev","holder","count","allBuffers","callFinal","prefinish","corkReq","onEndNT","isEncoding","_normalizeEncoding","retried","normalizeEncoding","nenc","nb","utf16Text","utf16End","utf8FillLast","base64Text","base64End","simpleWrite","simpleEnd","r","utf8End","utf8Text","utf8CheckByte","byte","utf8CheckIncomplete","utf8CheckExtraBytes","total","EElistenerCount","debugUtil","debug","require$$8","require$$9","kProxyEvents","prependListener","event","require$$10","readableHwm","require$$11","skipChunkCheck","addChunk","computeNewHighWaterMark","unpipeInfo","cleanedUp","ondata","increasedAwaitDrain","nReadingNextTick","resume","resume_","fromListPartial","hasStrings","copyFromBufferString","copyFromBuffer","str","endReadableNT","_this2","err2","DuplexWrapper","writable","reads","duplexer2Module","getOwnPropertySymbols","hasOwnProperty","propIsEnumerable","toObject","shouldUseNative","test1","test2","order2","test3","letter","objectAssign","source","from","to","symbols","duplexer","slice","defaultOpts","multipipe","pipe","streams","lastArg","first","createExtractCritical","cache","html","RGX","match","ids","id","createExtractCriticalToChunks","regularCssIds","regularCss","generateStyleTag","cssKey","styles","nonceString","createRenderStylesToString","inserted","registered","regex","seen","result","globalIds","globalStyles","style","lastInsertionPoint","_id","_style","createRenderStylesToNodeStream","insed","tokenStream","tokenize","inlineStream","thing","css","fragment","createConstructStyleTagsFromChunks","criticalData","styleTagsString","item","createEmotionServer"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30]}