{"version":3,"file":"form-BZobFHoy.js","sources":["../src/utils/form.ts"],"sourcesContent":["import type { FieldValidator, FormikHelpers } from \"formik\"\nimport { type Schema, type ValidateOptions, ValidationError } from \"yup\"\nimport type { TypedMutationTrigger } from \"@reduxjs/toolkit/query/react\"\n\nimport { excludeKeyPaths, getKeyPaths, getNestedProperty } from \"./general\"\n\nexport type FormValues = Record<string, any>\n\nexport function isFormError(error: unknown): boolean {\n  return (\n    typeof error === \"object\" &&\n    error !== null &&\n    \"status\" in error &&\n    error.status === 400 &&\n    \"data\" in error &&\n    typeof error.data === \"object\" &&\n    error.data !== null\n  )\n}\n\nexport function setFormErrors(\n  error: unknown,\n  setErrors: (errors: object) => void,\n): void {\n  if (!isFormError(error)) throw error\n\n  const data = Object.fromEntries(\n    Object.entries((error as { data: object }).data).map(([field, errors]) => {\n      if (Array.isArray(errors)) errors = errors.join(\". \")\n      return [field, errors]\n    }),\n  )\n\n  setErrors(data)\n}\n\nexport type SubmitFormOptions<\n  Values extends FormValues,\n  QueryArg extends FormValues,\n  ResultType,\n> = Partial<{\n  exclude: string[]\n  include: string[]\n  onlyDirtyValues: boolean\n  then: (\n    result: ResultType,\n    values: Values,\n    helpers: FormikHelpers<Values>,\n  ) => void\n  catch: (\n    error: unknown,\n    values: Values,\n    helpers: FormikHelpers<Values>,\n  ) => void\n  finally: (values: Values, helpers: FormikHelpers<Values>) => void\n}> &\n  (Values extends QueryArg\n    ? { clean?: (values: Values) => QueryArg }\n    : { clean: (values: Values) => QueryArg })\n\nexport type SubmitFormHandler<Values extends FormValues> = (\n  values: Values,\n  helpers: FormikHelpers<Values>,\n) => void | Promise<any>\n\nexport function submitForm<\n  Values extends QueryArg,\n  QueryArg extends FormValues,\n  ResultType,\n>(\n  trigger: TypedMutationTrigger<ResultType, QueryArg, any>,\n  initialValues: Values,\n  options?: SubmitFormOptions<Values, QueryArg, ResultType>,\n): SubmitFormHandler<Values>\n\nexport function submitForm<\n  Values extends FormValues,\n  QueryArg extends FormValues,\n  ResultType,\n>(\n  trigger: TypedMutationTrigger<ResultType, QueryArg, any>,\n  initialValues: Values,\n  options: SubmitFormOptions<Values, QueryArg, ResultType>,\n): SubmitFormHandler<Values>\n\nexport function submitForm<\n  Values extends FormValues,\n  QueryArg extends FormValues,\n  ResultType,\n>(\n  trigger: TypedMutationTrigger<ResultType, QueryArg, any>,\n  initialValues: Values,\n  options?: SubmitFormOptions<Values, QueryArg, ResultType>,\n): SubmitFormHandler<Values> {\n  const {\n    include,\n    onlyDirtyValues = false,\n    then,\n    catch: _catch,\n    finally: _finally,\n  } = options || {}\n  let { exclude = [] } = options || {}\n\n  return (values, helpers) => {\n    let arg =\n      options && options.clean\n        ? options.clean(values as QueryArg & FormValues)\n        : (values as unknown as QueryArg)\n\n    if (onlyDirtyValues) {\n      exclude = [\n        ...exclude,\n        ...getCleanNames(values, initialValues).filter(\n          cleanName => !exclude.includes(cleanName),\n        ),\n      ]\n    }\n\n    if (include) exclude = exclude.filter(name => !include.includes(name))\n\n    if (exclude.length) arg = excludeKeyPaths(arg, exclude) as QueryArg\n\n    trigger(arg)\n      .unwrap()\n      .then(result => {\n        if (then) then(result, values, helpers)\n      })\n      .catch(error => {\n        if (_catch) _catch(error, values, helpers)\n        setFormErrors(error, helpers.setErrors)\n      })\n      .finally(() => {\n        if (_finally) _finally(values, helpers)\n      })\n  }\n}\n\nexport function schemaToFieldValidator(\n  schema: Schema,\n  options?: ValidateOptions,\n): FieldValidator {\n  return async value => {\n    try {\n      await schema.validate(value, options)\n    } catch (error) {\n      if (error instanceof ValidationError) {\n        return error.errors.join(\". \")\n      }\n\n      throw error\n    }\n  }\n}\n\n// Checking if individual fields are dirty is not currently supported.\n// https://github.com/jaredpalmer/formik/issues/1421\nexport function getDirty<Values extends FormValues>(\n  values: Values,\n  initialValues: Values,\n  names?: string[],\n): Record<string, boolean> {\n  if (!names) names = getKeyPaths(values)\n\n  return Object.fromEntries(\n    names.map(name => [name, isDirty(values, initialValues, name)]),\n  )\n}\n\nexport function isDirty<Values extends FormValues>(\n  values: Values,\n  initialValues: Values,\n  name: string,\n): boolean {\n  const value: unknown = getNestedProperty(values, name)\n  const initialValue: unknown = getNestedProperty(initialValues, name)\n\n  return value !== initialValue\n}\n\nexport function getCleanNames<Values extends FormValues>(\n  values: Values,\n  initialValues: Values,\n  names?: string[],\n): string[] {\n  return Object.entries(getDirty(values, initialValues, names))\n    .filter(\n      ([\n        _, // eslint-disable-line @typescript-eslint/no-unused-vars\n        isDirty,\n      ]) => !isDirty,\n    )\n    .map(([name]) => name)\n}\n"],"names":["isFormError","error","setFormErrors","setErrors","data","field","errors","submitForm","trigger","initialValues","options","include","onlyDirtyValues","then","_catch","_finally","exclude","values","helpers","arg","getCleanNames","cleanName","name","excludeKeyPaths","result","schemaToFieldValidator","schema","value","ValidationError","getDirty","names","getKeyPaths","isDirty","getNestedProperty","initialValue","_"],"mappings":";;;;;AAQO,SAASA,EAAYC,GAAyB;AACnD,SACE,OAAOA,KAAU,YACjBA,MAAU,QACV,YAAYA,KACZA,EAAM,WAAW,OACjB,UAAUA,KACV,OAAOA,EAAM,QAAS,YACtBA,EAAM,SAAS;AAEnB;AAEO,SAASC,EACdD,GACAE,GACM;AACN,MAAI,CAACH,EAAYC,CAAK,EAAG,OAAMA;AAE/B,QAAMG,IAAO,OAAO;AAAA,IAClB,OAAO,QAASH,EAA2B,IAAI,EAAE,IAAI,CAAC,CAACI,GAAOC,CAAM,OAC9D,MAAM,QAAQA,CAAM,MAAGA,IAASA,EAAO,KAAK,IAAI,IAC7C,CAACD,GAAOC,CAAM,EACtB;AAAA,EAAA;AAGH,EAAAH,EAAUC,CAAI;AAChB;AAmDO,SAASG,EAKdC,GACAC,GACAC,GAC2B;AAC3B,QAAM;AAAA,IACJ,SAAAC;AAAA,IACA,iBAAAC,IAAkB;AAAA,IAClB,MAAAC;AAAA,IACA,OAAOC;AAAA,IACP,SAASC;AAAA,EAAA,IACPL,KAAW,CAAA;AACf,MAAI,EAAE,SAAAM,IAAU,GAAC,IAAMN,KAAW,CAAA;AAElC,SAAO,CAACO,GAAQC,MAAY;AAC1B,QAAIC,IACFT,KAAWA,EAAQ,QACfA,EAAQ,MAAMO,CAA+B,IAC5CA;AAEP,IAAIL,MACFI,IAAU;AAAA,MACR,GAAGA;AAAA,MACH,GAAGI,EAAcH,GAAQR,CAAa,EAAE;AAAA,QACtC,CAAAY,MAAa,CAACL,EAAQ,SAASK,CAAS;AAAA,MAAA;AAAA,IAC1C,IAIAV,UAAmBK,EAAQ,OAAO,OAAQ,CAACL,EAAQ,SAASW,CAAI,CAAC,IAEjEN,EAAQ,WAAQG,IAAMI,EAAgBJ,GAAKH,CAAO,IAEtDR,EAAQW,CAAG,EACR,OAAA,EACA,KAAK,CAAAK,MAAU;AACd,MAAIX,KAAMA,EAAKW,GAAQP,GAAQC,CAAO;AAAA,IACxC,CAAC,EACA,MAAM,CAAAjB,MAAS;AACd,MAAIa,KAAQA,EAAOb,GAAOgB,GAAQC,CAAO,GACzChB,EAAcD,GAAOiB,EAAQ,SAAS;AAAA,IACxC,CAAC,EACA,QAAQ,MAAM;AACb,MAAIH,KAAUA,EAASE,GAAQC,CAAO;AAAA,IACxC,CAAC;AAAA,EACL;AACF;AAEO,SAASO,EACdC,GACAhB,GACgB;AAChB,SAAO,OAAMiB,MAAS;AACpB,QAAI;AACF,YAAMD,EAAO,SAASC,GAAOjB,CAAO;AAAA,IACtC,SAAST,GAAO;AACd,UAAIA,aAAiB2B;AACnB,eAAO3B,EAAM,OAAO,KAAK,IAAI;AAG/B,YAAMA;AAAA,IACR;AAAA,EACF;AACF;AAIO,SAAS4B,EACdZ,GACAR,GACAqB,GACyB;AACzB,SAAKA,MAAOA,IAAQC,EAAYd,CAAM,IAE/B,OAAO;AAAA,IACZa,EAAM,IAAI,CAAAR,MAAQ,CAACA,GAAMU,EAAQf,GAAQR,GAAea,CAAI,CAAC,CAAC;AAAA,EAAA;AAElE;AAEO,SAASU,EACdf,GACAR,GACAa,GACS;AACT,QAAMK,IAAiBM,EAAkBhB,GAAQK,CAAI,GAC/CY,IAAwBD,EAAkBxB,GAAea,CAAI;AAEnE,SAAOK,MAAUO;AACnB;AAEO,SAASd,EACdH,GACAR,GACAqB,GACU;AACV,SAAO,OAAO,QAAQD,EAASZ,GAAQR,GAAeqB,CAAK,CAAC,EACzD;AAAA,IACC,CAAC;AAAA,MACCK;AAAA;AAAA,MACAH;AAAAA,IAAA,MACI,CAACA;AAAAA,EAAA,EAER,IAAI,CAAC,CAACV,CAAI,MAAMA,CAAI;AACzB;;;;;;;;;;;"}