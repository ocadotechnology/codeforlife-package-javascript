{"version":3,"file":"form-BDh51m23.cjs","sources":["../src/hooks/api.tsx","../src/utils/form.ts"],"sourcesContent":["import { type Dispatch, type SetStateAction, useState } from \"react\"\n\nexport type Pagination = { page: number; limit: number; offset: number }\nexport type SetPagination = Dispatch<\n  SetStateAction<{ page: number; limit: number }>\n>\nexport type UsePaginationOptions = Partial<{\n  page: number\n  limit: number\n}>\n\nexport function usePagination(\n  options?: UsePaginationOptions,\n): [Pagination, SetPagination] {\n  const { page = 0, limit = 150 } = options || {}\n\n  const [pagination, _setPagination] = useState<Pagination>({\n    page,\n    limit,\n    offset: page * limit,\n  })\n\n  const setPagination: SetPagination = value => {\n    _setPagination(({ page: previousPage, limit: previousLimit }) => {\n      const pagination =\n        typeof value === \"function\"\n          ? value({ page: previousPage, limit: previousLimit })\n          : value\n      let page = pagination.page\n      const limit = pagination.limit\n\n      if (limit !== previousLimit) page = 0\n\n      return { page, limit, offset: page * limit }\n    })\n  }\n\n  return [pagination, setPagination]\n}\n","import type { FieldValidator, FormikHelpers } from \"formik\"\nimport { type Schema, type ValidateOptions, ValidationError } from \"yup\"\nimport type { TypedMutationTrigger } from \"@reduxjs/toolkit/query/react\"\n\nimport { excludeKeyPaths, getKeyPaths, getNestedProperty } from \"./general\"\n\nexport type FormValues = Record<string, any>\n\nexport function isFormError(error: unknown): boolean {\n  return (\n    typeof error === \"object\" &&\n    error !== null &&\n    \"status\" in error &&\n    error.status === 400 &&\n    \"data\" in error &&\n    typeof error.data === \"object\" &&\n    error.data !== null\n  )\n}\n\nexport function setFormErrors(\n  error: unknown,\n  setErrors: (errors: object) => void,\n): void {\n  if (!isFormError(error)) throw error\n\n  const data = Object.fromEntries(\n    Object.entries((error as { data: object }).data).map(([field, errors]) => {\n      if (Array.isArray(errors)) errors = errors.join(\". \")\n      return [field, errors]\n    }),\n  )\n\n  setErrors(data)\n}\n\nexport type SubmitFormOptions<\n  Values extends FormValues,\n  QueryArg extends FormValues,\n  ResultType,\n> = Partial<{\n  exclude: string[]\n  include: string[]\n  onlyDirtyValues: boolean\n  then: (\n    result: ResultType,\n    values: Values,\n    helpers: FormikHelpers<Values>,\n  ) => void\n  catch: (\n    error: unknown,\n    values: Values,\n    helpers: FormikHelpers<Values>,\n  ) => void\n  finally: (values: Values, helpers: FormikHelpers<Values>) => void\n}> &\n  (Values extends QueryArg\n    ? { clean?: (values: Values) => QueryArg }\n    : { clean: (values: Values) => QueryArg })\n\nexport type SubmitFormHandler<Values extends FormValues> = (\n  values: Values,\n  helpers: FormikHelpers<Values>,\n) => void | Promise<any>\n\nexport function submitForm<\n  Values extends QueryArg,\n  QueryArg extends FormValues,\n  ResultType,\n>(\n  trigger: TypedMutationTrigger<ResultType, QueryArg, any>,\n  initialValues: Values,\n  options?: SubmitFormOptions<Values, QueryArg, ResultType>,\n): SubmitFormHandler<Values>\n\nexport function submitForm<\n  Values extends FormValues,\n  QueryArg extends FormValues,\n  ResultType,\n>(\n  trigger: TypedMutationTrigger<ResultType, QueryArg, any>,\n  initialValues: Values,\n  options: SubmitFormOptions<Values, QueryArg, ResultType>,\n): SubmitFormHandler<Values>\n\nexport function submitForm<\n  Values extends FormValues,\n  QueryArg extends FormValues,\n  ResultType,\n>(\n  trigger: TypedMutationTrigger<ResultType, QueryArg, any>,\n  initialValues: Values,\n  options?: SubmitFormOptions<Values, QueryArg, ResultType>,\n): SubmitFormHandler<Values> {\n  const {\n    include,\n    onlyDirtyValues = false,\n    then,\n    catch: _catch,\n    finally: _finally,\n  } = options || {}\n  let { exclude = [] } = options || {}\n\n  return (values, helpers) => {\n    let arg =\n      options && options.clean\n        ? options.clean(values as QueryArg & FormValues)\n        : (values as unknown as QueryArg)\n\n    if (onlyDirtyValues) {\n      exclude = [\n        ...exclude,\n        ...getCleanNames(values, initialValues).filter(\n          cleanName => !exclude.includes(cleanName),\n        ),\n      ]\n    }\n\n    if (include) exclude = exclude.filter(name => !include.includes(name))\n\n    if (exclude.length) arg = excludeKeyPaths(arg, exclude) as QueryArg\n\n    trigger(arg)\n      .unwrap()\n      .then(result => {\n        if (then) then(result, values, helpers)\n      })\n      .catch(error => {\n        if (_catch) _catch(error, values, helpers)\n        setFormErrors(error, helpers.setErrors)\n      })\n      .finally(() => {\n        if (_finally) _finally(values, helpers)\n      })\n  }\n}\n\nexport function schemaToFieldValidator(\n  schema: Schema,\n  options?: ValidateOptions,\n): FieldValidator {\n  return async value => {\n    try {\n      await schema.validate(value, options)\n    } catch (error) {\n      if (error instanceof ValidationError) {\n        return error.errors.join(\". \")\n      }\n\n      throw error\n    }\n  }\n}\n\n// Checking if individual fields are dirty is not currently supported.\n// https://github.com/jaredpalmer/formik/issues/1421\nexport function getDirty<Values extends FormValues>(\n  values: Values,\n  initialValues: Values,\n  names?: string[],\n): Record<string, boolean> {\n  if (!names) names = getKeyPaths(values)\n\n  return Object.fromEntries(\n    names.map(name => [name, isDirty(values, initialValues, name)]),\n  )\n}\n\nexport function isDirty<Values extends FormValues>(\n  values: Values,\n  initialValues: Values,\n  name: string,\n): boolean {\n  const value: unknown = getNestedProperty(values, name)\n  const initialValue: unknown = getNestedProperty(initialValues, name)\n\n  return value !== initialValue\n}\n\nexport function getCleanNames<Values extends FormValues>(\n  values: Values,\n  initialValues: Values,\n  names?: string[],\n): string[] {\n  return Object.entries(getDirty(values, initialValues, names))\n    .filter(\n      ([\n        _, // eslint-disable-line @typescript-eslint/no-unused-vars\n        isDirty,\n      ]) => !isDirty,\n    )\n    .map(([name]) => name)\n}\n"],"names":["usePagination","options","page","limit","pagination","_setPagination","useState","value","previousPage","previousLimit","isFormError","error","setFormErrors","setErrors","data","field","errors","submitForm","trigger","initialValues","include","onlyDirtyValues","then","_catch","_finally","exclude","values","helpers","arg","getCleanNames","cleanName","name","excludeKeyPaths","result","schemaToFieldValidator","schema","ValidationError","getDirty","names","getKeyPaths","isDirty","getNestedProperty","initialValue","_"],"mappings":"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"}