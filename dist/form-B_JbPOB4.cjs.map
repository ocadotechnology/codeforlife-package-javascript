{"version":3,"file":"form-B_JbPOB4.cjs","sources":["../src/utils/form.ts"],"sourcesContent":["import type { FieldValidator, FormikHelpers } from \"formik\"\nimport { type Schema, type ValidateOptions, ValidationError } from \"yup\"\nimport type { TypedMutationTrigger } from \"@reduxjs/toolkit/query/react\"\n\nimport { excludeKeyPaths, getKeyPaths, getNestedProperty } from \"./general\"\n\nexport type FormValues = Record<string, any>\n\nexport function isFormError(error: unknown): boolean {\n  return (\n    typeof error === \"object\" &&\n    error !== null &&\n    \"status\" in error &&\n    error.status === 400 &&\n    \"data\" in error &&\n    typeof error.data === \"object\" &&\n    error.data !== null\n  )\n}\n\nexport function setFormErrors(\n  error: unknown,\n  setErrors: (errors: object) => void,\n): void {\n  if (!isFormError(error)) throw error\n\n  const data = Object.fromEntries(\n    Object.entries((error as { data: object }).data).map(([field, errors]) => {\n      if (Array.isArray(errors)) errors = errors.join(\". \")\n      return [field, errors]\n    }),\n  )\n\n  setErrors(data)\n}\n\nexport type SubmitFormOptions<\n  Values extends FormValues,\n  QueryArg extends FormValues,\n  ResultType,\n> = Partial<{\n  exclude: string[]\n  include: string[]\n  onlyDirtyValues: boolean\n  then: (\n    result: ResultType,\n    values: Values,\n    helpers: FormikHelpers<Values>,\n  ) => void\n  catch: (\n    error: unknown,\n    values: Values,\n    helpers: FormikHelpers<Values>,\n  ) => void\n  finally: (values: Values, helpers: FormikHelpers<Values>) => void\n}> &\n  (Values extends QueryArg\n    ? { clean?: (values: Values) => QueryArg }\n    : { clean: (values: Values) => QueryArg })\n\nexport type SubmitFormHandler<Values extends FormValues> = (\n  values: Values,\n  helpers: FormikHelpers<Values>,\n) => void | Promise<any>\n\nexport function submitForm<\n  Values extends QueryArg,\n  QueryArg extends FormValues,\n  ResultType,\n>(\n  trigger: TypedMutationTrigger<ResultType, QueryArg, any>,\n  initialValues: Values,\n  options?: SubmitFormOptions<Values, QueryArg, ResultType>,\n): SubmitFormHandler<Values>\n\nexport function submitForm<\n  Values extends FormValues,\n  QueryArg extends FormValues,\n  ResultType,\n>(\n  trigger: TypedMutationTrigger<ResultType, QueryArg, any>,\n  initialValues: Values,\n  options: SubmitFormOptions<Values, QueryArg, ResultType>,\n): SubmitFormHandler<Values>\n\nexport function submitForm<\n  Values extends FormValues,\n  QueryArg extends FormValues,\n  ResultType,\n>(\n  trigger: TypedMutationTrigger<ResultType, QueryArg, any>,\n  initialValues: Values,\n  options?: SubmitFormOptions<Values, QueryArg, ResultType>,\n): SubmitFormHandler<Values> {\n  const {\n    include,\n    onlyDirtyValues = false,\n    then,\n    catch: _catch,\n    finally: _finally,\n  } = options || {}\n  let { exclude = [] } = options || {}\n\n  return (values, helpers) => {\n    let arg =\n      options && options.clean\n        ? options.clean(values as QueryArg & FormValues)\n        : (values as unknown as QueryArg)\n\n    if (onlyDirtyValues) {\n      exclude = [\n        ...exclude,\n        ...getCleanNames(values, initialValues).filter(\n          cleanName => !exclude.includes(cleanName),\n        ),\n      ]\n    }\n\n    if (include) exclude = exclude.filter(name => !include.includes(name))\n\n    if (exclude.length) arg = excludeKeyPaths(arg, exclude) as QueryArg\n\n    trigger(arg)\n      .unwrap()\n      .then(result => {\n        if (then) then(result, values, helpers)\n      })\n      .catch(error => {\n        if (_catch) _catch(error, values, helpers)\n        setFormErrors(error, helpers.setErrors)\n      })\n      .finally(() => {\n        if (_finally) _finally(values, helpers)\n      })\n  }\n}\n\nexport function schemaToFieldValidator(\n  schema: Schema,\n  options?: ValidateOptions,\n): FieldValidator {\n  return async value => {\n    try {\n      await schema.validate(value, options)\n    } catch (error) {\n      if (error instanceof ValidationError) {\n        return error.errors.join(\". \")\n      }\n\n      throw error\n    }\n  }\n}\n\n// Checking if individual fields are dirty is not currently supported.\n// https://github.com/jaredpalmer/formik/issues/1421\nexport function getDirty<Values extends FormValues>(\n  values: Values,\n  initialValues: Values,\n  names?: string[],\n): Record<string, boolean> {\n  if (!names) names = getKeyPaths(values)\n\n  return Object.fromEntries(\n    names.map(name => [name, isDirty(values, initialValues, name)]),\n  )\n}\n\nexport function isDirty<Values extends FormValues>(\n  values: Values,\n  initialValues: Values,\n  name: string,\n): boolean {\n  const value: unknown = getNestedProperty(values, name)\n  const initialValue: unknown = getNestedProperty(initialValues, name)\n\n  return value !== initialValue\n}\n\nexport function getCleanNames<Values extends FormValues>(\n  values: Values,\n  initialValues: Values,\n  names?: string[],\n): string[] {\n  return Object.entries(getDirty(values, initialValues, names))\n    .filter(\n      ([\n        _, // eslint-disable-line @typescript-eslint/no-unused-vars\n        isDirty,\n      ]) => !isDirty,\n    )\n    .map(([name]) => name)\n}\n"],"names":["isFormError","error","setFormErrors","setErrors","data","field","errors","submitForm","trigger","initialValues","options","include","onlyDirtyValues","then","_catch","_finally","exclude","values","helpers","arg","getCleanNames","cleanName","name","excludeKeyPaths","result","schemaToFieldValidator","schema","value","ValidationError","getDirty","names","getKeyPaths","isDirty","getNestedProperty","initialValue","_"],"mappings":"yKAQO,SAASA,EAAYC,EAAyB,CACnD,OACE,OAAOA,GAAU,UACjBA,IAAU,MACV,WAAYA,GACZA,EAAM,SAAW,KACjB,SAAUA,GACV,OAAOA,EAAM,MAAS,UACtBA,EAAM,OAAS,IAEnB,CAEO,SAASC,EACdD,EACAE,EACM,CACN,GAAI,CAACH,EAAYC,CAAK,EAAG,MAAMA,EAE/B,MAAMG,EAAO,OAAO,YAClB,OAAO,QAASH,EAA2B,IAAI,EAAE,IAAI,CAAC,CAACI,EAAOC,CAAM,KAC9D,MAAM,QAAQA,CAAM,IAAGA,EAASA,EAAO,KAAK,IAAI,GAC7C,CAACD,EAAOC,CAAM,EACtB,CAAA,EAGHH,EAAUC,CAAI,CAChB,CAmDO,SAASG,EAKdC,EACAC,EACAC,EAC2B,CAC3B,KAAM,CACJ,QAAAC,EACA,gBAAAC,EAAkB,GAClB,KAAAC,EACA,MAAOC,EACP,QAASC,CAAA,EACPL,GAAW,CAAA,EACf,GAAI,CAAE,QAAAM,EAAU,EAAC,EAAMN,GAAW,CAAA,EAElC,MAAO,CAACO,EAAQC,IAAY,CAC1B,IAAIC,EACFT,GAAWA,EAAQ,MACfA,EAAQ,MAAMO,CAA+B,EAC5CA,EAEHL,IACFI,EAAU,CACR,GAAGA,EACH,GAAGI,EAAcH,EAAQR,CAAa,EAAE,OACtCY,GAAa,CAACL,EAAQ,SAASK,CAAS,CAAA,CAC1C,GAIAV,MAAmBK,EAAQ,UAAe,CAACL,EAAQ,SAASW,CAAI,CAAC,GAEjEN,EAAQ,SAAQG,EAAMI,EAAAA,gBAAgBJ,EAAKH,CAAO,GAEtDR,EAAQW,CAAG,EACR,OAAA,EACA,KAAKK,GAAU,CACVX,GAAMA,EAAKW,EAAQP,EAAQC,CAAO,CACxC,CAAC,EACA,MAAMjB,GAAS,CACVa,GAAQA,EAAOb,EAAOgB,EAAQC,CAAO,EACzChB,EAAcD,EAAOiB,EAAQ,SAAS,CACxC,CAAC,EACA,QAAQ,IAAM,CACTH,GAAUA,EAASE,EAAQC,CAAO,CACxC,CAAC,CACL,CACF,CAEO,SAASO,EACdC,EACAhB,EACgB,CAChB,MAAO,OAAMiB,GAAS,CACpB,GAAI,CACF,MAAMD,EAAO,SAASC,EAAOjB,CAAO,CACtC,OAAST,EAAO,CACd,GAAIA,aAAiB2B,EAAAA,gBACnB,OAAO3B,EAAM,OAAO,KAAK,IAAI,EAG/B,MAAMA,CACR,CACF,CACF,CAIO,SAAS4B,EACdZ,EACAR,EACAqB,EACyB,CACzB,OAAKA,IAAOA,EAAQC,EAAAA,YAAYd,CAAM,GAE/B,OAAO,YACZa,EAAM,IAAIR,GAAQ,CAACA,EAAMU,EAAQf,EAAQR,EAAea,CAAI,CAAC,CAAC,CAAA,CAElE,CAEO,SAASU,EACdf,EACAR,EACAa,EACS,CACT,MAAMK,EAAiBM,EAAAA,kBAAkBhB,EAAQK,CAAI,EAC/CY,EAAwBD,EAAAA,kBAAkBxB,EAAea,CAAI,EAEnE,OAAOK,IAAUO,CACnB,CAEO,SAASd,EACdH,EACAR,EACAqB,EACU,CACV,OAAO,OAAO,QAAQD,EAASZ,EAAQR,EAAeqB,CAAK,CAAC,EACzD,OACC,CAAC,CACCK,EACAH,CAAA,IACI,CAACA,CAAA,EAER,IAAI,CAAC,CAACV,CAAI,IAAMA,CAAI,CACzB"}